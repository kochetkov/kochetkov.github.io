<!DOCTYPE html>
<html lang="ru" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Ищем уязвимости в коде: теория, практика и перспективы SAST - &#39;&#39;;!--&quot;&lt;kochetkov.vladimir&gt;=&amp;{()}</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html">

        <meta name="author" content="Владимир Кочетков" />
        <meta name="keywords" content="SAST,DAST,IAST,статический анализ кода,анализатор кода,static code analysis,Application Inspector" />
        <meta name="description" content="Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, SAST) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту SAST в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария SAST, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам SAST и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности кода." />

        <meta property="og:site_name" content="&#39;&#39;;!--&quot;&lt;kochetkov.vladimir&gt;=&amp;{()}" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Ищем уязвимости в коде: теория, практика и перспективы SAST"/>
        <meta property="og:url" content="https://kochetkov.github.io/sast-theory-practice-and-prospects.html"/>
        <meta property="og:description" content="Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, SAST) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту SAST в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария SAST, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам SAST и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности кода."/>
        <meta property="article:published_time" content="2016-07-08" />
            <meta property="article:section" content="Блог" />
            <meta property="article:tag" content="SAST" />
            <meta property="article:tag" content="DAST" />
            <meta property="article:tag" content="IAST" />
            <meta property="article:tag" content="статический анализ кода" />
            <meta property="article:tag" content="анализатор кода" />
            <meta property="article:tag" content="static code analysis" />
            <meta property="article:tag" content="Application Inspector" />
            <meta property="article:author" content="Владимир Кочетков" />

    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@kochetkov_v">
        <meta name="twitter:creator" content="@kochetkov_v">
    <meta name="twitter:domain" content="https://kochetkov.github.io">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://kochetkov.github.io/theme/css/bootstrap.kv.min.css" type="text/css"/>
    <link href="https://kochetkov.github.io/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://kochetkov.github.io/theme/css/pygments/monokai.css" rel="stylesheet">
        <link href="https://kochetkov.github.io/theme/css/typogrify.css" rel="stylesheet">
    <link rel="stylesheet" href="https://kochetkov.github.io/theme/css/style.css" type="text/css"/>

        <link href="https://kochetkov.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="&#39;&#39;;!--&quot;&lt;kochetkov.vladimir&gt;=&amp;{()} ATOM Feed"/>



        <link href="https://kochetkov.github.io/feeds/blog.atom.xml" type="application/atom+xml" rel="alternate"
              title="&#39;&#39;;!--&quot;&lt;kochetkov.vladimir&gt;=&amp;{()} Блог ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://kochetkov.github.io/" class="navbar-brand">
&#39;&#39;;!--&quot;&lt;kochetkov.vladimir&gt;=&amp;{()}            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="https://kochetkov.github.io/category/blog.html">Блог</a>
                        </li>
                         <li><a href="https://kochetkov.github.io/pages/whoami-and-wastes.html">
                             whoami &&&nbsp;wastes
                          </a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://kochetkov.github.io/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-8">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html"
                       rel="bookmark"
                       title="Permalink to Ищем уязвимости в коде: теория, практика и перспективы SAST">
                        Ищем уязвимости в коде: теория, практика и перспективы <span class="caps">SAST</span>
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2016-07-08T04:00:00+03:00"> Пт 08 Июль 2016</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="https://kochetkov.github.io/tag/sast.html">SAST</a>
        /
	<a href="https://kochetkov.github.io/tag/dast.html">DAST</a>
        /
	<a href="https://kochetkov.github.io/tag/iast.html">IAST</a>
        /
	<a href="https://kochetkov.github.io/tag/staticheskii-analiz-koda.html">статический анализ кода</a>
        /
	<a href="https://kochetkov.github.io/tag/analizator-koda.html">анализатор кода</a>
        /
	<a href="https://kochetkov.github.io/tag/static-code-analysis.html">static code analysis</a>
        /
	<a href="https://kochetkov.github.io/tag/application-inspector.html">Application Inspector</a>
    <span class="label label-default">Lang</span>
	<a href="https://kochetkov.github.io/sast-theory-practice-and-prospects-en.html">en</a>

</footer><!-- /.post-info -->                    </div>
                </div>
                <p>Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, <span class="caps">SAST</span>) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту <span class="caps">SAST</span> в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария <span class="caps">SAST</span>, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам <span class="caps">SAST</span> и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&nbsp;кода.</p>
<h2>Тьюринг, Райс - вот эти вот&nbsp;все</h2>
<p><span class="caps">TL</span>/<span class="caps">DR</span>: задача статического тестирования защищенности программ алгоритмически&nbsp;неразрешима.</p>
<p>Представьте себе множество полностью абстрактных программ P, которые только и умеют, что зависать на одних наборах входных данных и останавливаться через некоторое число операций на других. Очевидно, что класс P охватывает любые теоретически возможные программы, поскольку это свойство можно приписать любой из&nbsp;них. </p>
<p>Теперь представьте, что одна из таких программ (назовем ее h) является анализатором, умеющим отвечать на простой вопрос: зависает ли произвольная программа p из множества P на заданном наборе данных n? Очевидно, что отвечать на этот вопрос h сможет только завершая свою работу и тем самым сообщая, что p зависает на n. Иными словами, если p(n) не останавливается, то h(p(n)) должна завершить свою работу за конечное число шагов, а если p(n) останавливается, то h(p(n)) должна&nbsp;зависнуть. </p>
<p>Ну, а теперь представьте, что произойдет, если мы попробуем ответить с помощью такого анализатора на вопрос: зависнет ли он сам, в результате анализа самого себя, анализирующего самого себя (ведь p может быть любой программой из P, значит она может быть и самой h)? В этом случае получается, что если h(h(n)) остановится, то анализ h(n) зависает, а если h(h(n))) зависает, то анализ h(n) останавливается. Но ведь h как раз и есть h(n), а, следовательно, мы здесь имеем противоречие и анализатор подобный h не имеет права на&nbsp;существование.</p>
<p>Описанное является вольным изложением доказательства Теоремы останова, сформулированной Алланом Тьюрингом (основоположником современной теоретической информатики) в далеком 1936-м. Данная теорема утверждает, что не существует такой программы, которая могла бы проанализировать другую программу и ответить на вопрос, остановится ли та на заданном наборе входных данных. Хорошо, но можем ли мы построить такую программу, которая дает ответ на вопрос о каких-либо других свойствах&nbsp;программ?</p>
<p>Поскольку множество P включает в себя все возможные программы, мы всегда можем разбить его на два класса (пусть будут A и B) по признаку наличия у программ любого нетривиального инвариантного свойства. Под нетривиальным инвариантным свойством подразумевается такое свойство, которым любая программа множества P либо обладает, либо не обладает и при этом все функционально тождественные программы (дающие одни и те же наборы данных на выходе при одинаковых наборах данных на входе) либо все вместе обладают этим свойством, либо все вместе не&nbsp;обладают.</p>
<p>Давайте представим, что есть некоторый анализатор q, который принимает на вход произвольную программу p множества P и останавливается, если p относится к одному из классов. Пусть, для определенности, это будет класс A. Пусть pa - программа, относящаяся к классу A и зацикливающаяся на любом входе. Выберем также из класса B произвольную программу pb. Для каждой программы p определим программу p&#8217;, получающую на вход данные x и выполняющую следующий&nbsp;алгоритм:</p>
<ol>
<li>p(p)</li>
<li>pb(x)  </li>
</ol>
<p>Теперь построим программу q&#8217;, которая получает на вход произвольную программу p, строит для нее p&#8217; и вычисляет&nbsp;q(p&#8217;). </p>
<p>Если p&#8217; зависает на первом шаге, значит p&#8217; функционально тождественна pa (и относится к классу A), а, следовательно, q&#8217; должна немедленно остановиться. Если p&#8217; проходит первый шаг, то p&#8217; функционально тождественна pb (и относится к классу B), а, следовательно, q&#8217; должна зависнуть. Таким образом, для любой программы p, q&#8217;(p) останавливается тогда, когда p(p) не останавливается. Но в роли p может оказаться и сама q&#8217;, следовательно, p(p) останавливается только тогда, когда p(p) не останавливается. Снова пришли к&nbsp;противоречию. </p>
<p>Утверждение о том, что не существует такой программы, которая могла бы давать ответ на вопрос о наличии любых нетривиальных инвариантных свойств у произвольно взятой программы, доказал ученый Генри Райс в 1953 году. Фактически, его работа обобщает Теорему останова, поскольку свойство останавливаться на заданном наборе данных является нетривиальным и инвариантным. Теорема Райса имеет бесконечное множество практических значений, в зависимости от рассматриваемых свойств: «невозможно с помощью программы классифицировать алгоритм, реализуемый другой программой», «невозможно с помощью программы доказать, что две других программы реализуют один и тот же алгоритм», «невозможно с помощью программы доказать, что другая программа на любых наборах данных не входит в какие-либо состояния…» и т.п. И вот на последнем примере стоит остановиться&nbsp;подробнее.</p>
<p>В момент выполнения любого (как абстрактного, так и реального) алгоритма некоей универсальной выполняющей программой (например, виртуальной машиной, эмулирующей полноценный компьютер с установленной ОС), можно взять снимок этой машины, включая состояние самой выполняемой программы в адресном пространстве машины и ее внешнего окружения, такого, как дисковые накопители, состояние внешних устройств и т.п. и позднее, восстановив его, продолжить выполнение программы с того же самого места. По сути, весь процесс выполнения любой программы, представляет собой череду сменяющихся состояний, последовательность которых как раз и определяется ее кодом. При этом, в случае наличия каких-либо ошибок в конфигурации или реализации, как самой программы, так и выполняющей ее машины, велика вероятность того, что процесс выполнения войдет в состояние, которое изначально не предполагалось&nbsp;разработчиками.</p>
<p>А что есть уязвимость? Это возможность с помощью входных данных заставить процесс выполнения войти в такое состояние, которое приведет к реализации какой-либо из угроз в отношении обрабатываемой процессом информации. Следовательно, можно определить свойство защищенности любой программы, как ее способность в каждый момент времени оставаться, вне зависимости от изначальных входных данных, в рамках заранее определенного множества допустимых состояний, определяющего политику ее безопасности. При этом, задача анализа защищенности программы очевидно сводится к анализу невозможности ее перехода в любое неразрешенное политикой безопасности состояние на произвольном наборе входных данных. То есть, к той самой задаче, алгоритмическая неразрешимость которой была давным-давно доказана Генри&nbsp;Райсом.</p>
<p>Так получается, что же… весь рынок инструментария <span class="caps">SAST</span> – это индустрия обмана? В теории – да, на практике же, всё как обычно - возможны&nbsp;варианты.</p>
<h2>Теория <span class="caps">SAST</span> на&nbsp;практике</h2>
<p>Даже оставаясь в теоретическом поле, вполне возможно сделать несколько послаблений утверждению Райса для реальных программ, выполняющихся в реальных средах. Во-первых, в теоретической информатике под «программой» подразумевается математическая абстракция, эквивалентная машине Тьюринга (МТ) – самому мощному из вычислительных автоматов. Однако же, в реальных программах далеко не каждый фрагмент их кода эквивалентен МТ. Ниже по иерархии вычислительной мощности находятся линейно-ограниченные, стековые и конечные автоматы. Анализ защищенности двух последних вполне возможен, даже в рамках самой теоретической&nbsp;теории.</p>
<p>Во-вторых, отличительной особенностью МТ является то, что ей доступна память бесконечного размера. Именно из этой особенности вытекает невозможность получить все возможные состояния вычислительного процесса – их попросту бесконечное число. Однако, в реальных компьютерах память далеко не бесконечна. Что еще важнее, в реальных программах число состояний, представляющих интерес с точки зрения задачи анализа защищенности, также конечно (хотя и неприлично&nbsp;велико).</p>
<p>В-третьих, вычисление свойств программы по Райсу, является разрешимой проблемой для ряда малых МТ, имеющих небольшое количество состояний и возможных переходов между ними. Сложно себе представить реальную программу, имеющую от 2 до 4 состояний. Однако, такой <em>фрагмент</em> программы представить себе гораздо&nbsp;легче.</p>
<p>Следовательно, возможен эффективный анализ отдельных фрагментов кода программы, попадающих под перечисленных критерии. На практике, это означает,&nbsp;что:</p>
<ol>
<li>
<p>фрагмент кода без циклов и рекурсии может быть всесторонне проанализирован, т.к. эквивалентен конечному&nbsp;автомату;</p>
</li>
<li>
<p>фрагмент с циклами или рекурсией, условие выхода из которых не зависит от входных данных, поддается анализу в качестве конечного или стекового&nbsp;автомата;</p>
</li>
<li>
<p>если условия выхода из цикла или рекурсии зависят от входных данных, длина которых ограничена некоторым разумным порогом, то такой фрагмент в отдельных случаях получится проанализировать как систему линейно-ограниченных автоматов или малых&nbsp;МТ.</p>
</li>
</ol>
<p>А вот все остальное – увы и ах − статическим подходом проанализировать не удастся. Более того, разработка анализатора защищённости исходного кода - это такое направление, работая в котором инженеры ежедневно сталкиваются с трейдофом <span class="caps">EXPSPACE</span> &lt;-&gt; <span class="caps">EXPTIME</span>, а сводя даже частные случаи к субэкспоненте, радуются как дети, потому что это по-настоящему круто. Подумайте над тем, какова будет мощность множества значений переменной parm1 в последней точке&nbsp;выполнения?</p>
<div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">parm1</span> <span class="p">=</span> <span class="n">Request</span><span class="p">.</span><span class="n">Params</span><span class="p">[</span><span class="s">&quot;parm1&quot;</span><span class="p">];</span>
<span class="kt">var</span> <span class="n">count</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Request</span><span class="p">.</span><span class="n">Params</span><span class="p">[</span><span class="s">&quot;count&quot;</span><span class="p">]);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">?</span>
        <span class="n">parm1</span> <span class="p">=</span> <span class="n">parm</span> <span class="p">+</span> <span class="n">i</span><span class="p">.</span><span class="n">ToString</span><span class="p">():</span>
        <span class="n">parm1</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span> <span class="p">+</span> <span class="n">parm</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">parm</span><span class="p">);</span>
</pre></div>


<p>Вот поэтому о теоретических ограничениях можно не особо беспокоиться, поскольку упереться в них на текущих вычислительных мощностях будет крайне затруднительно. Однако же, перечисленные послабления этих ограничений задают правильное направление развития современных статических анализаторов, поэтому иметь в виду их все же&nbsp;стоит.   </p>
<h2><span class="caps">DAST</span>, <span class="caps">IAST</span> и&nbsp;все-все-все</h2>
<p>В противовес статическому подходу, работающему с кодом программы без его фактического выполнения, динамический (Dynamic Application Security Testing, <span class="caps">DAST</span>) подразумевает наличие развернутой среды выполнения приложения и ее прогон на наиболее интересных с точки зрения анализа наборах входных данных. Упрощая, его можно охарактеризовать, как метод «осознанного научного тыка» («давайте передадим программе вот такие данные, характерные вот для такой атаки и посмотрим, что же из этого выйдет»). Его недостатки очевидны: далеко не всегда есть возможность быстро развернуть анализируемую систему (а зачастую и просто собрать), переход системы в какое-либо состояние может быть следствием обработки предыдущих наборов данных, да и для всестороннего анализа поведения реальной системы количество наборов входных данных должно быть настолько велико, что о его конечности можно рассуждать исключительно&nbsp;теоретически.</p>
<p>Относительно недавно перспективным считался подход, комбинирующий преимущества <span class="caps">SAST</span> и <span class="caps">DAST</span> – интерактивный анализ (Interactive…, <span class="caps">IAST</span>). Отличительной особенностью этого подхода является то, что <span class="caps">SAST</span> используется для формирования наборов входных данных и шаблонов ожидаемых результатов, а <span class="caps">DAST</span> выполняет тестирование системы на этих наборах, опционально привлекая к процессу человека-оператора в неоднозначных ситуациях. Ирония этого подхода заключается в том, что он вобрал в себя как преимущества, так и недостатки <span class="caps">SAST</span> и <span class="caps">DAST</span>, что не могло не сказаться на его практической&nbsp;применимости.</p>
<p>Но кто сказал, что в случае динамического анализа нужно выполнять всю программу целиком? Как было показано выше, вполне реально проанализировать значительную часть кода с помощью статического подхода. Что же мешает проанализировать с помощью динамического только оставшиеся фрагменты? Звучит, как&nbsp;план…</p>
<h2>А внутре у ней&nbsp;неонка</h2>
<p>Существует несколько традиционных подходов к статическому анализу, отличающихся моделью, на основе которой анализатор выводит те или иные свойства исследуемого кода. Самым примитивным и очевидным является сигнатурный поиск, основанный на поиске вхождений какого-либо шаблона в синтаксическую модель представления кода (как правило, это либо поток токенов, либо абстрактное синтаксическое дерево). Отдельные реализации этого подхода используют чуть более сложные модели (семантическое дерево, его отображение на граф отдельных потоков данных и т.п.), но в целом этот подход можно рассматривать исключительно в качестве вспомогательного, позволяющего за линейное время выделить в коде подозрительные места для последующей ручной верификации. Подробнее останавливаться на нём не будем, интересующиеся могут обратиться к посвященной ему <a href="https://habrahabr.ru/company/pt/blog/300946/">серии статей</a> Ивана&nbsp;Кочуркина.</p>
<p>Более сложные подходы оперируют уже моделями выполнения (а не представления или семантики) кода. Такие модели, как правило, позволяют получить ответ на вопрос &#8220;может ли контролируемый извне поток данных достичь какой-либо точки выполнения, в которой это приведет к возникновению уязвимости?&#8221;. В большинстве случаев, модель здесь представляет собой вариацию на тему графов <a href="https://en.wikipedia.org/wiki/Control_flow_graph">потока выполнения</a> и <a href="https://en.wikipedia.org/wiki/Data_flow_diagram">потоков данных</a>, либо их комбинацию (например, <a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf">граф свойств кода</a>). Недостаток подобных подходов также очевиден - в любом нетривиальном коде одного только ответа на этот вопрос недостаточно для успешного детектирования уязвимости. Например, для&nbsp;фрагмента:</p>
<div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">requestParam</span> <span class="p">=</span> <span class="n">Request</span><span class="p">.</span><span class="n">Params</span><span class="p">[</span><span class="s">&quot;param&quot;</span><span class="p">];</span>
<span class="kt">var</span> <span class="n">filteredParam</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

<span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">symbol</span> <span class="k">in</span> <span class="n">requestParam</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">symbol</span> <span class="p">&gt;=</span> <span class="sc">&#39;a&#39;</span> <span class="p">&amp;&amp;</span> <span class="n">symbol</span> <span class="p">&lt;=</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">filteredParam</span> <span class="p">+=</span> <span class="n">symbol</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">filteredParam</span><span class="p">);</span>
</pre></div>


<p>такой анализатор выведет из построенной модели утвердительный ответ о достижимости потоком данных <code>Request.Params["param"]</code> точки выполнения <code>Response.Write(filteredParam)</code> и существовании в данной точке уязвимости к <span class="caps">XSS</span>. В то время, как на самом деле, данный поток эффективно фильтруется и не может являться носителем вектора атаки. Существует множество способов покрыть частные случаи, связанные с предварительной обработкой потоков данных, но все они в конечном итоге сводятся к разумному балансу между ложными срабатываниями первого и второго&nbsp;типа.</p>
<p><img alt="Type 1 &amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg"></p>
<p>Каким образом можно минимизировать появление ошибок обоих типов? Для этого необходимо учитывать условия достижимости как потенциально уязвимых точек выполнения, так и множеств значений потоков данных, приходящих в такие точки. На основе этой информации становится возможным построить систему уравнений, множество решений которой даст все возможные наборы входных данных, необходимые для того, чтобы прийти в потенциально уязвимую точку программы. Пересечение этого множества со множеством всех возможных векторов атаки, даст множество всех наборов входных данных, приводящих программу в уязвимое состояние. Звучит отлично, но как получить модель, которая содержала бы всю необходимую&nbsp;информацию?</p>
<h2>Абстрактная интерпретация и символические&nbsp;вычисления</h2>
<p>Допустим, перед нами стоит задача определить, число с каким знаком определяет выражение <code>-42 / 8 * 100500</code>. Самый простой способ - это вычислить данное выражение и убедиться, что получено отрицательное число. Вычисление выражения с вполне определенными значениями всех его аргументов называется конкретным вычислением. Но есть и другой способ решить эту задачу. Давайте на секунду представим, что по какой-то причине у нас нет возможности конкретно вычислить данное выражение. Например, если в него добавилась переменная <code>-42 / 8 * 100500 * x</code>. Определим абстрактную арифметику, в которой результат операций над числами определяется исключительно правилом знака, а значения их аргументов&nbsp;игнорируются:</p>
<div class="highlight"><pre><span></span>(+a) = (+)
(-a) = (-)
(-) * (+) = (-)
(-) / (+) = (-)  
...
(-) + (+) = (+-)
...
</pre></div>


<p>Интерпретируя исходное выражение в рамках данной семантики, получаем: <code>(-) / (+) * (+) * (+)</code> -&gt; <code>(-) * (+) * (+)</code> -&gt; <code>(-) * (+)</code> -&gt; <code>(-)</code>. Этот подход будет давать однозначный ответ на поставленную задачу до тех пор, пока в выражении не появятся операции сложения или вычитания. Давайте дополним нашу арифметику таким образом, чтобы значения аргументов операций также&nbsp;учитывались:</p>
<div class="highlight"><pre><span></span>(-a) * (+b) = (-c)
(-a) / (+b) = (-c)  
...
(-a) + (+b) = 
    a &lt;= b -&gt; (+)
    a &gt;  b -&gt; (-)
...
</pre></div>


<p>Интерпретируя выражение <code>-42 / 8 * 100500 + x</code> в новой семантике получим результат <code>x &gt;= -527625 -&gt; (+), x &lt; -527625 -&gt; (-)</code>.</p>
<p>Описанный выше подход называется <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">абстрактной интерпретацией</a> и формально определяется, как устойчивая аппроксимация семантики выражений, основанная на монотонных функциях над упорядоченными множествами. Говоря более простым языком, это интерпретация выражений без их конкретного вычисления с целью сбора информации в рамках заданного семантического поля. Если мы плавно перейдем от интерпретации отдельных выражений к интерпретации кода программы на каком-либо языке, а в качестве семантического поля определим семантику самого языка, дополненную правилом оперировать всеми входными данными, как неизвестными переменными (символическими значениями), то мы получим подход, именуемый <a href="https://en.wikipedia.org/wiki/Symbolic_execution">&#8220;символическим выполнением&#8221;</a> и лежащий в основе большинства перспективных направлений статического анализа&nbsp;кода.</p>
<p>Именно с помощью символических вычислений становится возможным построение контекстного графа символического вычисления (альтернативное название: граф потока вычислений) - модели, всесторонне описывающей процесс вычисления исследуемой программы. Эта модель была рассмотрена в докладе <a href="http://www.slideshare.net/kochetkov.vladimir/ss-48743308/14">&#8220;Автоматическая генерация патчей для исходного кода&#8221;</a>, а ее применение для анализа защищенности кода - в статье <a href="https://habrahabr.ru/company/pt/blog/224547/">&#8220;Об анализе исходного кода и автоматической генерации эксплоитов&#8221;</a>. Вряд ли имеет смысл рассматривать их повторно в рамках данной статьи. Необходимо лишь отметить, что эта модель позволяет получить условия достижимости как любой точки потока выполнения, так и множеств значений всех приходящих в нее аргументов. То есть - именно то, что требуется нам для решения нашей&nbsp;задачи.</p>
<h2>Поиск уязвимостей на графе потока&nbsp;вычисления</h2>
<p>Формализовав в терминах графа потока вычислений критерии уязвимости к тому или иному классу атак, мы сможем реализовать анализ защищенности кода через разрешение свойств конкретной модели, полученной в результате абстрактной интерпретации исследуемого кода. Например, критерии уязвимости к атакам любых инъекций (SQLi, <span class="caps">XSS</span>, XPATHi, Path Traversal и т.п.) можно формализовать примерно&nbsp;так:</p>
<blockquote>
<p>Пусть C - граф потока вычисления исследуемого&nbsp;кода.</p>
<p>Пусть pvf(t) - достижимая вершина потока управления на C, являющаяся вызовом функции прямой или косвенной интерпретации текста t, соответствующего формальной грамматике&nbsp;G.</p>
<p>Пусть e - поток аргумента входных данных на&nbsp;С. </p>
<p>Пусть De - множество потоков данных на C, порождаемых от e и достижимых в точке вызова&nbsp;pvf(t).</p>
<p>Тогда приложение уязвимо к атакам инъекции в точке вызова pvf(t), если t принадлежит De и множество значений De включает в себя хотя бы одну пару элементов, при которых, в результате их синтаксического разбора в соответствии с грамматикой G, получаются не изоморфные друг-другу&nbsp;деревья.</p>
</blockquote>
<p>Аналогичным образом формализуются уязвимости и к другим классам атак. Однако, здесь необходимо заметить, что не все типы уязвимостей возможно формализовать в рамках какой-либо модели, выводимой только из анализируемого кода. В отдельных случаях может потребоваться дополнительная информация. Например, для формализации уязвимостей к атакам на бизнес-логику, необходимо иметь формализованные правила предметной области приложения, для формализации уязвимостей к атакам на контроль доступа - формализованную политику разграничения доступа и&nbsp;т.п.</p>
<h2>Идеальный сферический анализатор защищенности кода в&nbsp;вакууме</h2>
<p>Давайте теперь ненадолго отвлечемся от суровой реальности и чуть-чуть помечтаем о том, какой функциональностью должно обладать ядро гипотетического Идеального Анализатора (назовем его условно &#8220;<span class="caps">IA</span>&#8221;)?</p>
<p>Во-первых, оно должно вбирать в себя преимущества <span class="caps">SAST</span> и <span class="caps">DAST</span>, не включая при этом их недостатки. Из этого в частности следует, что <span class="caps">IA</span> должен уметь работать исключительно с имеющимся кодом приложения (исходным или бинарным), не требуя при этом его полноты или развертывания приложения в исполняющей среде. Иными словами, он должен поддерживать анализ проектов с отсутствующими внешними зависимостями или же какими-либо другими факторами, препятствующими сборке и развертыванию приложения. При этом, работа с фрагментами кода, имеющего ссылки на отсутствующие зависимости, должна быть реализована в настолько полной мере, насколько это возможно в каждом конкретном случае. С другой стороны, <span class="caps">IA</span> должен уметь эффективно &#8220;уворачиваться&#8221; не только от теоретических ограничений, накладываемых тьюринговой моделью вычислений, но и осуществлять сканирование за разумное время, потребляя разумное количество памяти и придерживаясь по возможности субэкспоненциальной &#8220;весовой&nbsp;категории&#8221;.</p>
<p>Во-вторых, вероятность появления ошибок первого рода должна быть сведена к минимуму за счет построения и решения систем логических уравнений и генерации на выходе работающего вектора атаки, позволяющего пользователю подтвердить существование уязвимости одним&nbsp;действием. </p>
<p>В-третьих, <span class="caps">IA</span> должен эффективно бороться с ошибками второго рода, предоставляя пользователю возможность ручной проверки всех потенциально уязвимых точек потока выполнения, уязвимость которых сам <span class="caps">IA</span> не смог ни подтвердить, ни&nbsp;опровергнуть.</p>
<p>Использование модели, основанной на символических вычислениях, позволяет реализовать все эти требования, что называется &#8220;by-design&#8221;, за исключением той их части, которая касается теоретических ограничений и субэкспонент. И здесь, как нельзя кстати, придется наш план - использовать динамический анализ там, где не справился&nbsp;статический. </p>
<h2>Частичные вычисления, обратные функции и отложенная&nbsp;интерпретация</h2>
<p>Представьте себе, что <span class="caps">IA</span> содержит в себе некоторую базу знаний, описывающую семантику функций преобразования входных данных, реализованных в стандартной библиотеке языка или исполняющей среды приложения, наиболее популярных фреймворках и <span class="caps">CMS</span>. Например, что функции Base64Decode и Base64Encode являются взаимно-обратными, или что каждый вызов StringBuilder.Append добавляет новую строку к уже хранящейся в промежуточной переменной-аккумуляторе этого класса и т.п. Обладая такими знаниями <span class="caps">IA</span> будет избавлен от необходимости «проваливаться» в библиотечный код, анализ которого также попадает под все вычислительные&nbsp;ограничения:</p>
<div class="highlight"><pre><span></span><span class="c1">// Нужное для выполнения условия значение для cond2 будет выведено солвером на основе информации базы знаний об обратных функциях </span>
<span class="k">if</span> <span class="p">(</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="n">Convert</span><span class="p">.</span><span class="n">FromBase64String</span><span class="p">(</span><span class="n">cond2</span><span class="p">))</span> <span class="p">==</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">sb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
    <span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">Request</span><span class="p">.</span><span class="n">Params</span><span class="p">[</span><span class="s">&quot;param&quot;</span><span class="p">]);</span>
    <span class="c1">// Значение sb.ToString будет получено в результаты эмуляции семантики StringBuilder, описанной в базе знаний библиотечных функций</span>
    <span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>    
<span class="p">}</span>
</pre></div>


<p>Но что делать, если в коде встречается вызов функции, не описанной в базе знаний <span class="caps">IA</span>? Давайте представим, что в распоряжении <span class="caps">IA</span> есть некая виртуальная среда-песочница, позволяющая запустить произвольный фрагмент анализируемого кода в заданном контексте и получить результат его выполнения. Назовём это &#8220;частичным вычислением&#8221;. Тогда, перед тем, как честно «провалиться» в неизвестную функцию и начинать её абстрактно интерпретировать, <span class="caps">IA</span> может попробовать проделать трюк, называемый «частичным фаззингом». Его общая идея заключается в предварительной подготовке базы знаний по библиотечным трансформирующим функциям и сочетаниям их последовательных вызовов на заранее известных наборах пробных данных. Имея такую базу, можно выполнить неизвестную функцию на тех же наборах данных и сравнить полученные результаты с образцами из базы знаний. Если результаты выполнения неизвестной функции совпадут с результатами выполнения известной цепочки библиотечных функций, то это будет значить, что <span class="caps">IA</span> теперь известна семантика неизвестной функции и в ее интерпретации нет&nbsp;необходимости.</p>
<p>Если же для какого-то фрагмента известны множества значений всех потоков данных, приходящих в этот фрагмент, а сам фрагмент не содержит опасных операций, то <span class="caps">IA</span> может просто выполнить его на всех возможных потоках данных и использовать полученные результаты вместо абстрактной интерпретации данного фрагмента кода. Причем этот фрагмент может относиться к любому классу вычислительной сложности и это никак не отразится на результатах его выполнения. Более того, даже если множества значений потоков данных, приходящих во фрагмент, заранее неизвестны, <span class="caps">IA</span> может отложить интерпретацию этого фрагмента до тех пор, пока не начнется решение уравнения для конкретной опасной операции. На этапе решения на множество значений входных данных накладывается дополнительное ограничение о наличии во входных данных векторов тех или иных атак, что может позволить предположить также и множество значений входных данных, приходящих в отложенный фрагмент и, тем самым, частично вычислить его на данном&nbsp;этапе.</p>
<p>Даже более того, на этапе решения ничего не мешает <span class="caps">IA</span> взять конечную формулу достижимости опасной точки и ее аргументов (которую проще всего строить в синтаксисе и семантике того же языка, на котором написан анализируемый код) и &#8220;профаззить&#8221; ее всеми известными значениями векторов на предмет получения их подмножества, проходящего через все фильтрующие функции&nbsp;формулы:</p>
<div class="highlight"><pre><span></span><span class="c1">// Ззначение аргумента Response.Write, проходящее через фильтрующую функцию без изменений, может быть получено в результате фаззинга его формулы постановкой в parm1 значений всех возможных векторов XSS </span>
<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">CustomFilterLibrary</span><span class="p">.</span><span class="n">CustomFilter</span><span class="p">.</span><span class="n">Filter</span><span class="p">(</span><span class="n">parm1</span><span class="p">));</span>
</pre></div>


<p>Описанные выше подходы позволяют справиться с анализом значительной части фрагментов тьюринг-полного кода, но требуют существенной инженерной проработки как в части наполнения базы знаний и оптимизации эмулирования семантики стандартных типов, так и в части реализации песочницы для частичного выполнения кода (никто не захочет, чтобы в процессе анализа внезапно выполнилось что-то вроде File.Delete в цикле), а также поддержки фаззинга n-местных неизвестных функций, интеграции концепции частичного вычисления с <span class="caps">SMT</span>-солвером и т.п. Однако же, никаких существенных ограничений на их реализацию нет, в отличии от граблей классического <span class="caps">SAST</span>.</p>
<h2>Когда гадкий duck-typing становится&nbsp;лебедем</h2>
<p><img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg"></p>
<p>Представьте, что нам необходимо проанализировать следующий&nbsp;код:</p>
<div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">argument</span> <span class="p">=</span> <span class="s">&quot;harmless value&quot;</span><span class="p">;</span>

<span class="c1">// UnknownType - тип, объявленный в отсутствующей зависимости </span>
<span class="n">UnknownType</span><span class="p">.</span><span class="n">Property1</span> <span class="p">=</span> <span class="n">parm1</span><span class="p">;</span>
<span class="n">UnknownType</span><span class="p">.</span><span class="n">Property2</span> <span class="p">=</span> <span class="n">UnknownType</span><span class="p">.</span><span class="n">Property1</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">UnknownType</span><span class="p">.</span><span class="n">Property3</span> <span class="p">==</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">argument</span> <span class="p">=</span> <span class="n">UnknownType</span><span class="p">.</span><span class="n">Property2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>
</pre></div>


<p>Человек без труда увидит здесь достижимую уязвимость к <span class="caps">XSS</span>. А вот большинство существующих статических анализаторов ее благополучно прошляпят в связи с тем, что им ничего не известно о типе UnknownType. Однако все, что здесь требуется от <span class="caps">IA</span> - это забыть о статической типизации и перейти к утиной. Семантика интерпретации таких конструкций должна полностью зависеть от контекста их использования. Да, интерпретатор ничего не знает о том, чем является <code>UnknownType.Property1</code> - свойством, полем, или даже делегатом (ссылкой на метод в C#). Но поскольку операции с ней осуществляются как с переменной-мембером какого-то типа, интерпретатору ничего не мешает обрабатывать их именно таким образом. А если, к примеру, далее по коду встретится конструкция <code>UnknownType.Property1()</code>, то ничто не мешает интерпретировать вызов того метода, ссылка на который была ранее присвоена Property1. И так далее, в лучших традициях заводчиков&nbsp;уток-чемпионов.</p>
<h2>Подводя&nbsp;итоги</h2>
<p>Разумеется, есть масса маркетинговых свистелок, которыми один анализатор якобы выгодно отличается от другого, с точки зрения продающей его стороны. Но, согласитесь, в них нет никакого проку, если ядро продукта не в состоянии обеспечить базовую функциональность, ради которой его и будут использовать. А для того, чтобы её обеспечить, анализатор обязан стремиться по своим возможностям к описанному <span class="caps">IA</span>. Иначе ни о какой реальной защищенности на обрабатываемых им проектах и речи быть не&nbsp;может. </p>
<p>Несколько лет назад, один из наших клиентов обратился к нам за проведением анализа защищенности разрабатываемой им системы. В числе вводных данных он предоставил отчет об анализе кода их проекта продуктом, являвшимся на тот момент лидером на рынке <span class="caps">SAST</span>-инструментария. Отчет содержал около двух тысяч записей, большинство из которых оказались в итоге на проверку положительно-ложными срабатываниями. Но самым плохим оказалось то, чего не было в отчете. В результате ручного анализа кода, нами были обнаружены десятки уязвимых мест, пропущенных при сканировании. Использование подобных анализаторов приносит больше вреда, чем пользы, как отнимая время, необходимое для разбора всех ложно-положительных результатов, так и создавая иллюзию защищённости из-за ложно-отрицательных. Этот случай, кстати, стал одной из причин разработки нами собственного&nbsp;анализатора.</p>
<h2><span class="dquo">&#8220;</span>Talk is cheap. Show me the&nbsp;code.&#8221;</h2>
<p>Было бы странным не завершить статью небольшим примером кода, позволяющим проверить степень идеальности того или иного анализатора на практике. Voila - ниже представлен код, включающий в себя все базовые кейсы, покрываемые описанным подходом к абстрактной интерпретации, но не покрываемые более примитивными подходами. Каждый кейс реализован настолько тривиально, насколько это возможно и с минимальным количеством инструкций языка. Это пример для C#/<span class="caps">ASP</span>.Net WebForms, но не содержит какой-либо специфики и легко может быть транслирован в код на любом другом ООП-языке и под любой&nbsp;web-фреймворк. </p>
<div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">parm1</span> <span class="p">=</span> <span class="n">Request</span><span class="p">.</span><span class="n">Params</span><span class="p">[</span><span class="s">&quot;parm1&quot;</span><span class="p">];</span>
<span class="k">const</span> <span class="kt">string</span> <span class="n">cond1</span> <span class="p">=</span> <span class="s">&quot;ZmFsc2U=&quot;</span><span class="p">;</span> <span class="c1">// &quot;false&quot; в base64-кодировке</span>
<span class="n">Action</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">pvo</span> <span class="p">=</span> <span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">;</span>

<span class="c1">// False-negative</span>
<span class="c1">// Анализаторы, не интерпретирующие поток выполнения по потокам данных функционального типа, не сообщат здесь об уязвимости</span>
<span class="n">pvo</span><span class="p">(</span><span class="n">parm1</span><span class="p">);</span>

<span class="c1">// Для анализаторов, требующих компилируемый код, этот фрагмент необходимо удалить</span>
<span class="cp">#region</span>

<span class="kt">var</span> <span class="n">argument</span> <span class="p">=</span> <span class="s">&quot;harmless value&quot;</span><span class="p">;</span>

<span class="n">UnknownType</span><span class="p">.</span><span class="n">Property1</span> <span class="p">=</span> <span class="n">parm1</span><span class="p">;</span>
<span class="n">UnknownType</span><span class="p">.</span><span class="n">Property2</span> <span class="p">=</span> <span class="n">UnknownType</span><span class="p">.</span><span class="n">Property1</span><span class="p">;</span>
<span class="n">UnknownType</span><span class="p">.</span><span class="n">Property3</span> <span class="p">=</span> <span class="n">cond1</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">UnknownType</span><span class="p">.</span><span class="n">Property3</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">argument</span> <span class="p">=</span> <span class="n">UnknownType</span><span class="p">.</span><span class="n">Property2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// False-positive</span>
<span class="c1">// Анализаторы, игнорирующие некомпилируемый код, сообщат здесь об уязвимости</span>
<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>

<span class="cp">#endregion</span>

<span class="c1">// False-positive</span>
<span class="c1">// Анализаторы, не учитывающие условия достижимости точек выполнения, сообщат здесь об уязвимости</span>
<span class="k">if</span> <span class="p">(</span><span class="n">cond1</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">parm1</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// False-positive</span>
<span class="c1">// Анализаторы, не учитывающие семантику стандартных фильтрующих функций, сообщат здесь об уязвимости</span>
<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">WebUtility</span><span class="p">.</span><span class="n">HtmlEncode</span><span class="p">(</span><span class="n">parm1</span><span class="p">));</span>

<span class="c1">// False-positive</span>
<span class="c1">// Анализаторы, не учитывающие семантику нестандартных фильтрующих функций, сообщат здесь об уязвимости</span>
<span class="c1">// (CustomFilter.Filter реализует логику `s.Replace(&quot;&lt;&quot;, string.Empty).Replace(&quot;&gt;&quot;, string.Empty)`)</span>
<span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">CustomFilterLibrary</span><span class="p">.</span><span class="n">CustomFilter</span><span class="p">.</span><span class="n">Filter</span><span class="p">(</span><span class="n">parm1</span><span class="p">));</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="n">Convert</span><span class="p">.</span><span class="n">FromBase64String</span><span class="p">(</span><span class="n">cond1</span><span class="p">))</span> <span class="p">==</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// False-positive</span>
    <span class="c1">// Анализаторы, не учитывающие семантику стандартных кодирующих функций, сообщат здесь об уязвимости</span>
    <span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">parm1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="m">15</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="p">+=</span> <span class="n">i</span> <span class="p">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">!=</span> <span class="m">1725</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// False-positive</span>
    <span class="c1">// Анализаторы, аппроксимирующие или игнорирующие интерпретацию циклов, сообщат здесь об уязвимости</span>
    <span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">parm1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">sb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
<span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">cond1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span> <span class="p">==</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// False-positive</span>
    <span class="c1">// Анализаторы, не интерпретирующие семантику типов стандартной библиотеки, сообщат здесь об уязвимости</span>
    <span class="n">Response</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">parm1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Результатом анализа данного кода должно являться сообщение о единственной уязвимости к атакам <span class="caps">XSS</span> в выражении <code>pvo(parm1)</code>.</p>
<p>Вступить и компилировать с готовым к сканированию проектом можно <a href="https://kochetkov.github.io/uploads/IAMeter.zip">здесь</a>.</p>
<p>Но, как говорится, &#8220;лучше один раз увидеть&#8230;&#8221; и, в первую очередь, мы проверили на соответствие <span class="caps">IA</span> разрабатываемый нами анализатор, по чистой случайности называющийся <a href="http://ai.ptsecurity.ru/"><span class="caps">AI</span></a>:  </p>
<p><a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"><img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"></a></p>
<p>А вы - уже проверили свой?&nbsp;;)</p>
<h2>На правах бонуса для дочитавших до&nbsp;конца</h2>
<p>Мы открываем публичное альфа-тестирование бесплатной утилиты Approof. В нее не включена функциональность анализа кода и не используется весь описанный выше матастафический хардкор, зато включена функциональность выявления в проектах уязвимых внешних компонентов, недостатков конфигурации, чувствительных к разглашению данных, а также внедренных веб-шеллов и вредоносного&nbsp;кода:</p>
<p><img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png"></p>
<p>Скачать утилиту можно на <a href="http://approof.ptsecurity.ru/">официальном сайте</a>. Перед ее использованием обязательно ознакомьтесь с лицензионным соглашением. В ходе анализа, Approof собирает неконфиденциальную статистику по проекту (<span class="caps">CLOC</span>, типы файлов, используемые фреймворки и т.к.) и, опционально, отправляет ее на сервер <span class="caps">PT</span>. Отключить отправку статистики или ознакомиться с сырым json, содержащим собранные данные, можно в разделе About&nbsp;приложения.</p>
            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Комментарии</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'kochetkov'; // required: replace example with your forum shortname

                    var disqus_identifier = 'sast-theory-practice-and-prospects';
                var disqus_url = 'https://kochetkov.github.io/sast-theory-practice-and-prospects.html';

            var disqus_config = function () {
                this.language = "ru";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-4" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">

    <li class="list-group-item"><h4><i class="fa fa-twitter fa-lg"></i><span class="icon-label">Latest Tweets</span></h4></li>
    <div id="twitter_timeline">
        <a class="twitter-timeline" data-chrome="noheader nofooter transparent" href="https://twitter.com/kochetkov_v" data-widget-id="353079324083097600">Tweets by kochetkov_v</a>
    </div>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>



            <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Recent Posts</span></h4>
                <ul class="list-group" id="recentposts">
                    <li class="list-group-item">
                        <a href="https://kochetkov.github.io/webinar-applied-cryptography-pitfalls-1.html">
                            Материалы вебинара &#8220;Подводные камни прикладной криптографии&nbsp;I&#8221;
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html">
                            Ищем уязвимости в коде: теория, практика и перспективы <span class="caps">SAST</span>
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="https://kochetkov.github.io/following-the-tracks-of-phdays-6.html">
                            По следам PHDays <span class="caps">VI</span>
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html">
                            Семинар Positive Development User&nbsp;Group
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="https://kochetkov.github.io/blog-movement.html">
                            Переезд&nbsp;блога
                        </a>
                    </li>
                </ul>
            </li>


            <li class="list-group-item"><a href="https://kochetkov.github.io/"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
                <ul class="list-group list-inline tagcloud" id="tags">
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/analizator-koda.html">
                            анализатор кода
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/application-inspector.html">
                            Application Inspector
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="https://kochetkov.github.io/tag/appsec.html">
                            appsec
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/blog.html">
                            блог
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/dast.html">
                            DAST
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/iast.html">
                            IAST
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/kriptografiia.html">
                            криптография
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="https://kochetkov.github.io/tag/meropriiatiia.html">
                            мероприятия
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="https://kochetkov.github.io/tag/phdays.html">
                            phdays
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="https://kochetkov.github.io/tag/razrabotka.html">
                            разработка
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/sast.html">
                            SAST
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/static-code-analysis.html">
                            static code analysis
                        </a>
                    </li>
                    <li class="list-group-item tag-4">
                        <a href="https://kochetkov.github.io/tag/staticheskii-analiz-koda.html">
                            статический анализ кода
                        </a>
                    </li>
                    <li class="list-group-item tag-1">
                        <a href="https://kochetkov.github.io/tag/vebinary.html">
                            вебинары
                        </a>
                    </li>
                </ul>
            </li>



    <li class="list-group-item"><h4><i class="fa fa-github fa-lg"></i><span class="icon-label">GitHub Repos</span></h4>
        <div id="gh_repos">
            <p class="list-group-item">Status updating...</p>
        </div>
            <a href="https://github.com/kochetkov">@kochetkov</a> on GitHub
    </li>
    </ul>
</section>
            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Владимир Кочетков
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    Содержимое сайа
  распространяется на условиях <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, если явно не оговорено иное. Все материалы отражают частную точку зрения их автора и не могут рассматриваться в качестве официальной позиции каких-либо организаций и сообществ.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer><script src="https://kochetkov.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://kochetkov.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://kochetkov.github.io/theme/js/respond.min.js"></script>

    <!-- GitHub JS -->
    <script type="text/javascript">
        $(document).ready(function () {
            if (!window.jXHR) {
                var jxhr = document.createElement('script');
                jxhr.type = 'text/javascript';
                jxhr.src = 'https://kochetkov.github.io/theme/js/jXHR.js';
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(jxhr, s);
            }

            github.showRepos({
                user: 'kochetkov',
                count: 5,
                skip_forks: false,
                target: '#gh_repos'
            });
        });
    </script>
    <script src="https://kochetkov.github.io/theme/js/github.js" type="text/javascript"></script>
    <!-- End GitHub JS Code -->
    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'kochetkov'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-71486437-1', '');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

</body>
</html>