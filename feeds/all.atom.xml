<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>'';!--"&lt;kochetkov.vladimir&gt;=&amp;{()}</title><link href="https://kochetkov.github.io/" rel="alternate"></link><link href="https://kochetkov.github.io/feeds/all.atom.xml" rel="self"></link><id>https://kochetkov.github.io/</id><updated>2016-10-07T12:00:00+03:00</updated><entry><title>Материалы вебинара “Подводные камни прикладной криптографии I”</title><link href="https://kochetkov.github.io/webinar-applied-cryptography-pitfalls-1.html" rel="alternate"></link><published>2016-10-07T12:00:00+03:00</published><updated>2016-10-07T12:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-10-07:/webinar-applied-cryptography-pitfalls-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о генерации криптографических случайных чисел в различных языках (включая многострадальный &lt;span class="caps"&gt;PHP&lt;/span&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;неплохая &lt;a href="https://jazzy.id.au/tags/prng.html"&gt;серия статей&lt;/a&gt; о техниках взлома различных &lt;span class="caps"&gt;PRNG&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks"&gt;описание&lt;/a&gt; атаки удлинения&amp;nbsp;сообщения;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth"&gt;описание&lt;/a&gt; атаки на оракул&amp;nbsp;дополнения.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S: Было бы совсем здорово, если бы участники вебинара не поленились черкнуть пару слов о том, что им (не) понравилось и какие темы были бы им интересны в следующей части&amp;nbsp;вебинара.&lt;/p&gt;</content><category term="вебинары"></category><category term="криптография"></category></entry><entry><title>Ищем уязвимости в коде: теория, практика и перспективы SAST</title><link href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html" rel="alternate"></link><published>2016-07-08T04:00:00+03:00</published><updated>2016-07-08T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-07-08:/sast-theory-practice-and-prospects.html</id><summary type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;
&lt;h2&gt;Тьюринг, Райс - вот эти вот&amp;nbsp;все&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;/&lt;span class="caps"&gt;DR&lt;/span&gt;: задача статического тестирования защищенности программ алгоритмически&amp;nbsp;неразрешима.&lt;/p&gt;
&lt;p&gt;Представьте себе множество полностью абстрактных программ P, которые только и умеют, что зависать на одних наборах входных данных и останавливаться через некоторое число операций на других. Очевидно, что класс P охватывает любые теоретически возможные программы, поскольку это свойство можно приписать любой из&amp;nbsp;них. &lt;/p&gt;
&lt;p&gt;Теперь представьте, что одна из таких программ (назовем ее h) является анализатором, умеющим отвечать на простой вопрос: зависает ли произвольная программа p из множества P на заданном наборе данных n? Очевидно, что отвечать на этот вопрос h сможет только завершая свою работу и тем самым сообщая, что p зависает на n. Иными словами, если p(n) не останавливается, то h(p(n)) должна завершить свою работу за конечное число шагов, а если p(n) останавливается, то h(p(n)) должна&amp;nbsp;зависнуть. &lt;/p&gt;
&lt;p&gt;Ну, а теперь представьте, что произойдет, если мы попробуем ответить с помощью такого анализатора на вопрос: зависнет ли он сам, в результате анализа самого себя, анализирующего самого себя (ведь p может быть любой программой из P, значит она может быть и самой h)? В этом случае получается, что если h(h(n)) остановится, то анализ h(n) зависает, а если h(h(n))) зависает, то анализ h(n) останавливается. Но ведь h как раз и есть h(n), а, следовательно, мы здесь имеем противоречие и анализатор подобный h не имеет права на&amp;nbsp;существование.&lt;/p&gt;
&lt;p&gt;Описанное является вольным изложением доказательства Теоремы останова, сформулированной Алланом Тьюрингом (основоположником современной теоретической информатики) в далеком 1936-м. Данная теорема утверждает, что не существует такой программы, которая могла бы проанализировать другую программу и ответить на вопрос, остановится ли та на заданном наборе входных данных. Хорошо, но можем ли мы построить такую программу, которая дает ответ на вопрос о каких-либо других свойствах&amp;nbsp;программ?&lt;/p&gt;
&lt;p&gt;Поскольку множество P включает в себя все возможные программы, мы всегда можем разбить его на два класса (пусть будут A и B) по признаку наличия у программ любого нетривиального инвариантного свойства. Под нетривиальным инвариантным свойством подразумевается такое свойство, которым любая программа множества P либо обладает, либо не обладает и при этом все функционально тождественные программы (дающие одни и те же наборы данных на выходе при одинаковых наборах данных на входе) либо все вместе обладают этим свойством, либо все вместе не&amp;nbsp;обладают.&lt;/p&gt;
&lt;p&gt;Давайте представим, что есть некоторый анализатор q, который принимает на вход произвольную программу p множества P и останавливается, если p относится к одному из классов. Пусть, для определенности, это будет класс A. Пусть pa - программа, относящаяся к классу A и зацикливающаяся на любом входе. Выберем также из класса B произвольную программу pb. Для каждой программы p определим программу p&amp;#8217;, получающую на вход данные x и выполняющую следующий&amp;nbsp;алгоритм:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p(p)&lt;/li&gt;
&lt;li&gt;pb(x)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Теперь построим программу q&amp;#8217;, которая получает на вход произвольную программу p, строит для нее p&amp;#8217; и вычисляет&amp;nbsp;q(p&amp;#8217;). &lt;/p&gt;
&lt;p&gt;Если p&amp;#8217; зависает на первом шаге, значит p&amp;#8217; функционально тождественна pa (и относится к классу A), а, следовательно, q&amp;#8217; должна немедленно остановиться. Если p&amp;#8217; проходит первый шаг, то p&amp;#8217; функционально тождественна pb (и относится к классу B), а, следовательно, q&amp;#8217; должна зависнуть. Таким образом, для любой программы p, q&amp;#8217;(p) останавливается тогда, когда p(p) не останавливается. Но в роли p может оказаться и сама q&amp;#8217;, следовательно, p(p) останавливается только тогда, когда p(p) не останавливается. Снова пришли к&amp;nbsp;противоречию. &lt;/p&gt;
&lt;p&gt;Утверждение о том, что не существует такой программы, которая могла бы давать ответ на вопрос о наличии любых нетривиальных инвариантных свойств у произвольно взятой программы, доказал ученый Генри Райс в 1953 году. Фактически, его работа обобщает Теорему останова, поскольку свойство останавливаться на заданном наборе данных является нетривиальным и инвариантным. Теорема Райса имеет бесконечное множество практических значений, в зависимости от рассматриваемых свойств: «невозможно с помощью программы классифицировать алгоритм, реализуемый другой программой», «невозможно с помощью программы доказать, что две других программы реализуют один и тот же алгоритм», «невозможно с помощью программы доказать, что другая программа на любых наборах данных не входит в какие-либо состояния…» и т.п. И вот на последнем примере стоит остановиться&amp;nbsp;подробнее.&lt;/p&gt;
&lt;p&gt;В момент выполнения любого (как абстрактного, так и реального) алгоритма некоей универсальной выполняющей программой (например, виртуальной машиной, эмулирующей полноценный компьютер с установленной ОС), можно взять снимок этой машины, включая состояние самой выполняемой программы в адресном пространстве машины и ее внешнего окружения, такого, как дисковые накопители, состояние внешних устройств и т.п. и позднее, восстановив его, продолжить выполнение программы с того же самого места. По сути, весь процесс выполнения любой программы, представляет собой череду сменяющихся состояний, последовательность которых как раз и определяется ее кодом. При этом, в случае наличия каких-либо ошибок в конфигурации или реализации, как самой программы, так и выполняющей ее машины, велика вероятность того, что процесс выполнения войдет в состояние, которое изначально не предполагалось&amp;nbsp;разработчиками.&lt;/p&gt;
&lt;p&gt;А что есть уязвимость? Это возможность с помощью входных данных заставить процесс выполнения войти в такое состояние, которое приведет к реализации какой-либо из угроз в отношении обрабатываемой процессом информации. Следовательно, можно определить свойство защищенности любой программы, как ее способность в каждый момент времени оставаться, вне зависимости от изначальных входных данных, в рамках заранее определенного множества допустимых состояний, определяющего политику ее безопасности. При этом, задача анализа защищенности программы очевидно сводится к анализу невозможности ее перехода в любое неразрешенное политикой безопасности состояние на произвольном наборе входных данных. То есть, к той самой задаче, алгоритмическая неразрешимость которой была давным-давно доказана Генри&amp;nbsp;Райсом.&lt;/p&gt;
&lt;p&gt;Так получается, что же… весь рынок инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt; – это индустрия обмана? В теории – да, на практике же, всё как обычно - возможны&amp;nbsp;варианты.&lt;/p&gt;
&lt;h2&gt;Теория &lt;span class="caps"&gt;SAST&lt;/span&gt; на&amp;nbsp;практике&lt;/h2&gt;
&lt;p&gt;Даже оставаясь в теоретическом поле, вполне возможно сделать несколько послаблений утверждению Райса для реальных программ, выполняющихся в реальных средах. Во-первых, в теоретической информатике под «программой» подразумевается математическая абстракция, эквивалентная машине Тьюринга (МТ) – самому мощному из вычислительных автоматов. Однако же, в реальных программах далеко не каждый фрагмент их кода эквивалентен МТ. Ниже по иерархии вычислительной мощности находятся линейно-ограниченные, стековые и конечные автоматы. Анализ защищенности двух последних вполне возможен, даже в рамках самой теоретической&amp;nbsp;теории.&lt;/p&gt;
&lt;p&gt;Во-вторых, отличительной особенностью МТ является то, что ей доступна память бесконечного размера. Именно из этой особенности вытекает невозможность получить все возможные состояния вычислительного процесса – их попросту бесконечное число. Однако, в реальных компьютерах память далеко не бесконечна. Что еще важнее, в реальных программах число состояний, представляющих интерес с точки зрения задачи анализа защищенности, также конечно (хотя и неприлично&amp;nbsp;велико).&lt;/p&gt;
&lt;p&gt;В-третьих, вычисление свойств программы по Райсу, является разрешимой проблемой для ряда малых МТ, имеющих небольшое количество состояний и возможных переходов между ними. Сложно себе представить реальную программу, имеющую от 2 до 4 состояний. Однако, такой &lt;em&gt;фрагмент&lt;/em&gt; программы представить себе гораздо&amp;nbsp;легче.&lt;/p&gt;
&lt;p&gt;Следовательно, возможен эффективный анализ отдельных фрагментов кода программы, попадающих под перечисленных критерии. На практике, это означает,&amp;nbsp;что:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;фрагмент кода без циклов и рекурсии может быть всесторонне проанализирован, т.к. эквивалентен конечному&amp;nbsp;автомату;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;фрагмент с циклами или рекурсией, условие выхода из которых не зависит от входных данных, поддается анализу в качестве конечного или стекового&amp;nbsp;автомата;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;если условия выхода из цикла или рекурсии зависят от входных данных, длина которых ограничена некоторым разумным порогом, то такой фрагмент в отдельных случаях получится проанализировать как систему линейно-ограниченных автоматов или малых&amp;nbsp;МТ.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;А вот все остальное – увы и ах − статическим подходом проанализировать не удастся. Более того, разработка анализатора защищённости исходного кода - это такое направление, работая в котором инженеры ежедневно сталкиваются с трейдофом &lt;span class="caps"&gt;EXPSPACE&lt;/span&gt; &amp;lt;-&amp;gt; &lt;span class="caps"&gt;EXPTIME&lt;/span&gt;, а сводя даже частные случаи к субэкспоненте, радуются как дети, потому что это по-настоящему круто. Подумайте над тем, какова будет мощность множества значений переменной parm1 в последней точке&amp;nbsp;выполнения?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Вот поэтому о теоретических ограничениях можно не особо беспокоиться, поскольку упереться в них на текущих вычислительных мощностях будет крайне затруднительно. Однако же, перечисленные послабления этих ограничений задают правильное направление развития современных статических анализаторов, поэтому иметь в виду их все же&amp;nbsp;стоит.   &lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAST&lt;/span&gt;, &lt;span class="caps"&gt;IAST&lt;/span&gt; и&amp;nbsp;все-все-все&lt;/h2&gt;
&lt;p&gt;В противовес статическому подходу, работающему с кодом программы без его фактического выполнения, динамический (Dynamic Application Security Testing, &lt;span class="caps"&gt;DAST&lt;/span&gt;) подразумевает наличие развернутой среды выполнения приложения и ее прогон на наиболее интересных с точки зрения анализа наборах входных данных. Упрощая, его можно охарактеризовать, как метод «осознанного научного тыка» («давайте передадим программе вот такие данные, характерные вот для такой атаки и посмотрим, что же из этого выйдет»). Его недостатки очевидны: далеко не всегда есть возможность быстро развернуть анализируемую систему (а зачастую и просто собрать), переход системы в какое-либо состояние может быть следствием обработки предыдущих наборов данных, да и для всестороннего анализа поведения реальной системы количество наборов входных данных должно быть настолько велико, что о его конечности можно рассуждать исключительно&amp;nbsp;теоретически.&lt;/p&gt;
&lt;p&gt;Относительно недавно перспективным считался подход, комбинирующий преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt; – интерактивный анализ (Interactive…, &lt;span class="caps"&gt;IAST&lt;/span&gt;). Отличительной особенностью этого подхода является то, что &lt;span class="caps"&gt;SAST&lt;/span&gt; используется для формирования наборов входных данных и шаблонов ожидаемых результатов, а &lt;span class="caps"&gt;DAST&lt;/span&gt; выполняет тестирование системы на этих наборах, опционально привлекая к процессу человека-оператора в неоднозначных ситуациях. Ирония этого подхода заключается в том, что он вобрал в себя как преимущества, так и недостатки &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, что не могло не сказаться на его практической&amp;nbsp;применимости.&lt;/p&gt;
&lt;p&gt;Но кто сказал, что в случае динамического анализа нужно выполнять всю программу целиком? Как было показано выше, вполне реально проанализировать значительную часть кода с помощью статического подхода. Что же мешает проанализировать с помощью динамического только оставшиеся фрагменты? Звучит, как&amp;nbsp;план…&lt;/p&gt;
&lt;h2&gt;А внутре у ней&amp;nbsp;неонка&lt;/h2&gt;
&lt;p&gt;Существует несколько традиционных подходов к статическому анализу, отличающихся моделью, на основе которой анализатор выводит те или иные свойства исследуемого кода. Самым примитивным и очевидным является сигнатурный поиск, основанный на поиске вхождений какого-либо шаблона в синтаксическую модель представления кода (как правило, это либо поток токенов, либо абстрактное синтаксическое дерево). Отдельные реализации этого подхода используют чуть более сложные модели (семантическое дерево, его отображение на граф отдельных потоков данных и т.п.), но в целом этот подход можно рассматривать исключительно в качестве вспомогательного, позволяющего за линейное время выделить в коде подозрительные места для последующей ручной верификации. Подробнее останавливаться на нём не будем, интересующиеся могут обратиться к посвященной ему &lt;a href="https://habrahabr.ru/company/pt/blog/300946/"&gt;серии статей&lt;/a&gt; Ивана&amp;nbsp;Кочуркина.&lt;/p&gt;
&lt;p&gt;Более сложные подходы оперируют уже моделями выполнения (а не представления или семантики) кода. Такие модели, как правило, позволяют получить ответ на вопрос &amp;#8220;может ли контролируемый извне поток данных достичь какой-либо точки выполнения, в которой это приведет к возникновению уязвимости?&amp;#8221;. В большинстве случаев, модель здесь представляет собой вариацию на тему графов &lt;a href="https://en.wikipedia.org/wiki/Control_flow_graph"&gt;потока выполнения&lt;/a&gt; и &lt;a href="https://en.wikipedia.org/wiki/Data_flow_diagram"&gt;потоков данных&lt;/a&gt;, либо их комбинацию (например, &lt;a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf"&gt;граф свойств кода&lt;/a&gt;). Недостаток подобных подходов также очевиден - в любом нетривиальном коде одного только ответа на этот вопрос недостаточно для успешного детектирования уязвимости. Например, для&amp;nbsp;фрагмента:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filteredParam&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;такой анализатор выведет из построенной модели утвердительный ответ о достижимости потоком данных &lt;code&gt;Request.Params["param"]&lt;/code&gt; точки выполнения &lt;code&gt;Response.Write(filteredParam)&lt;/code&gt; и существовании в данной точке уязвимости к &lt;span class="caps"&gt;XSS&lt;/span&gt;. В то время, как на самом деле, данный поток эффективно фильтруется и не может являться носителем вектора атаки. Существует множество способов покрыть частные случаи, связанные с предварительной обработкой потоков данных, но все они в конечном итоге сводятся к разумному балансу между ложными срабатываниями первого и второго&amp;nbsp;типа.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Type 1 &amp;amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Каким образом можно минимизировать появление ошибок обоих типов? Для этого необходимо учитывать условия достижимости как потенциально уязвимых точек выполнения, так и множеств значений потоков данных, приходящих в такие точки. На основе этой информации становится возможным построить систему уравнений, множество решений которой даст все возможные наборы входных данных, необходимые для того, чтобы прийти в потенциально уязвимую точку программы. Пересечение этого множества со множеством всех возможных векторов атаки, даст множество всех наборов входных данных, приводящих программу в уязвимое состояние. Звучит отлично, но как получить модель, которая содержала бы всю необходимую&amp;nbsp;информацию?&lt;/p&gt;
&lt;h2&gt;Абстрактная интерпретация и символические&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Допустим, перед нами стоит задача определить, число с каким знаком определяет выражение &lt;code&gt;-42 / 8 * 100500&lt;/code&gt;. Самый простой способ - это вычислить данное выражение и убедиться, что получено отрицательное число. Вычисление выражения с вполне определенными значениями всех его аргументов называется конкретным вычислением. Но есть и другой способ решить эту задачу. Давайте на секунду представим, что по какой-то причине у нас нет возможности конкретно вычислить данное выражение. Например, если в него добавилась переменная &lt;code&gt;-42 / 8 * 100500 * x&lt;/code&gt;. Определим абстрактную арифметику, в которой результат операций над числами определяется исключительно правилом знака, а значения их аргументов&amp;nbsp;игнорируются:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(+a) = (+)
(-a) = (-)
(-) * (+) = (-)
(-) / (+) = (-)  
...
(-) + (+) = (+-)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Интерпретируя исходное выражение в рамках данной семантики, получаем: &lt;code&gt;(-) / (+) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-)&lt;/code&gt;. Этот подход будет давать однозначный ответ на поставленную задачу до тех пор, пока в выражении не появятся операции сложения или вычитания. Давайте дополним нашу арифметику таким образом, чтобы значения аргументов операций также&amp;nbsp;учитывались:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(-a) * (+b) = (-c)
(-a) / (+b) = (-c)  
...
(-a) + (+b) = 
    a &amp;lt;= b -&amp;gt; (+)
    a &amp;gt;  b -&amp;gt; (-)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Интерпретируя выражение &lt;code&gt;-42 / 8 * 100500 + x&lt;/code&gt; в новой семантике получим результат &lt;code&gt;x &amp;gt;= -527625 -&amp;gt; (+), x &amp;lt; -527625 -&amp;gt; (-)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Описанный выше подход называется &lt;a href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;абстрактной интерпретацией&lt;/a&gt; и формально определяется, как устойчивая аппроксимация семантики выражений, основанная на монотонных функциях над упорядоченными множествами. Говоря более простым языком, это интерпретация выражений без их конкретного вычисления с целью сбора информации в рамках заданного семантического поля. Если мы плавно перейдем от интерпретации отдельных выражений к интерпретации кода программы на каком-либо языке, а в качестве семантического поля определим семантику самого языка, дополненную правилом оперировать всеми входными данными, как неизвестными переменными (символическими значениями), то мы получим подход, именуемый &lt;a href="https://en.wikipedia.org/wiki/Symbolic_execution"&gt;&amp;#8220;символическим выполнением&amp;#8221;&lt;/a&gt; и лежащий в основе большинства перспективных направлений статического анализа&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Именно с помощью символических вычислений становится возможным построение контекстного графа символического вычисления (альтернативное название: граф потока вычислений) - модели, всесторонне описывающей процесс вычисления исследуемой программы. Эта модель была рассмотрена в докладе &lt;a href="http://www.slideshare.net/kochetkov.vladimir/ss-48743308/14"&gt;&amp;#8220;Автоматическая генерация патчей для исходного кода&amp;#8221;&lt;/a&gt;, а ее применение для анализа защищенности кода - в статье &lt;a href="https://habrahabr.ru/company/pt/blog/224547/"&gt;&amp;#8220;Об анализе исходного кода и автоматической генерации эксплоитов&amp;#8221;&lt;/a&gt;. Вряд ли имеет смысл рассматривать их повторно в рамках данной статьи. Необходимо лишь отметить, что эта модель позволяет получить условия достижимости как любой точки потока выполнения, так и множеств значений всех приходящих в нее аргументов. То есть - именно то, что требуется нам для решения нашей&amp;nbsp;задачи.&lt;/p&gt;
&lt;h2&gt;Поиск уязвимостей на графе потока&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Формализовав в терминах графа потока вычислений критерии уязвимости к тому или иному классу атак, мы сможем реализовать анализ защищенности кода через разрешение свойств конкретной модели, полученной в результате абстрактной интерпретации исследуемого кода. Например, критерии уязвимости к атакам любых инъекций (SQLi, &lt;span class="caps"&gt;XSS&lt;/span&gt;, XPATHi, Path Traversal и т.п.) можно формализовать примерно&amp;nbsp;так:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Пусть C - граф потока вычисления исследуемого&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Пусть pvf(t) - достижимая вершина потока управления на C, являющаяся вызовом функции прямой или косвенной интерпретации текста t, соответствующего формальной грамматике&amp;nbsp;G.&lt;/p&gt;
&lt;p&gt;Пусть e - поток аргумента входных данных на&amp;nbsp;С. &lt;/p&gt;
&lt;p&gt;Пусть De - множество потоков данных на C, порождаемых от e и достижимых в точке вызова&amp;nbsp;pvf(t).&lt;/p&gt;
&lt;p&gt;Тогда приложение уязвимо к атакам инъекции в точке вызова pvf(t), если t принадлежит De и множество значений De включает в себя хотя бы одну пару элементов, при которых, в результате их синтаксического разбора в соответствии с грамматикой G, получаются не изоморфные друг-другу&amp;nbsp;деревья.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Аналогичным образом формализуются уязвимости и к другим классам атак. Однако, здесь необходимо заметить, что не все типы уязвимостей возможно формализовать в рамках какой-либо модели, выводимой только из анализируемого кода. В отдельных случаях может потребоваться дополнительная информация. Например, для формализации уязвимостей к атакам на бизнес-логику, необходимо иметь формализованные правила предметной области приложения, для формализации уязвимостей к атакам на контроль доступа - формализованную политику разграничения доступа и&amp;nbsp;т.п.&lt;/p&gt;
&lt;h2&gt;Идеальный сферический анализатор защищенности кода в&amp;nbsp;вакууме&lt;/h2&gt;
&lt;p&gt;Давайте теперь ненадолго отвлечемся от суровой реальности и чуть-чуть помечтаем о том, какой функциональностью должно обладать ядро гипотетического Идеального Анализатора (назовем его условно &amp;#8220;&lt;span class="caps"&gt;IA&lt;/span&gt;&amp;#8221;)?&lt;/p&gt;
&lt;p&gt;Во-первых, оно должно вбирать в себя преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, не включая при этом их недостатки. Из этого в частности следует, что &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь работать исключительно с имеющимся кодом приложения (исходным или бинарным), не требуя при этом его полноты или развертывания приложения в исполняющей среде. Иными словами, он должен поддерживать анализ проектов с отсутствующими внешними зависимостями или же какими-либо другими факторами, препятствующими сборке и развертыванию приложения. При этом, работа с фрагментами кода, имеющего ссылки на отсутствующие зависимости, должна быть реализована в настолько полной мере, насколько это возможно в каждом конкретном случае. С другой стороны, &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь эффективно &amp;#8220;уворачиваться&amp;#8221; не только от теоретических ограничений, накладываемых тьюринговой моделью вычислений, но и осуществлять сканирование за разумное время, потребляя разумное количество памяти и придерживаясь по возможности субэкспоненциальной &amp;#8220;весовой&amp;nbsp;категории&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Во-вторых, вероятность появления ошибок первого рода должна быть сведена к минимуму за счет построения и решения систем логических уравнений и генерации на выходе работающего вектора атаки, позволяющего пользователю подтвердить существование уязвимости одним&amp;nbsp;действием. &lt;/p&gt;
&lt;p&gt;В-третьих, &lt;span class="caps"&gt;IA&lt;/span&gt; должен эффективно бороться с ошибками второго рода, предоставляя пользователю возможность ручной проверки всех потенциально уязвимых точек потока выполнения, уязвимость которых сам &lt;span class="caps"&gt;IA&lt;/span&gt; не смог ни подтвердить, ни&amp;nbsp;опровергнуть.&lt;/p&gt;
&lt;p&gt;Использование модели, основанной на символических вычислениях, позволяет реализовать все эти требования, что называется &amp;#8220;by-design&amp;#8221;, за исключением той их части, которая касается теоретических ограничений и субэкспонент. И здесь, как нельзя кстати, придется наш план - использовать динамический анализ там, где не справился&amp;nbsp;статический. &lt;/p&gt;
&lt;h2&gt;Частичные вычисления, обратные функции и отложенная&amp;nbsp;интерпретация&lt;/h2&gt;
&lt;p&gt;Представьте себе, что &lt;span class="caps"&gt;IA&lt;/span&gt; содержит в себе некоторую базу знаний, описывающую семантику функций преобразования входных данных, реализованных в стандартной библиотеке языка или исполняющей среды приложения, наиболее популярных фреймворках и &lt;span class="caps"&gt;CMS&lt;/span&gt;. Например, что функции Base64Decode и Base64Encode являются взаимно-обратными, или что каждый вызов StringBuilder.Append добавляет новую строку к уже хранящейся в промежуточной переменной-аккумуляторе этого класса и т.п. Обладая такими знаниями &lt;span class="caps"&gt;IA&lt;/span&gt; будет избавлен от необходимости «проваливаться» в библиотечный код, анализ которого также попадает под все вычислительные&amp;nbsp;ограничения:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Нужное для выполнения условия значение для cond2 будет выведено солвером на основе информации базы знаний об обратных функциях &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// Значение sb.ToString будет получено в результаты эмуляции семантики StringBuilder, описанной в базе знаний библиотечных функций&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Но что делать, если в коде встречается вызов функции, не описанной в базе знаний &lt;span class="caps"&gt;IA&lt;/span&gt;? Давайте представим, что в распоряжении &lt;span class="caps"&gt;IA&lt;/span&gt; есть некая виртуальная среда-песочница, позволяющая запустить произвольный фрагмент анализируемого кода в заданном контексте и получить результат его выполнения. Назовём это &amp;#8220;частичным вычислением&amp;#8221;. Тогда, перед тем, как честно «провалиться» в неизвестную функцию и начинать её абстрактно интерпретировать, &lt;span class="caps"&gt;IA&lt;/span&gt; может попробовать проделать трюк, называемый «частичным фаззингом». Его общая идея заключается в предварительной подготовке базы знаний по библиотечным трансформирующим функциям и сочетаниям их последовательных вызовов на заранее известных наборах пробных данных. Имея такую базу, можно выполнить неизвестную функцию на тех же наборах данных и сравнить полученные результаты с образцами из базы знаний. Если результаты выполнения неизвестной функции совпадут с результатами выполнения известной цепочки библиотечных функций, то это будет значить, что &lt;span class="caps"&gt;IA&lt;/span&gt; теперь известна семантика неизвестной функции и в ее интерпретации нет&amp;nbsp;необходимости.&lt;/p&gt;
&lt;p&gt;Если же для какого-то фрагмента известны множества значений всех потоков данных, приходящих в этот фрагмент, а сам фрагмент не содержит опасных операций, то &lt;span class="caps"&gt;IA&lt;/span&gt; может просто выполнить его на всех возможных потоках данных и использовать полученные результаты вместо абстрактной интерпретации данного фрагмента кода. Причем этот фрагмент может относиться к любому классу вычислительной сложности и это никак не отразится на результатах его выполнения. Более того, даже если множества значений потоков данных, приходящих во фрагмент, заранее неизвестны, &lt;span class="caps"&gt;IA&lt;/span&gt; может отложить интерпретацию этого фрагмента до тех пор, пока не начнется решение уравнения для конкретной опасной операции. На этапе решения на множество значений входных данных накладывается дополнительное ограничение о наличии во входных данных векторов тех или иных атак, что может позволить предположить также и множество значений входных данных, приходящих в отложенный фрагмент и, тем самым, частично вычислить его на данном&amp;nbsp;этапе.&lt;/p&gt;
&lt;p&gt;Даже более того, на этапе решения ничего не мешает &lt;span class="caps"&gt;IA&lt;/span&gt; взять конечную формулу достижимости опасной точки и ее аргументов (которую проще всего строить в синтаксисе и семантике того же языка, на котором написан анализируемый код) и &amp;#8220;профаззить&amp;#8221; ее всеми известными значениями векторов на предмет получения их подмножества, проходящего через все фильтрующие функции&amp;nbsp;формулы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Ззначение аргумента Response.Write, проходящее через фильтрующую функцию без изменений, может быть получено в результате фаззинга его формулы постановкой в parm1 значений всех возможных векторов XSS &lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Описанные выше подходы позволяют справиться с анализом значительной части фрагментов тьюринг-полного кода, но требуют существенной инженерной проработки как в части наполнения базы знаний и оптимизации эмулирования семантики стандартных типов, так и в части реализации песочницы для частичного выполнения кода (никто не захочет, чтобы в процессе анализа внезапно выполнилось что-то вроде File.Delete в цикле), а также поддержки фаззинга n-местных неизвестных функций, интеграции концепции частичного вычисления с &lt;span class="caps"&gt;SMT&lt;/span&gt;-солвером и т.п. Однако же, никаких существенных ограничений на их реализацию нет, в отличии от граблей классического &lt;span class="caps"&gt;SAST&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Когда гадкий duck-typing становится&amp;nbsp;лебедем&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Представьте, что нам необходимо проанализировать следующий&amp;nbsp;код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// UnknownType - тип, объявленный в отсутствующей зависимости &lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Человек без труда увидит здесь достижимую уязвимость к &lt;span class="caps"&gt;XSS&lt;/span&gt;. А вот большинство существующих статических анализаторов ее благополучно прошляпят в связи с тем, что им ничего не известно о типе UnknownType. Однако все, что здесь требуется от &lt;span class="caps"&gt;IA&lt;/span&gt; - это забыть о статической типизации и перейти к утиной. Семантика интерпретации таких конструкций должна полностью зависеть от контекста их использования. Да, интерпретатор ничего не знает о том, чем является &lt;code&gt;UnknownType.Property1&lt;/code&gt; - свойством, полем, или даже делегатом (ссылкой на метод в C#). Но поскольку операции с ней осуществляются как с переменной-мембером какого-то типа, интерпретатору ничего не мешает обрабатывать их именно таким образом. А если, к примеру, далее по коду встретится конструкция &lt;code&gt;UnknownType.Property1()&lt;/code&gt;, то ничто не мешает интерпретировать вызов того метода, ссылка на который была ранее присвоена Property1. И так далее, в лучших традициях заводчиков&amp;nbsp;уток-чемпионов.&lt;/p&gt;
&lt;h2&gt;Подводя&amp;nbsp;итоги&lt;/h2&gt;
&lt;p&gt;Разумеется, есть масса маркетинговых свистелок, которыми один анализатор якобы выгодно отличается от другого, с точки зрения продающей его стороны. Но, согласитесь, в них нет никакого проку, если ядро продукта не в состоянии обеспечить базовую функциональность, ради которой его и будут использовать. А для того, чтобы её обеспечить, анализатор обязан стремиться по своим возможностям к описанному &lt;span class="caps"&gt;IA&lt;/span&gt;. Иначе ни о какой реальной защищенности на обрабатываемых им проектах и речи быть не&amp;nbsp;может. &lt;/p&gt;
&lt;p&gt;Несколько лет назад, один из наших клиентов обратился к нам за проведением анализа защищенности разрабатываемой им системы. В числе вводных данных он предоставил отчет об анализе кода их проекта продуктом, являвшимся на тот момент лидером на рынке &lt;span class="caps"&gt;SAST&lt;/span&gt;-инструментария. Отчет содержал около двух тысяч записей, большинство из которых оказались в итоге на проверку положительно-ложными срабатываниями. Но самым плохим оказалось то, чего не было в отчете. В результате ручного анализа кода, нами были обнаружены десятки уязвимых мест, пропущенных при сканировании. Использование подобных анализаторов приносит больше вреда, чем пользы, как отнимая время, необходимое для разбора всех ложно-положительных результатов, так и создавая иллюзию защищённости из-за ложно-отрицательных. Этот случай, кстати, стал одной из причин разработки нами собственного&amp;nbsp;анализатора.&lt;/p&gt;
&lt;h2&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Talk is cheap. Show me the&amp;nbsp;code.&amp;#8221;&lt;/h2&gt;
&lt;p&gt;Было бы странным не завершить статью небольшим примером кода, позволяющим проверить степень идеальности того или иного анализатора на практике. Voila - ниже представлен код, включающий в себя все базовые кейсы, покрываемые описанным подходом к абстрактной интерпретации, но не покрываемые более примитивными подходами. Каждый кейс реализован настолько тривиально, насколько это возможно и с минимальным количеством инструкций языка. Это пример для C#/&lt;span class="caps"&gt;ASP&lt;/span&gt;.Net WebForms, но не содержит какой-либо специфики и легко может быть транслирован в код на любом другом ООП-языке и под любой&amp;nbsp;web-фреймворк. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ZmFsc2U=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;false&amp;quot; в base64-кодировке&lt;/span&gt;
&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pvo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// False-negative&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не интерпретирующие поток выполнения по потокам данных функционального типа, не сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;pvo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Для анализаторов, требующих компилируемый код, этот фрагмент необходимо удалить&lt;/span&gt;
&lt;span class="cp"&gt;#region&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, игнорирующие некомпилируемый код, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endregion&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие условия достижимости точек выполнения, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WebUtility&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HtmlEncode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику нестандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="c1"&gt;// (CustomFilter.Filter реализует логику `s.Replace(&amp;quot;&amp;lt;&amp;quot;, string.Empty).Replace(&amp;quot;&amp;gt;&amp;quot;, string.Empty)`)&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных кодирующих функций, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="m"&gt;1725&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, аппроксимирующие или игнорирующие интерпретацию циклов, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не интерпретирующие семантику типов стандартной библиотеки, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Результатом анализа данного кода должно являться сообщение о единственной уязвимости к атакам &lt;span class="caps"&gt;XSS&lt;/span&gt; в выражении &lt;code&gt;pvo(parm1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Вступить и компилировать с готовым к сканированию проектом можно &lt;a href="https://kochetkov.github.io/uploads/IAMeter.zip"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но, как говорится, &amp;#8220;лучше один раз увидеть&amp;#8230;&amp;#8221; и, в первую очередь, мы проверили на соответствие &lt;span class="caps"&gt;IA&lt;/span&gt; разрабатываемый нами анализатор, по чистой случайности называющийся &lt;a href="http://ai.ptsecurity.ru/"&gt;&lt;span class="caps"&gt;AI&lt;/span&gt;&lt;/a&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А вы - уже проверили свой?&amp;nbsp;;)&lt;/p&gt;
&lt;h2&gt;На правах бонуса для дочитавших до&amp;nbsp;конца&lt;/h2&gt;
&lt;p&gt;Мы открываем публичное альфа-тестирование бесплатной утилиты Approof. В нее не включена функциональность анализа кода и не используется весь описанный выше матастафический хардкор, зато включена функциональность выявления в проектах уязвимых внешних компонентов, недостатков конфигурации, чувствительных к разглашению данных, а также внедренных веб-шеллов и вредоносного&amp;nbsp;кода:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png"&gt;&lt;/p&gt;
&lt;p&gt;Скачать утилиту можно на &lt;a href="http://approof.ptsecurity.ru/"&gt;официальном сайте&lt;/a&gt;. Перед ее использованием обязательно ознакомьтесь с лицензионным соглашением. В ходе анализа, Approof собирает неконфиденциальную статистику по проекту (&lt;span class="caps"&gt;CLOC&lt;/span&gt;, типы файлов, используемые фреймворки и т.к.) и, опционально, отправляет ее на сервер &lt;span class="caps"&gt;PT&lt;/span&gt;. Отключить отправку статистики или ознакомиться с сырым json, содержащим собранные данные, можно в разделе About&amp;nbsp;приложения.&lt;/p&gt;</content><category term="SAST"></category><category term="DAST"></category><category term="IAST"></category><category term="статический анализ кода"></category><category term="анализатор кода"></category><category term="static code analysis"></category><category term="Application Inspector"></category></entry><entry><title>Analyzing source code for vulnerabilities: SAST theory, practice, and prospects</title><link href="https://kochetkov.github.io/sast-theory-practice-and-prospects-en.html" rel="alternate"></link><published>2016-07-08T04:00:00+03:00</published><updated>2016-07-08T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-07-08:/sast-theory-practice-and-prospects-en.html</id><summary type="html">&lt;p&gt;It would not be a big overstatement to say that the market for &lt;span class="caps"&gt;SAST&lt;/span&gt; (Static Application Security Testing) tools is currently booming. Research papers on &lt;span class="caps"&gt;SAST&lt;/span&gt; are published at least once every two months, new &lt;span class="caps"&gt;SAST&lt;/span&gt; tools become available every year, and whole sections at international information security conferences are dedicated to &lt;span class="caps"&gt;SAST&lt;/span&gt;’s role in software development. &lt;span class="caps"&gt;SAST&lt;/span&gt; tool vendors constantly bombard the prospective users with tons of information about their products, and it is not easy to understand which part of it is true, and which is just a marketing hype. Let’s try to understand the real capabilities of such tools, and what we should do if they cannot handle some issues. We are going to take a little dive into the theory that lies in the basis of state-of-the-art &lt;span class="caps"&gt;SAST&lt;/span&gt;&amp;nbsp;tools.&lt;/p&gt;</summary><content type="html">&lt;p&gt;It would not be a big overstatement to say that the &lt;span class="caps"&gt;SAST&lt;/span&gt; market is currently booming. Research papers on &lt;span class="caps"&gt;SAST&lt;/span&gt; are published at least once every two months, new &lt;span class="caps"&gt;SAST&lt;/span&gt; tools become available every year, and whole sections at international information security conferences are dedicated to &lt;span class="caps"&gt;SAST&lt;/span&gt;’s role in software development. &lt;span class="caps"&gt;SAST&lt;/span&gt; tool vendors constantly bombard the prospective users with tons of information about their products, and it is not easy to understand which part of it is true, and which is just a marketing hype. Let’s try to understand the real capabilities of such tools, and what we should do if they cannot handle some issues. We are going to take a little dive into the theory that lies in the basis of state-of-the-art &lt;span class="caps"&gt;SAST&lt;/span&gt;&amp;nbsp;tools.&lt;/p&gt;
&lt;h2&gt;Turing, Rice and all, all,&amp;nbsp;all&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;/&lt;span class="caps"&gt;DR&lt;/span&gt;: The problem of static application security testing is algorithmically&amp;nbsp;undecidable.&lt;/p&gt;
&lt;p&gt;Imagine a set of fully abstract programs (let’s call it P) that always hang on some inputs and halt after doing some operations on other inputs. Obviously, class P includes all theoretically possible programs, because each of them has this&amp;nbsp;property. &lt;/p&gt;
&lt;p&gt;Now imagine that one of these programs is a code analyzer (let’s call it h) that can answer this simple question: Does an arbitrary program p of P hang on the given input n? Obviously, h can answer this question only if it completes its job; by doing that, it tells us that p hangs on n. In other words, if p(n) doesn’t halt, then h(p(n)) must complete its job in a finite number of steps; and if p(n) halts, then h(p(n)) must&amp;nbsp;hang. &lt;/p&gt;
&lt;p&gt;Now imagine what happens if we try using that analyzer to answer this question: Will the analyzer hang if it tries to analyze itself analyzing itself? (Because p can be any program of P, so it can be h, too.) But in this case, if h(h(n)) halts, then the analyzing of h(n) hangs; and if h(h(n))) hangs, then the analyzing of h(n) halts. But h is h(n), so we have a contradiction, which means that an h-like analyzer cannot&amp;nbsp;exist.&lt;/p&gt;
&lt;p&gt;The above is a loose summary of the proof of The Halting Theorem that was formulated by Alan Turing, the founder of the modern theoretical computer science, in 1936. The theorem states that there is no program able to analyze another program and answer the question whether that program would halt on a certain input. Well, maybe we could create a program that can answer the question about some other properties of programs under&amp;nbsp;examination?&lt;/p&gt;
&lt;p&gt;Because set P includes all possible programs, we can always split it into two classes (let’s call them A and B) based on the existence of any nontrivial, invariant property in the programs. Here nontriviality and invariance means that any program of P either has that property or doesn’t have it. Moreover, either all functionally identical programs (which produce the same outputs when fed identical inputs) have that property, or none of them has&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Imagine that there exists a code analyzer (let’s call it q) that takes an arbitrary program p of P as an input, and halts if p belongs to one of the classes (A or B). For example, let it be class A. Let pa be a program that belongs to class A and gets caught in an endless loop on any input. Let’s also take an arbitrary program (pb) from class B. For each program p, let’s define program p&amp;#8217; that takes input x and executes the following&amp;nbsp;algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p(p)&lt;/li&gt;
&lt;li&gt;pb(x)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now let’s create program q&amp;#8217; that takes an arbitrary program p as an input, creates for it p&amp;#8217;, and calculates&amp;nbsp;q(p&amp;#8217;). &lt;/p&gt;
&lt;p&gt;If p&amp;#8217; hangs on the first step, it means that p&amp;#8217; is functionally identical to pa (and belongs to class A), so q&amp;#8217; must halt immediately. If p&amp;#8217; completes the first step, it means that p&amp;#8217; is functionally identical to pb (and belongs to class B), so q&amp;#8217; must hang. Therefore, for any program p, q&amp;#8217;(p) halts if p(p) doesn’t halt. But q&amp;#8217; can take the place of p, so p(p) halts only if p(p) doesn’t halt. Again, it is a&amp;nbsp;contradiction. &lt;/p&gt;
&lt;p&gt;The statement that there is no program that can answer the question whether an arbitrary program has any nontrivial, invariant properties was proved by the scientist Henry Gordon Rice in 1953. Basically, his research has generalized the Halting Theorem, because the property of halting on a given input is nontrivial and invariant. Depending on the properties considered, Rice&amp;#8217;s theorem has infinitely many practical values: “It is impossible to use a program to classify an algorithm implemented by another program,” “It is impossible to use a program to prove that two other programs implement one and the same algorithm,” “It is impossible to use a program to prove that another program doesn’t enter certain states on any inputs,” etc. We should consider the last example in more&amp;nbsp;detail.&lt;/p&gt;
&lt;p&gt;When any (abstract or real) algorithm is being executed by a universal executing program (for example, by a virtual machine that emulates a real computer with its operating system), we can take a snapshot of that virtual machine, including the state of the application (algorithm) being executed in the address space of the virtual machine and its external environment, such as disk drives, the state of external devices, etc. Later we can restore that state from the snapshot and continue running the application from the very same point. In essence, the whole process of any program’s execution is a sequence of changing states that is determined by the program’s source code. If there are any errors in the configuration or implementation of the program or the virtual machine, it is highly probable that the control flow will enter a state that has  never been intended by the program’s&amp;nbsp;developer.&lt;/p&gt;
&lt;p&gt;What is a vulnerability? It is an opportunity of using input data to make the control flow enter a state that allows the attacker to realize a threat regarding the data being processed by the program. Therefore, we can define the security of any program as its ability to always remain within the predetermined set of admissible states that determine its security policy, regardless of the initial input. In that case, the security analysis problem boils down to checking whether it is impossible for the program to enter any state not allowed by the security policy on an arbitrary input. That is, to the problem whose algorithmic undecidability has been long ago proved by Henry&amp;nbsp;Rice.&lt;/p&gt;
&lt;p&gt;Does it mean that the whole &lt;span class="caps"&gt;SAST&lt;/span&gt; market is basically a snake oil industry? In theory – yes, it is. But in practice, as usually, the answer to that question is not that&amp;nbsp;simple.&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;SAST&lt;/span&gt; theory in&amp;nbsp;practice&lt;/h2&gt;
&lt;p&gt;Even as pure theorists, we could ease some requirements of Rice’s statement for real programs executed in real environments. First, in theoretical computer science, a program is a mathematical abstraction that is equivalent to a Turing machine (&lt;span class="caps"&gt;TM&lt;/span&gt;), the most powerful computing automaton. However, in real programs only some code fragments are truly equivalent to &lt;span class="caps"&gt;TM&lt;/span&gt;. In terms of computation power, linear bounded automata, stack machines, and finite state machines are below &lt;span class="caps"&gt;TM&lt;/span&gt;. Even as pure theorists, we can analyze the security of stack machines and finite state&amp;nbsp;machines.&lt;/p&gt;
&lt;p&gt;Second, &lt;span class="caps"&gt;TM&lt;/span&gt;’s distinguishing feature is that it can use a memory of an infinite size. This feature is the reason why we cannot get all possible states of a computation process – simply because there are an infinite number of them. But the amount of memory in real computers is far from infinite. What is even more important, in real programs the number of states that may be of some interest from the viewpoint of security analysis is also finite, though obscenely&amp;nbsp;huge.&lt;/p&gt;
&lt;p&gt;Third, calculating a program’s properties based on Rice’s statement is a decidable problem for a number of small TMs that have few states and few possible transitions between them. It is hard to imagine a real program that has 2 to 4 states. But it is much easier to imagine a program’s &lt;em&gt;fragment&lt;/em&gt; with that number of&amp;nbsp;states.&lt;/p&gt;
&lt;p&gt;Therefore, we can effectively analyze code fragments that meet the above criteria. In practice it means&amp;nbsp;that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We can thoroughly analyze a code fragment without any program loops or recursion, because it is equivalent to a finite state&amp;nbsp;machine;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can analyze a code fragment with some program loops or recursion if the exit conditions do not depend on input, by considering it as a finite state machine or a stack&amp;nbsp;machine;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the exit conditions for the program loop or recursion depends on input whose length is reasonably limited, in some cases we can analyze the fragment as a system of linear bounded automata or a system of small&amp;nbsp;TMs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As for other code fragment types, alas, we cannot use the static approach to analyze them. Moreover, when developing source code security analyzers, software engineers have to trade off between &lt;span class="caps"&gt;EXPSPACE&lt;/span&gt; and &lt;span class="caps"&gt;EXPTIME&lt;/span&gt; on a daily basis. When they do manage to reduce even special cases to a sub-exponential algorithm, they feel happy like little kids, because it’s really awesome! How do you think, what will be the power of the set of possible values of variable parm1 at the last execution&amp;nbsp;point?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That’s why we don’t have to worry too much about the theoretical limitations, because it is extremely unlikely that we would ever hit them when using any practically available computation power. However, the easing of the requirements has set the evolution of modern static code analyzers on the right course, so we should keep it in mind&amp;nbsp;anyway.   &lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAST&lt;/span&gt;, &lt;span class="caps"&gt;IAST&lt;/span&gt;, and all, all,&amp;nbsp;all&lt;/h2&gt;
&lt;p&gt;Unlike the static approach, where program code is analyzed without actually being executed, the dynamic approach (Dynamic Application Security Testing, &lt;span class="caps"&gt;DAST&lt;/span&gt;) requires having a runtime environment and executing the program on some inputs that are most useful for analysis purposes. Simply speaking, we can call &lt;span class="caps"&gt;DAST&lt;/span&gt; a “method of informed trial and error”: “Let’s feed these input data, which are characteristic for that kind of attack, to the program and see what happens.” This method has obvious drawbacks: In many cases we can’t quickly deploy the system to be analyzed (sometimes we can’t even build it), the system’s transition to a certain state may be the result of processing the previous inputs, and a comprehensive analysis of a real system’s behavior requires feeding it so many inputs that it is utterly impractical to try testing the system on each of&amp;nbsp;them.&lt;/p&gt;
&lt;p&gt;Not long ago, Interactive Application Security Testing (&lt;span class="caps"&gt;IAST&lt;/span&gt;) – an approach that combined the strengths of &lt;span class="caps"&gt;SAST&lt;/span&gt; and &lt;span class="caps"&gt;DAST&lt;/span&gt; – was considered promising. &lt;span class="caps"&gt;IAST&lt;/span&gt;’s distinctive feature is that the &lt;span class="caps"&gt;SAST&lt;/span&gt; part generates inputs and the templates of expected results, and the &lt;span class="caps"&gt;DAST&lt;/span&gt; part tests the system on these inputs, prompting the human operator to interfere in ambiguous situations. The irony of this approach is that it has inherited both strengths and weaknesses of &lt;span class="caps"&gt;SAST&lt;/span&gt; and &lt;span class="caps"&gt;DAST&lt;/span&gt;, which calls in question its&amp;nbsp;practicality.&lt;/p&gt;
&lt;p&gt;But who said that dynamic code analysis means that we have to execute the whole program? As we have already seen, we can use the static approach to analyze a major portion of the program’s code. Why can’t we use the dynamic approach to analyze only the remaining code fragments? It sounds like we have a&amp;nbsp;plan…&lt;/p&gt;
&lt;h2&gt;Mumbo Jumbo™&amp;nbsp;Inside&lt;/h2&gt;
&lt;p&gt;There are several classic approaches to static code analysis, which use different models for producing the properties of the code under examination. The most primitive and obvious approach is signature search. It is based on looking for occurrences of some template in the syntax code presentation model (which is usually a token flow or an abstract syntax tree). Some implementations of that approach use slightly more-complex models (semantic tree, its mapping to the graph of some data flow, etc.). But on the whole, this approach is only useful as a secondary one: It allows us to mark suspicious parts of the code within a linear time, so that later we can check them manually. Enough said about this approach; if you are interested in it, please read the &lt;a href="http://blog.ptsecurity.com/search/label/AST"&gt;series of articles&lt;/a&gt; by Ivan&amp;nbsp;Kochurkin.&lt;/p&gt;
&lt;p&gt;More-complex approaches use code execution (not presentation or semantic) models. Such models usually can answer this question: Can a data flow under external control reach such an control flow point that it creates a vulnerability? In most cases, the model is a &lt;a href="https://en.wikipedia.org/wiki/Control_flow_graph"&gt;control flow graph&lt;/a&gt; or a &lt;a href="https://en.wikipedia.org/wiki/Data_flow_diagram"&gt;data flow diagram&lt;/a&gt;, or a combination of them (for example, a &lt;a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf"&gt;code property graph&lt;/a&gt;). Such approaches have an obvious drawback: When analyzing any nontrivial code, answering the above question is not enough to successfully detect a vulnerability. For example, here’s a code&amp;nbsp;fragment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filteredParam&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Based on the created model, the trivial graph-based analyzer will confirm that the data flow &lt;code&gt;Request.Params["param"]&lt;/code&gt; can reach the control flow point &lt;code&gt;Response.Write(filteredParam)&lt;/code&gt;, and that there is a vulnerability to &lt;span class="caps"&gt;XSS&lt;/span&gt; attacks there. Actually, that data flow is effectively filtered and cannot carry the attack vector! There are many methods that allow us to cover special cases associated with data flow preprocessing, but ultimately each of them means finding a reasonable balance between false positives and false negatives, also known as Type I errors and type &lt;span class="caps"&gt;II&lt;/span&gt;&amp;nbsp;errors.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Type 1 &amp;amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg"&gt;&lt;/p&gt;
&lt;p&gt;How can we minimize the number of errors of both types? We need to consider reachability conditions both for potentially vulnerable control flow points and for combinations of values of the data flows that can reach those points. Based on that information, we can create a system of equations whose set of solutions will give us all possible inputs that are necessary to reach the potentially vulnerable point in the program. The intersection of this set with the set of all possible attack vectors will produce the set of all inputs that bring the program to a vulnerable state. It sounds great, but how can we build a model that contains all necessary&amp;nbsp;information?&lt;/p&gt;
&lt;h2&gt;Abstract interpretation and symbolic&amp;nbsp;computation&lt;/h2&gt;
&lt;p&gt;Suppose, we need to find out the sign of the number produced by this expression: &lt;code&gt;-42 / 8 * 100500&lt;/code&gt;. The simplest way to do it is to calculate the result and check if it is negative. The computation of an expression by using specific values of all arguments is known as “concrete computation.” But we can also solve this problem in a different way. Imagine that for some reason the concrete computation of this expression cannot be done. For example, because a variable has been added: &lt;code&gt;-42 / 8 * 100500 * x&lt;/code&gt;. Let’s define an abstract arithmetic in which the result of operations on numbers is defined only by the signs, while the absolute values of all arguments are&amp;nbsp;ignored:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(+a) = (+)
(-a) = (-)
(-) * (+) = (-)
(-) / (+) = (-)  
...
(-) + (+) = (+-)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let’s interpret the initial expression within this semantics: &lt;code&gt;(-) / (+) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-)&lt;/code&gt;. This approach will give an unambiguous answer to the question as long as the expression does not contain any addition or subtraction operators. Let’s modify our arithmetic to consider the absolute values of arguments,&amp;nbsp;too:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(-a) * (+b) = (-c)
(-a) / (+b) = (-c)  
...
(-a) + (+b) = 
    a &amp;lt;= b -&amp;gt; (+)
    a &amp;gt;  b -&amp;gt; (-)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we interpret the expression &lt;code&gt;-42 / 8 * 100500 + x&lt;/code&gt; based on the new semantics, the result will be &lt;code&gt;x &amp;gt;= -527625 -&amp;gt; (+), x &amp;lt; -527625 -&amp;gt; (-)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The above approach is called &lt;a href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;abstract interpretation&lt;/a&gt;. It is formally defined as a stable approximation of the semantics of expressions, based on monotonic functions over ordered sets. Simply speaking, it is an interpretation of expressions without a concrete computation of them, intended to gather information within the given semantic field. Let’s smoothly go from interpreting some expressions to interpreting program code in some programming language. As for the semantic field, let’s define the semantics of the language, complemented with the rule to handle all inputs as unknown variables (symbolic values). The result is an approach known as “[symbolic execution,]”(https://en.wikipedia.org/wiki/Symbolic_execution) which lies in the basis of most promising &lt;span class="caps"&gt;SAST&lt;/span&gt;&amp;nbsp;tools.&lt;/p&gt;
&lt;p&gt;It is symbolic computation that allows us to create a context graph for symbolic computation (also known as a computation flow graph). It is a model that comprehensively describes the computation process of the program under examination. That model was considered in the report &lt;a href="http://www.slideshare.net/kochetkov.vladimir/automated-patching-for-vulnerable-source-code/14"&gt;“Automated generation of source code patches”&lt;/a&gt;, and the model’s application for code security analysis was covered in the article &lt;a href="https://www.ptsecurity.com/upload/ptcom/PT_Positive_Research_2015_EN_web.pdf"&gt;&amp;#8220;Source Code Security Assessment and Automatic Exploit Generation&amp;#8221;&lt;/a&gt; (p. 23-24). It doesn’t make much sense for us to cover them again in this article. It should be noted that the model allows us to get reachability conditions both for any control flow point and for sets of values of input arguments. That is, it is just what we need to solve our&amp;nbsp;problem.&lt;/p&gt;
&lt;h2&gt;Vulnerability search based on the computation flow&amp;nbsp;graph&lt;/h2&gt;
&lt;p&gt;If we formalize vulnerability criteria to a certain attack class in terms of the computation flow graph, we can implement code security analysis by finding out the properties of a concrete model obtained as a result of the abstract interpretation of the code under examination. For example, we can formalize the criteria of vulnerability to any injection attacks (SQLi, &lt;span class="caps"&gt;XSS&lt;/span&gt;, XPATHi, Path Traversal, etc.) as&amp;nbsp;follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let C be the computation flow graph of the code under&amp;nbsp;examination.&lt;/p&gt;
&lt;p&gt;Let pvf(t) be the reachable control flow node in C, so that pvf(t) is the call of the function of direct or indirect interpretation of text t that conforms to formal grammar&amp;nbsp;G.&lt;/p&gt;
&lt;p&gt;Let e be the input data argument flow in&amp;nbsp;С. &lt;/p&gt;
&lt;p&gt;Let De be the set of data flows in C that are derived from e and reachable at the pvf(t) invocation&amp;nbsp;point.&lt;/p&gt;
&lt;p&gt;Then the program is vulnerable to injection attacks at the pvf(t) invocation point if t belongs to De and the set of values of De includes at least one pair of elements which, if syntactically parsed in conformance with grammar G, produces trees that are not isomorphic to each&amp;nbsp;other.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can formalize vulnerabilities to other attack classes in a similar manner. However, it should be noted that not all vulnerability types can be formalized within a model created based on the code under examination. In some cases, we may need more information. For example, to formalize vulnerabilities to attacks against business logic, we need to have formalized rules for the program’s application domain; to formalize vulnerabilities to attacks against access control, we need formalized access control policies;&amp;nbsp;etc.&lt;/p&gt;
&lt;h2&gt;Ideal – that is, purely theoretical – code security&amp;nbsp;analyzer&lt;/h2&gt;
&lt;p&gt;Let’s forget about the harsh reality for awhile and try answering this question: If a hypothetical Ideal Analyzer (&lt;span class="caps"&gt;IA&lt;/span&gt;) could exist, what functionality should it&amp;nbsp;have?&lt;/p&gt;
&lt;p&gt;First, it should have the strengths of both &lt;span class="caps"&gt;SAST&lt;/span&gt; and &lt;span class="caps"&gt;DAST&lt;/span&gt;, but do not have their weaknesses. Among other things, it means that &lt;span class="caps"&gt;IA&lt;/span&gt; should be able to analyze any existing program code (source code or binary code) without requiring its completeness or the program to be deployed in the runtime environment. In other words, &lt;span class="caps"&gt;IA&lt;/span&gt; should be able to analyze projects with missing external dependencies, or when some other factors do not let us to build or deploy the program. Moreover, handling code fragments that contain references to missing dependencies should be implemented as completely as possible in each particular case. On the other hand, &lt;span class="caps"&gt;IA&lt;/span&gt; should not only be able to avoid the theoretical limitations imposed by the Turing computation model, but also complete scanning within a reasonable time, consume a reasonable amount of memory, and, when possible, stay in the sub-exponential “weight&amp;nbsp;category.”&lt;/p&gt;
&lt;p&gt;Second, the probability of Type I errors should be minimized by creating and solving systems of logical equations and generating a working attack vector that allows the user to confirm the existence of the vulnerability in one&amp;nbsp;click. &lt;/p&gt;
&lt;p&gt;Third, &lt;span class="caps"&gt;IA&lt;/span&gt; should effectively deal with Type &lt;span class="caps"&gt;II&lt;/span&gt; errors by allowing the user to check all potentially vulnerable control flow points manually if &lt;span class="caps"&gt;IA&lt;/span&gt; was unable to either prove or disprove their&amp;nbsp;vulnerability.&lt;/p&gt;
&lt;p&gt;Using a model based on symbolic computation allows us to implement all of the above requirements by-design, except for the ones related to theoretical limitations and sub-exponentiality. Our plan – to employ dynamic code analysis when static code analysis fails – is just what we&amp;nbsp;need! &lt;/p&gt;
&lt;h2&gt;Partial computation, inverse functions, and deferred&amp;nbsp;interpretation&lt;/h2&gt;
&lt;p&gt;Imagine that &lt;span class="caps"&gt;IA&lt;/span&gt; contains a knowledge base that describes the semantics of input transformation functions implemented in the standard language library or the program’s runtime environment, in the most popular frameworks and CMSs. For example, imagine that the functions Base64Decode and Base64Encode are mutually inverse, or that each call of StringBuilder.Append adds a new line to the string already stored in the temporary variable of that class, etc. Thanks to all that knowledge, &lt;span class="caps"&gt;IA&lt;/span&gt; doesn’t have to “fall through” into the library code whose analysis is subject to all computational limitations,&amp;nbsp;too:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// The value of cond2 required for meeting the condition will be produced by the solver based on the knowledge base on inverse functions &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// The value of sb.ToString will be obtained by emulating the semantics of StringBuilder described in the knowledge base on library functions&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But what if there is a call of a function in the code, but there is no description of that function in the &lt;span class="caps"&gt;IA&lt;/span&gt; knowledge base? Imagine that &lt;span class="caps"&gt;IA&lt;/span&gt; can use a virtual sandbox environment that allows it to run an arbitrary fragment of the code under examination in the given context and get the result of its execution. Let’s call it “partial computation.” In that case, before “falling through” into an unknown function and starting to interpret it abstractly, &lt;span class="caps"&gt;IA&lt;/span&gt; can try doing a trick called “partial fuzzing.” The general idea of that trick is that we can prebuild a knowledge base on library transformation functions and any combinations of sequential calls of such functions based on the already-known combinations of test data. Having that knowledge base, we can execute an unknown function on the same combinations of data and then compare the results to the samples from the knowledge base. If the results of executing the unknown function match the results of executing a known sequence of library functions, it would mean that now &lt;span class="caps"&gt;IA&lt;/span&gt; knows the semantics of the unknown function, so there is no need to interpret the&amp;nbsp;function.&lt;/p&gt;
&lt;p&gt;But if the set of input values of all data flows are known for a code fragment that doesn’t contain any dangerous operators, &lt;span class="caps"&gt;IA&lt;/span&gt; can simply execute that fragment on all possible data flows and use the results instead of abstractly interpreting that fragment. That fragment can be of any computation power class, without any impact whatsoever on the results of its execution. Moreover, even if we do not know beforehand the the set of input values of data flows for a code fragment, &lt;span class="caps"&gt;IA&lt;/span&gt; can defer the interpretation of that fragment until it starts to solve the equation for the specific dangerous operator. At the solution step, an additional limitation about the presence of specific attack vectors in input data is imposed on the set of input values, which may allow us to make assumptions about the set of input values for the deferred fragment, and thereby partially compute it at this&amp;nbsp;step.&lt;/p&gt;
&lt;p&gt;Moreover, at the solution step, &lt;span class="caps"&gt;IA&lt;/span&gt; can simply take the final reachability formula for the dangerous point and its arguments (it would be easier to build the formula by using the syntax and semantics of the language used in the code under examination) and fuzzy it thoroughly on all known vector values to get their subset that can pass through all filter functions of the&amp;nbsp;formula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// The value of the Response.Write argument that passes unchanged through the filter function can be obtained by fuzzing its formula by substituting the values of all possible XSS vectors in parm1 &lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The above approaches allow us to analyze a good share of Turing-complete code fragments but require significant efforts by the software engineers, who need to build knowledge bases and optimize the emulation of semantics of standard types, and to implement the sandbox for partial code execution (surely nobody wants for something like File.Delete to be executed in program loop during the analysis). The engineers also need to provide support for fuzzing of n-local unknown functions, integrate the concept of partial execution with the &lt;span class="caps"&gt;SMT&lt;/span&gt; solver, etc. Nevertheless, there are no substantial limitations to doing all these things, quite unlike the drawbacks of the classic &lt;span class="caps"&gt;SAST&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;When the ugly duck-typing becomes a&amp;nbsp;swan&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Imagine that we need to analyze the following&amp;nbsp;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// UnknownType - a type that is declared in a missing dependency &lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A human can easily detect a reachable &lt;span class="caps"&gt;XSS&lt;/span&gt; vulnerability in the above code fragment. However, the majority of the existing static code analyzers will miss it simply because they don’t know anything about the UnknownType type. But &lt;span class="caps"&gt;IA&lt;/span&gt; only needs to forget about static typing and use duck typing instead. The semantics of interpretation of such constructs should be completely dependent on the context of their use. Yes, the interpreter doesn’t know what &lt;code&gt;UnknownType.Property1&lt;/code&gt; is – a property, a field, or even a delegate (a reference to a method in C#). But because operations on it are done as if it is a variable-member of a specific type, the interpreter can simply process it in the respective manner. And if, for example, &lt;span class="caps"&gt;IA&lt;/span&gt; finds the construct &lt;code&gt;UnknownType.Property1()&lt;/code&gt; further in the code, it can simply interpret the call of the method, a reference to which has been earlier attributed to Property1. Etcetera, etcetera, in keeping with the best traditions of duck&amp;nbsp;breeders.&lt;/p&gt;
&lt;h2&gt;Taking&amp;nbsp;stock&lt;/h2&gt;
&lt;p&gt;Surely, there are tons of bells and whistles which supposedly make one code analyzer better than another, at least from the vendor’s viewpoint. But if the analyzer’s engine cannot provide even the basic functionality, what’s the point of having lots of trendy features? To make the users happy, the analyzer’s developers must strive to provide the functionality that is as close to that of the &lt;span class="caps"&gt;IA&lt;/span&gt; as possible. Otherwise, you can just forget about any actual security of the projects checked by the&amp;nbsp;analyzer. &lt;/p&gt;
&lt;p&gt;Some years ago, a customer of ours asked us to analyze the security of a system he was developing. Among the introductory data, he enclosed a report of code analysis done by an analyzing product that was the leader of the &lt;span class="caps"&gt;SAST&lt;/span&gt; tools market at that time. The report contained about two thousand entries, most of which eventually proved to be false positives. But the worst part was what was missing in the report. By manually analyzing the code, we have found dozens of vulnerable points that had been missed by the leading analyzer! So using such analyzers does more harm than good: You waste your time on manually checking all false positives, and the presence of false negatives creates an illusion of security. By the way, that case was one of the reasons why we’ve decided to develop our own&amp;nbsp;analyzer.&lt;/p&gt;
&lt;h2&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Talk is cheap. Show me the&amp;nbsp;code.&amp;#8221;&lt;/h2&gt;
&lt;p&gt;It would be amiss not to complete the article with a small code sample that allows you to check the “degree of ideality” of any analyzer in practice. Presto! Below you can see the code that includes all basic cases covered by the approach to abstract interpretation described in this article, but not covered by the more-primitive approaches. Each case has been implemented as trivially as possible and contains few instructions. Though the example is intended for C#/&lt;span class="caps"&gt;ASP&lt;/span&gt;.Net WebForms, it does not contain any specifics and can be easily translated into any other &lt;span class="caps"&gt;OOP&lt;/span&gt; code or adapted for any Web&amp;nbsp;framework. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ZmFsc2U=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;false&amp;quot; in base64&lt;/span&gt;
&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pvo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// False-negative&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that doesn’t interpret the control flow by functional data flows will not report a vulnerability here&lt;/span&gt;
&lt;span class="n"&gt;pvo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// If the analyzer requires compiled code, delete this fragment&lt;/span&gt;
&lt;span class="cp"&gt;#region&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores noncompiled code will report a vulnerability here&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endregion&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores execution point reachability conditions will report a vulnerability here&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores the semantics of standard filter functions will report a vulnerability here&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WebUtility&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HtmlEncode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores the semantics of nonstandard filter functions will report a vulnerability here&lt;/span&gt;
&lt;span class="c1"&gt;// (CustomFilter.Filter implements the logic of `s.Replace(&amp;quot;&amp;lt;&amp;quot;, string.Empty).Replace(&amp;quot;&amp;gt;&amp;quot;, string.Empty)`)&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// An analyzer that ignores the semantics of standard encoding functions will report a vulnerability here&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="m"&gt;1725&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// An analyzer that approximates or ignores the interpretation of program loops will report a vulnerability here&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// An analyzer that does not interpret the semantics of standard library types will report a vulnerability here&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The result of analyzing this code should be a report of a single vulnerability to &lt;span class="caps"&gt;XSS&lt;/span&gt; attacks in the expression &lt;code&gt;pvo(parm1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can join us and compile a ready-to-scan project &lt;a href="https://kochetkov.github.io/uploads/IAMeter.zip"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But, as the saying goes, a picture is worth a thousand words. So we checked our own analyzer, coincidentally called &lt;a href="https://www.ptsecurity.com/products/#ai"&gt;&lt;span class="caps"&gt;AI&lt;/span&gt;&lt;/a&gt;, on conformance to &lt;span class="caps"&gt;IA&lt;/span&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_en.png"&gt;&lt;img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_en.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Have you already checked your analyzer?&amp;nbsp;;)&lt;/p&gt;
&lt;h2&gt;A little bonus for the most patient&amp;nbsp;reader&lt;/h2&gt;
&lt;p&gt;Welcome to the public alpha test of our freeware tool Approof! It doesn’t include the code analysis functionality and doesn’t implement all of the above semitheoretical stuff. Nonetheless, Approof can detect vulnerable external components, configuration defects, and sensible information, as well as injected web shells and&amp;nbsp;malware:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png"&gt;&lt;/p&gt;
&lt;p&gt;You can download Approof from our &lt;a href="https://approof.ptsecurity.com/"&gt;official website&lt;/a&gt;. Before using the tool, please read the license agreement. When analyzing code, Approof collects nonconfidential statistics on the project (&lt;span class="caps"&gt;CLOC&lt;/span&gt;, file types, frameworks used, etc.) and optionally sends it to the &lt;span class="caps"&gt;PT&lt;/span&gt; server. You can turn off the sending of statistics or take a look at the raw json that contains the collected data via the tool’s About&amp;nbsp;menu.&lt;/p&gt;</content><category term="SAST"></category><category term="DAST"></category><category term="IAST"></category><category term="static code analysis"></category><category term="code analyzer"></category><category term="Application Inspector"></category></entry><entry><title>По следам PHDays VI</title><link href="https://kochetkov.github.io/following-the-tracks-of-phdays-6.html" rel="alternate"></link><published>2016-06-01T04:00:00+03:00</published><updated>2016-06-01T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-06-01:/following-the-tracks-of-phdays-6.html</id><summary type="html">&lt;p&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз Application Inspector нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://phdays.ru"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз &lt;a href="http://www.ptsecurity.ru/products/ai/"&gt;Application Inspector&lt;/a&gt; нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас. &lt;/p&gt;
&lt;p&gt;Внезапно, обещание пропустить все доклады выполнилось само собой и большую часть времени я провел за кулисами, либо очищая &lt;span class="caps"&gt;AI&lt;/span&gt; от лишних фич и готовясь к своему выступлению в промежутках между прогонами тестов, либо выступая на закрытой встрече нашей новой девелоперской юзергруппы, о которой расскажу ниже. В итоге, чуть менее, чем вся конференция для меня выглядела как-то&amp;nbsp;так: &lt;/p&gt;
&lt;p&gt;&lt;img alt="PHDays VI глазами Вовы" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Ни за какими конкурсами я не наблюдал и тем более в них не участвовал (а в окрестностях &lt;span class="caps"&gt;CTF&lt;/span&gt;-зоны вообще появлялся лишь на пару минут и только для того, чтобы урвать себе немного космической еды), с вендорскими ништяками пролетел, во всех форках afterparty не участвовал и т.п. Развиртуализировался (ненавижу это слово) с несколькими френдами / подписчиками, что для интроверта уже немеряный подвиг. Наложил кирпичей, когда мимо меня, прямо за кулисами, несколько раз прошуршал  (ряженый, как выяснилось сильно позже) ОМОН в составе 4&amp;nbsp;бойцов.&lt;/p&gt;
&lt;p&gt;Однако же, гвоздем программы для меня стало мероприятие, проводившееся за ее рамками. Как я уже &lt;a href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html"&gt;писал&lt;/a&gt; ранее, в ходе конференции мы планировали провести первую встречу нашей новой пользовательской юзергруппы девелоперов, интересующихся вопросами разработки защищенных приложений и предметной области application security. В ходе нее планировалось провести сокращенный вариант прошлогоднего мастер-класса для разработчиков банковских приложений. В результате - встреча состоялась, мастер-класс проведен и по полученным отзывам можно с уверенностью сказать, что юзергруппе - быть. В относительно ближайшее время, мы планируем провести еще несколько оффлайн-встреч и вебинаров, посвященных тематике группы. В том числе, и с приглашением сторонних экспертов в различных областях и направлениях, связанных с application security. На встрече разработчики аккуратно получали около 6 часов живительного хардкора о теории и всевозможных практических аспектах проектирования и разработки защищенных приложений от&amp;nbsp;/me:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый /me" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;а поддерживать интерес аудитории мне помогал мой коллега Леша Гончаров, развлекавший народ задачками на ненормальный кодинг и раздававший печеньки особо&amp;nbsp;отличившмся:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Леша" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;В конце встречи мы анонсировали бесплатную утилиту от команды &lt;span class="caps"&gt;AI&lt;/span&gt; с рабочим названием Approof, позволяющую провести сканирование исходного кода проекта на предмет ошибок конфигурации и использования уязвимых компонентов. Участники встречи получили ее альфа-версию, а в скором времени, она будет доступна для загрузки всем&amp;nbsp;желающим. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Approof" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/4.png"&gt;&lt;/p&gt;
&lt;p&gt;Должен заметить, что на встрече я столкнулся с самой живой аудиторией из всех, встречавшихся мне на докладах, митапах и вебинарах. Была масса вопросов, кулуларных обсуждений, со мной пытались спорить и даже помогали вести встречу, отвечая участникам на вопросы, адресованные мне. Один из участников упрекнул нашу компанию в том, что мы даем владельцам веб-приложений слишком жесткие рекомендации по усилению content security policy, которые им, компаниям-разработчикам, потом тяжело выполнять (не зря работаем, значит). На второй день из более, чем полусотни слушателей отсеялось лишь около десятка человек, что как бы намекает. Слайды не выкладываю, т.к. они большей частью являются компиляцией ранее публиковавшихся выступлений и представляют интерес только для участников встречи, которые их и так получили по окончанию мероприятия вместе со всей&amp;nbsp;раздаткой.&lt;/p&gt;
&lt;p&gt;Но, в конечном счете, впечатления от конференции сугубо позитивные, хоть она и прошла для меня в достаточно своеобразном формате, повторять который - лично мне бы не&amp;nbsp;хотелось)&lt;/p&gt;</content><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Семинар Positive Development User Group</title><link href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html" rel="alternate"></link><published>2016-05-06T00:00:00+03:00</published><updated>2016-05-06T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-05-06:/phdays6-positive-development-user-group-workshop.html</id><summary type="html">&lt;p&gt;В этом году, в рамках развития идеи &amp;#8220;&lt;span class="caps"&gt;PT&lt;/span&gt;/PHDays для разработчиков&amp;#8221; эксперты Positive Technologies планируют провести 6-часовой мастер-класс по разработке защищенных&amp;nbsp;приложений.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Идея разработки по-настоящему-полезного-курса-по-разработке-защищенных-приложений-на-котором-не-захочется-спать зародилась в Positive Technologies еще в 2012 году, после проведения серии закрытых вебинаров на эту тему для разработчиков наших партнеров. Позднее, в 2013-ом, на PHDays &lt;span class="caps"&gt;III&lt;/span&gt; был представлен &lt;a href="http://www.slideshare.net/kochetkov.vladimir/hdswasm-russianproofreaded"&gt;воркшоп&lt;/a&gt;, построенный на их материалах. Следующие пару лет, отдельные его фрагменты использовались в различных докладах и курсах, а контент постоянно перерабатывался и дополнялся новыми разделами. Осенью 2015-го, мы с Тимуром Юнусовым объединили свои наработки и провели &lt;a href="https://habrahabr.ru/company/pt/blog/271287/"&gt;двухдневный мастер-класс&lt;/a&gt; для разработчиков банковских приложений. Его изюминкой стала непрерывная смена offensive и defensive направлений рассматриваемых тем. Тимур показывал типовые ошибки разработчиков и их последствия с точки зрения нападающего, а я объяснял, как не допускать их в новом коде и правильно устранять в уже&amp;nbsp;существующем.&lt;/p&gt;
&lt;p&gt;И, поскольку засыпающих в ходе мастер-класса отмечено не было, а отзывы о нем были получены сугубо положительные, мы решили выступить на бис и провести его сокращенный вариант повторно на предстоящей конференции &lt;a href="http://www.phdays.ru/"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt;. И не просто выступить, а в рамках первой (и, как мы надеемся, не последней) встречи Positive Development User Group - сообщества разработчиков, интересующихся предметной областью безопасности приложений. Мероприятие будет проводиться вне основной программы конференции в закрытом формате по персональным приглашениям. Заявку на участие можно заполнить &lt;a href="http://goo.gl/forms/rPIlrPeZBk"&gt;здесь&lt;/a&gt;. С программой и расписанием семинара можно ознакомиться в &lt;a href="https://goo.gl/ZIRUR0"&gt;официальном пресс-релизе мероприятия&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;P.S: И да - у нас будут печеньки&amp;nbsp;:) &lt;/p&gt;</content><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Переезд блога</title><link href="https://kochetkov.github.io/blog-movement.html" rel="alternate"></link><published>2015-12-15T10:45:00+03:00</published><updated>2015-12-15T10:45:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-12-15:/blog-movement.html</id><summary type="html">&lt;p&gt;Давно собирался перенести свой блог с Blogger и наконец сделал это. Со временем, перенесу все хорошие статьи оттуда. Новые статьи будут опубликованы только&amp;nbsp;здесь.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Давно собирался перенести свой блог с Blogger и наконец сделал это. Со временем, перенесу все хорошие статьи оттуда. Новые статьи будут опубликованы только&amp;nbsp;здесь.&lt;/p&gt;</content><category term="блог"></category></entry><entry><title>Blog Movement</title><link href="https://kochetkov.github.io/blog-movement-en.html" rel="alternate"></link><published>2015-12-15T10:45:00+03:00</published><updated>2015-12-15T10:45:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-12-15:/blog-movement-en.html</id><summary type="html">&lt;p&gt;For a long time I was going to move my blog from Blogger, and finally did it. Over time, I will transfer all good articles from there. New articles will be only published&amp;nbsp;here.&lt;/p&gt;</summary><content type="html">&lt;p&gt;For a long time I was going to move my blog from Blogger, and finally did it. Over time, I will transfer all good articles from there. New articles will be only published&amp;nbsp;here.&lt;/p&gt;</content><category term="блог"></category></entry><entry><title>По следам вебинара “Прикладная теория Application Security”</title><link href="https://kochetkov.github.io/webinar-applied-theory-of-the-application-security.html" rel="alternate"></link><published>2015-11-14T00:00:00+03:00</published><updated>2015-11-14T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-11-14:/webinar-applied-theory-of-the-application-security.html</id><summary type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления, на ходу подбирая нужные фразы и пояснения. Посему приношу извинения тем слушателям, которые так и не поняли, что это было. Вероятно в ближайшие месяцы, проведу работу над ошибками в формате статьи или серии заметок, дабы донести основные идеи более внятным и последовательным&amp;nbsp;образом.&lt;/p&gt;
&lt;p&gt;На вебинаре я обещал дать ссылки на несколько статей о символическом исполнении, абстрактной интерпретации и т.п. Поступим проще. Вот &lt;a href="https://www.dropbox.com/sh/sqln21ngapchx3l/AADiJqQuA1U8F4jX3tYly-q9a?dl=0"&gt;здесь&lt;/a&gt; лежит подборка материалов на эти и смежные темы, которые мы в той или иной мере использовали при работе над Application Inspector. Будут вопросы - задавайте в&amp;nbsp;комментариях.&lt;/p&gt;
&lt;p&gt;Что касается книг для дальнейшего чтения, то конкретно по теории есть не так уж и много материалов и практически все мне известные можно собрать по крупицам из подборки выше. Стоит отдельно отметить выступление Meredith L. Patterson, Sergey Bratus на 28C3 в 2011 (&lt;a href="http://www.youtube.com/watch?v=3kEfedtQVOY"&gt;видео&lt;/a&gt;, &lt;a href="http://langsec.org/insecurity-theory-28c3.pdf"&gt;слайды&lt;/a&gt;) и &lt;a href="http://nob.cs.ucdavis.edu/bishop/notes/2008-cse-14/2008-cse-14.pdf"&gt;работу&lt;/a&gt; Matt Bishop с коллегами, которую я упоминал на&amp;nbsp;вебинаре.&lt;/p&gt;
&lt;p&gt;Если говорить о практике, то мой &lt;span class="caps"&gt;TOP&lt;/span&gt; 5 книг, обязательных к прочтению на данную тему следующий (порядок&amp;nbsp;произвольный):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Writing Secure Code, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nostarch.com/tangledweb.htm"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Tangled Web. A Guide to Securing Modern Web&amp;nbsp;Applications&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118026470.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Web Application Hacker&amp;#8217;s Handbook: Finding and Exploiting Security Flaws, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118662091.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Browser Hacker&amp;#8217;s&amp;nbsp;Handbook&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-047008023X.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Shellcoder&amp;#8217;s Handbook: Discovering and Exploiting Security Holes, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Собственно, серию &amp;#8220;Handbooks&amp;#8221; данного издательства стоит прочесть&amp;nbsp;всю.&lt;/p&gt;
&lt;p&gt;P.S: Коллегам по конкурирующему цеху: парни, согласитесь, что обсуждать технические вопросы реализации Application Inspector на вебинаре, связанном с ним лишь косвенно - не вполне корректно по отношению к остальным слушателям. Я всегда готов делиться той информацией, которой имею право делиться со всеми, кто попросит. Даже с конкурентами, причем даже с теми конкурентами, руководство которых находится со мной в контрах. И для этого совсем не нужно дожидаться вебинара с моим участием, как повода задать интересующие вас вопросы :) Мои контакты доступны - пишите, звоните, буду рад пообщаться. Я&amp;nbsp;серьезно.&lt;/p&gt;</content><category term="вебинары"></category></entry></feed>