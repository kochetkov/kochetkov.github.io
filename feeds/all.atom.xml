<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>'';!--"&lt;kochetkov.vladimir&gt;=&amp;{()}</title><link href="https://kochetkov.github.io/" rel="alternate"></link><link href="https://kochetkov.github.io/feeds/all.atom.xml" rel="self"></link><id>https://kochetkov.github.io/</id><updated>2020-02-25T14:00:00+03:00</updated><entry><title>Мечтают ли WAF’ы о статанализаторах</title><link href="https://kochetkov.github.io/do-wafs-dream-of-static-analyzers-en.html" rel="alternate"></link><published>2020-02-25T14:00:00+03:00</published><updated>2020-02-25T14:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2020-02-25:/do-wafs-dream-of-static-analyzers-en.html</id><summary type="html">&lt;p&gt;Virtual patching (&lt;span class="caps"&gt;VP&lt;/span&gt;) has been one of the most popular trends in application protection in recent years. Implemented at the level of a web application firewall, &lt;span class="caps"&gt;VP&lt;/span&gt; allows protecting web applications against exploitation of previously defined vulnerabilities. (For our purposes, a web application firewall, or &lt;span class="caps"&gt;WAF&lt;/span&gt;, will refer to a dedicated solution operating on a separate node between an external gateway and web server.) In short, &lt;span class="caps"&gt;VP&lt;/span&gt; works by taking the results of static application security testing (&lt;span class="caps"&gt;SAST&lt;/span&gt;) and using them to create rules for filtering &lt;span class="caps"&gt;HTTP&lt;/span&gt; requests on the &lt;span class="caps"&gt;WAF&lt;/span&gt;. The problem, though, is that &lt;span class="caps"&gt;SAST&lt;/span&gt; and WAFs rely on different application presentation models and different decision-making methods. As a result, none of the currently available solutions do an adequate job of integrating &lt;span class="caps"&gt;SAST&lt;/span&gt; with WAFs. &lt;span class="caps"&gt;SAST&lt;/span&gt; is based on the white-box model, which applies formal approaches to detect vulnerabilities in code. Meanwhile, a &lt;span class="caps"&gt;WAF&lt;/span&gt; perceives an application as a black box, so it uses heuristics for attack detection. This state of affairs makes &lt;span class="caps"&gt;VP&lt;/span&gt; sub-optimal for preventing attacks when the exploitation conditions for a vulnerability go beyond the trivial &lt;code&gt;http_parameter=plain_text_attack_vector&lt;/code&gt;. But what if we could make &lt;span class="caps"&gt;SAST&lt;/span&gt; and a &lt;span class="caps"&gt;WAF&lt;/span&gt; &amp;#8220;play nice&amp;#8221; with each other? Perhaps we could obtain information about an application&amp;#8217;s internal structure via &lt;span class="caps"&gt;SAST&lt;/span&gt; but then make this information available to the &lt;span class="caps"&gt;WAF&lt;/span&gt;. That way we could detect attacks on vulnerabilities in a provable way, instead of by mere&amp;nbsp;guessing.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/title-picture.png"&gt;&lt;img alt="Титульная картинка" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/title-picture.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Virtual patching (&lt;span class="caps"&gt;VP&lt;/span&gt;) has been one of the most popular trends in application protection in recent years. Implemented at the level of a web application firewall, &lt;span class="caps"&gt;VP&lt;/span&gt; allows protecting web applications against exploitation of previously defined vulnerabilities. (For our purposes, a web application firewall, or &lt;span class="caps"&gt;WAF&lt;/span&gt;, will refer to a dedicated solution operating on a separate node between an external gateway and web&amp;nbsp;server.)&lt;/p&gt;
&lt;p&gt;In short, &lt;span class="caps"&gt;VP&lt;/span&gt; works by taking the results of static application security testing (&lt;span class="caps"&gt;SAST&lt;/span&gt;) and using them to create rules for filtering &lt;span class="caps"&gt;HTTP&lt;/span&gt; requests on the &lt;span class="caps"&gt;WAF&lt;/span&gt;. The problem, though, is that &lt;span class="caps"&gt;SAST&lt;/span&gt; and WAFs rely on different application presentation models and different decision-making methods. As a result, none of the currently available solutions do an adequate job of integrating &lt;span class="caps"&gt;SAST&lt;/span&gt; with WAFs. &lt;span class="caps"&gt;SAST&lt;/span&gt; is based on the white-box model, which applies formal approaches to detect vulnerabilities in code. Meanwhile, a &lt;span class="caps"&gt;WAF&lt;/span&gt; perceives an application as a black box, so it uses heuristics for attack detection. This state of affairs makes &lt;span class="caps"&gt;VP&lt;/span&gt; sub-optimal for preventing attacks when the exploitation conditions for a vulnerability go beyond the trivial &lt;code&gt;http_parameter=plain_text_attack_vector&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if we could make &lt;span class="caps"&gt;SAST&lt;/span&gt; and a &lt;span class="caps"&gt;WAF&lt;/span&gt; &amp;#8220;play nice&amp;#8221; with each other? Perhaps we could obtain information about an application&amp;#8217;s internal structure via &lt;span class="caps"&gt;SAST&lt;/span&gt; but then make this information available to the &lt;span class="caps"&gt;WAF&lt;/span&gt;. That way we could detect attacks on vulnerabilities in a provable way, instead of by mere&amp;nbsp;guessing.&lt;/p&gt;
&lt;h2&gt;Splendors and miseries of traditional &lt;span class="caps"&gt;VP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;The traditional approach to automated virtual patching for web applications involves providing the &lt;span class="caps"&gt;WAF&lt;/span&gt; with information about each vulnerability that has been detected with &lt;span class="caps"&gt;SAST&lt;/span&gt;. This information&amp;nbsp;includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vulnerability&amp;nbsp;class;&lt;/li&gt;
&lt;li&gt;vulnerable entry point to the web application (full or partial &lt;span class="caps"&gt;URL&lt;/span&gt;);&lt;/li&gt;
&lt;li&gt;values of additional &lt;span class="caps"&gt;HTTP&lt;/span&gt; request parameters necessary for the&amp;nbsp;attack;&lt;/li&gt;
&lt;li&gt;values of the vulnerable parameter constituting the attack&amp;nbsp;vector;&lt;/li&gt;
&lt;li&gt;set of characters or words (tokens) whose presence in a vulnerable parameter will lead to exploitation of the&amp;nbsp;vulnerability.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The set of &lt;span class="caps"&gt;HTTP&lt;/span&gt; request parameters and dangerous elements of a vulnerable parameter can be defined both by bruteforcing and by using a generic function (typically based on regular expressions). Let us look at a fragment of code from an &lt;span class="caps"&gt;ASP&lt;/span&gt;.&lt;span class="caps"&gt;NET&lt;/span&gt; page that is vulnerable to &lt;a href="https://habrahabr.ru/company/pt/blog/149152/"&gt;&lt;span class="caps"&gt;XSS&lt;/span&gt;&lt;/a&gt;&amp;nbsp;attacks:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;01&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;02&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;03&lt;/span&gt;
&lt;span class="m"&gt;04&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;05&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;06&lt;/span&gt;      &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wrong parameters!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="m"&gt;07&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;08&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;09&lt;/span&gt;
&lt;span class="m"&gt;10&lt;/span&gt;  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;11&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;secret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;12&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;13&lt;/span&gt;    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;`&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;14&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;15&lt;/span&gt;  &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="m"&gt;16&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;17&lt;/span&gt;    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Secret not found!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;18&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;19&lt;/span&gt;
&lt;span class="m"&gt;20&lt;/span&gt;  &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;b&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;/b&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;By analyzing this attack vector code, we can generate a symbolic formula for the set of attack vector&amp;nbsp;values: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;{condition = "secret" ⇒ param ∈ { XSShtml-text }}&lt;/code&gt;, where XSShtml-text is the set of possible vectors of an &lt;span class="caps"&gt;XSS&lt;/span&gt; attack in the context of &lt;span class="caps"&gt;TEXT&lt;/span&gt;, as described in the &lt;span class="caps"&gt;HTML&lt;/span&gt;&amp;nbsp;grammar.&lt;/p&gt;
&lt;p&gt;This formula may yield both an exploit and a virtual patch. The descriptor of the &lt;span class="caps"&gt;WAF&lt;/span&gt; virtual patch can be used to generate filtering rules to block all &lt;span class="caps"&gt;HTTP&lt;/span&gt; requests capable of exploiting the relevant&amp;nbsp;vulnerability.&lt;/p&gt;
&lt;p&gt;Although this approach surely heads off certain attacks, it has some substantial&amp;nbsp;drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;to demonstrate any given vulnerability, &lt;span class="caps"&gt;SAST&lt;/span&gt; needs to discover just one of the possible attack vectors. But to ensure true elimination of a vulnerability, it is necessary to address all possible attack vectors. Passing such information to the &lt;span class="caps"&gt;WAF&lt;/span&gt; is difficult, because the set of vectors is not only infinite but cannot even be expressed in regular expressions due to the irregularity of attack vector&amp;nbsp;grammars;&lt;/li&gt;
&lt;li&gt;the same is true for values of all additional request parameters that are necessary for vulnerability&amp;nbsp;exploitation;&lt;/li&gt;
&lt;li&gt;information regarding dangerous elements of a vulnerable parameter becomes useless if an attack vector, between the entry point and vulnerable execution point, undergoes intermediate transformations that change the context of its grammar or even its entire grammar (such as with Base64, &lt;span class="caps"&gt;URL&lt;/span&gt;, or &lt;span class="caps"&gt;HTML&lt;/span&gt; encoding, or string&amp;nbsp;transformations).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Due to these flaws, &lt;span class="caps"&gt;VP&lt;/span&gt; technology—which is designed for piecemeal protection—is incapable of offering protection against all possible attacks on &lt;span class="caps"&gt;SAST&lt;/span&gt;-detected vulnerabilities. Attempts to create such &amp;#8220;all-encompassing&amp;#8221; traffic filtering rules often lead to blocking of legitimate &lt;span class="caps"&gt;HTTP&lt;/span&gt; requests and disrupt operation of the web application. Let us slightly modify the vulnerable&amp;nbsp;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;01&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;02&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;03&lt;/span&gt; 
&lt;span class="m"&gt;04&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;05&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;06&lt;/span&gt;      &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wrong parameters!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="m"&gt;07&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;08&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;09&lt;/span&gt; 
&lt;span class="m"&gt;10&lt;/span&gt;  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;11&lt;/span&gt;  &lt;span class="c1"&gt;// CustomDecode implements chain data transformation base64-URL-base64&lt;/span&gt;
&lt;span class="m"&gt;12&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomDecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;Contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;secret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="m"&gt;13&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;14&lt;/span&gt;      &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;CustomDecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;`&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;15&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;16&lt;/span&gt;  &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="m"&gt;17&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;18&lt;/span&gt;       &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Secret not found!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;19&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;20&lt;/span&gt; 
&lt;span class="m"&gt;21&lt;/span&gt;  &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The only difference from the previous example is that both request parameters now undergo a transformation and the condition for the &lt;code&gt;secret&lt;/code&gt; parameter is weakened until the sub-string is included back in. The attack vector formula, based on analysis of this new code, is as&amp;nbsp;follows: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(String.Contains (CustomDecode (condition)) ("secret"))  ⇒ param ∈ (CustomDecode { XSShtml-text })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The analyzer will derive a formula at the relevant computation flow graph (CompFG) node for the CustomDecode function to describe the Base64—&lt;span class="caps"&gt;URL&lt;/span&gt;—Base64 transformation&amp;nbsp;chain: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Base64Decode (UrlDecode (Base64Decode argument)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;It is still possible to build an exploit on the basis of such formulas (we have considered this issue in a previous &lt;a href="https://kochetkov.github.io/sast-theory-practice-and-prospects-en.html"&gt;article&lt;/a&gt;), but the classical approach to generating virtual patches cannot be applied here for the following&amp;nbsp;reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the vulnerability may be exploited only if the decoded &lt;code&gt;condition&lt;/code&gt; parameter of the request contains the &amp;#8220;secret&amp;#8221; substring (String 12). However, this parameter&amp;#8217;s set of values is quite large and expressing this set via regular expressions is infeasible due to the irregularity of decoding&amp;nbsp;functions;&lt;/li&gt;
&lt;li&gt;request parameter that is, in fact, an attack vector also is decoded (String 14). Therefore, &lt;span class="caps"&gt;SAST&lt;/span&gt; cannot describe that set of dangerous elements to the &lt;span class="caps"&gt;WAF&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since all the problems of traditional &lt;span class="caps"&gt;VP&lt;/span&gt; stem from the inability to interact with an application at the &lt;span class="caps"&gt;WAF&lt;/span&gt; level based on the white-box approach, the obvious solution is to implement this capability and make further improvements so&amp;nbsp;that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="caps"&gt;SAST&lt;/span&gt; provides the &lt;span class="caps"&gt;WAF&lt;/span&gt; with full information about all transformations to which a vulnerable parameter and variables of attack conditions are subjected, from entry point to vulnerable execution point. This enables the &lt;span class="caps"&gt;WAF&lt;/span&gt; to compute argument values based on the values of the parameters of a given &lt;span class="caps"&gt;HTTP&lt;/span&gt;&amp;nbsp;request;&lt;/li&gt;
&lt;li&gt;for attack detection, heuristics are replaced with formal methods that are based on rigorous proof of all statements and describe the exploitation conditions for any particular vulnerability in the most general case, instead of haphazardly describing a limited number of&amp;nbsp;cases.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus was born runtime virtual&amp;nbsp;patching.&lt;/p&gt;
&lt;h2&gt;Runtime virtual&amp;nbsp;patching&lt;/h2&gt;
&lt;p&gt;Runtime virtual patching (&lt;span class="caps"&gt;RVP&lt;/span&gt;) is based on the computation flow graph model used in &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector (&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;). The model is built using abstract interpretation of an application&amp;#8217;s code, expressed in semantics similar to conventional symbolic computations. Nodes of this graph contain generating formulas in the target language. The formulas yield the set of all allowable values associated with all data flows at the relevant execution&amp;nbsp;points:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/compfg-example.png"&gt;&lt;img alt="CompFG example" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/compfg-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;These flows are called execution point arguments. CompFG is evaluable, and thus able to compute sets of specific values for all arguments at any execution point, based on the values that have been set for input&amp;nbsp;parameters.&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;RVP&lt;/span&gt; occurs in two stages, which correspond to the application lifecycle: Deployment (D) and Run&amp;nbsp;(R):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/rvp-workflow.png"&gt;&lt;img alt="RVP workflow" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/rvp-workflow.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Deployment&amp;nbsp;stage&lt;/h3&gt;
&lt;p&gt;Before a new version of an application is deployed, the application is analyzed by &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;. Three formulas are computed for each CompFG node that describes a vulnerable execution&amp;nbsp;point:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;conditions for reaching the vulnerable execution&amp;nbsp;point;&lt;/li&gt;
&lt;li&gt;conditions for reaching values of all its&amp;nbsp;arguments;&lt;/li&gt;
&lt;li&gt;sets of values of all arguments and corresponding&amp;nbsp;grammars.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All formula sets are grouped by the application entry point to whose control flow the vulnerability relates. The very notion of entry point is specific to each web framework supported by &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; and is defined in the analyzer&amp;#8217;s&amp;nbsp;database.&lt;/p&gt;
&lt;p&gt;Then a report containing the list of vulnerabilities and related formulas is extracted in the form of code written in a special language based on S-expression syntax. This language describes CompFG formulas in a form that does not depend on the target language. For instance, the formula describing the value of an argument for the vulnerable point in the above code sample is as&amp;nbsp;follows:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(+ ("Parameter value is ``") (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (param))))) ("``"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The formula for reaching the vulnerable point&amp;nbsp;is:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Contains (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (condition))))) ("secret"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The report is then uploaded to &lt;span class="caps"&gt;PT&lt;/span&gt; Application Firewall (&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt;). On the basis of the report, a binary module is generated, which can compute all the formulas contained in the report. For example, the decompiled code for computing the condition for reaching the above-mentioned vulnerable point is as&amp;nbsp;follows: &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/evaluator-example.png"&gt;&lt;img alt="Evaluator example" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/evaluator-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To make formula computation possible, &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt; must have one of the&amp;nbsp;following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pre-compute database of all functions that may occur in the&amp;nbsp;report;&lt;/li&gt;
&lt;li&gt;an isolated sandbox with runtime environment for the language or platform on which the web application runs (such as &lt;span class="caps"&gt;CLR&lt;/span&gt;, &lt;span class="caps"&gt;JVM&lt;/span&gt;, or &lt;span class="caps"&gt;PHP&lt;/span&gt;, Python, or Ruby interpreter), and libraries used in the&amp;nbsp;application.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first method ensures maximum speed but requires a huge volume of manual work by the &lt;span class="caps"&gt;WAF&lt;/span&gt; developers to describe the pre-compute database even if the developers restrict the scope to standard library functions). The second method allows computing all the functions that may occur in the report, but increases the time needed to process each &lt;span class="caps"&gt;HTTP&lt;/span&gt; request, because the &lt;span class="caps"&gt;WAF&lt;/span&gt; needs to access the runtime environment to compute each function. The most appropriate solution here would be to use the first approach for the most common functions while using the second approach for the&amp;nbsp;rest.&lt;/p&gt;
&lt;p&gt;It is quite possible for a formula to contain a function that the analyzer cannot process (for instance, calling a method that involves a missing project dependency or native code) and/or a function that &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt; is unable to compute (for instance, a function for reading data from external sources or the server environment). Such functions are flagged &amp;#8220;unknown&amp;#8221; in formulas and processed in a special way as described&amp;nbsp;below.&lt;/p&gt;
&lt;h3&gt;Run&amp;nbsp;stage&lt;/h3&gt;
&lt;p&gt;At the run stage, the &lt;span class="caps"&gt;WAF&lt;/span&gt; delegates processing of each &lt;span class="caps"&gt;HTTP&lt;/span&gt; request to the binary module. The module analyzes a request and detects the relevant entry point in the web application. For this point, formulas of all detected vulnerabilities are selected and then computed in a specific&amp;nbsp;way.&lt;/p&gt;
&lt;p&gt;First, formulas are computed for both conditions: 1) reaching the vulnerable point and 2) reaching values of all its arguments. In each formula, variables are substituted with values of the relevant request parameters, after which the formula value is computed. If a formula contains expressions that are flagged &amp;#8220;unknown&amp;#8221;, it is processed as&amp;nbsp;follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;each &amp;#8220;unknown&amp;#8221; flag spreads bottom-up through the formula expression tree until a Boolean expression is&amp;nbsp;found;&lt;/li&gt;
&lt;li&gt;in the formula, such expressions (&amp;#8220;unknown&amp;#8221; regions) are substituted with Boolean variables, so the Boolean satisfiability problem is&amp;nbsp;solved;&lt;/li&gt;
&lt;li&gt;the assumption formula generates n conditions by substituting possible values of unknown regions from all the solutions found in the previous&amp;nbsp;step;&lt;/li&gt;
&lt;li&gt;the value of each formula is computed. If at least one formula is satisfiable, the assumption is deemed satisfiable as&amp;nbsp;well.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If computations show that the assumption is false, then the &lt;span class="caps"&gt;HTTP&lt;/span&gt; request in question cannot lead the application to a vulnerable point even with dangerous values of all request arguments. In this case, &lt;span class="caps"&gt;RVP&lt;/span&gt; simply returns request processing to the &lt;span class="caps"&gt;WAF&lt;/span&gt;&amp;#8217;s core&amp;nbsp;module.&lt;/p&gt;
&lt;p&gt;If attack conditions are satisfiable, the value of the argument of the vulnerable point is then computed. Algorithms used depend on the vulnerability class to which the analyzed point belongs. Their only similarity is the logic used to process formulas that contain unknown nodes: unlike assumption formulas, argument formulas cannot possibly be computed, which is immediately communicated to the &lt;span class="caps"&gt;WAF&lt;/span&gt;. Then the next vulnerable point is computed. To better flesh this out, we shall now review the most complicated algorithm, which is used for detecting injection&amp;nbsp;attacks.&lt;/p&gt;
&lt;h3&gt;Detecting&amp;nbsp;injections&lt;/h3&gt;
&lt;p&gt;Injections include any attacks that target the integrity of text written in a formal language (including &lt;span class="caps"&gt;HTML&lt;/span&gt;, &lt;span class="caps"&gt;XML&lt;/span&gt;, JavaScript, &lt;span class="caps"&gt;SQL&lt;/span&gt;, URLs, and file paths) on the basis of data controlled by the attacker. The attack is carried out by passing specifically formed input data to the application. When this data is &amp;#8220;plugged in&amp;#8221; to the target text, the boundaries of the token are exceeded and the text now includes syntactic constructions not intended by the application&amp;nbsp;logic.&lt;/p&gt;
&lt;p&gt;If a vulnerable point belongs to this attack class, its argument value is determined using incremental computation with abstract interpretation using taint analysis semantics. The idea behind this method is that each expression is computed separately, from bottom to top, while the computation results obtained at each step are additionally marked with taint intervals, given the semantics of each function and rules of traditional &lt;a href="https://en.wikipedia.org/wiki/Taint_checking"&gt;taint checking&lt;/a&gt;. This makes it possible to pinpoint all fragments that are the result of transformation of input data (tainted&amp;nbsp;fragments).&lt;/p&gt;
&lt;p&gt;For instance, for the code above and the following &lt;span class="caps"&gt;HTTP&lt;/span&gt; request parameter &lt;code&gt;?condition=YzJWamNtVjA%3d&amp;amp;param=UEhOamNtbHdkRDVoYkdWeWRDZ3hLVHd2YzJOeWFYQjBQZyUzRCUzRA%3d%3d&lt;/code&gt;, the result of applying this algorithm to the formula of a vulnerable point argument is as follows (tainted arguments are marked in&amp;nbsp;red):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/incremental-evaluation-exampe.png"&gt;&lt;img alt="Incremental evaluation example" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/incremental-evaluation-exampe.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The value is then tokenized in accordance with the grammar of the vulnerable point argument. If any tainted fragment matches more than one token, this is a formal sign of an injection attack (based on the definition of injection given at the beginning of this&amp;nbsp;section).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/tokenization-example.png"&gt;&lt;img alt="Tokenization example" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/tokenization-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once formulas have been computed for all vulnerabilities pertaining to the current entry point, request processing is passed on to the &lt;span class="caps"&gt;WAF&lt;/span&gt;&amp;#8217;s core module together with detection&amp;nbsp;results.&lt;/p&gt;
&lt;h3&gt;&lt;span class="caps"&gt;RVP&lt;/span&gt; advantages and specific&amp;nbsp;features&lt;/h3&gt;
&lt;p&gt;This approach to application protection based on code analysis has a range of substantial advantages as compared to traditional &lt;span class="caps"&gt;VP&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the shortcomings of traditional &lt;span class="caps"&gt;VP&lt;/span&gt; are addressed, thanks to the formal approach described above and the ability to take into account any and all intermediate&amp;nbsp;transformations;&lt;/li&gt;
&lt;li&gt;the formal approach also completely rules out the possibility of false positives, so long as the formulas do not contain unknown&amp;nbsp;nodes;&lt;/li&gt;
&lt;li&gt;there is no adverse impact on web application functionality, because protection is built on the functions of the application, as opposed to simply trying to work around&amp;nbsp;them. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For testing the technology and confirming its effectiveness, we have developed a prototype of an integration module for &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector and &lt;span class="caps"&gt;PT&lt;/span&gt; Application Firewall, in the form of a .&lt;span class="caps"&gt;NET&lt;/span&gt; &lt;span class="caps"&gt;HTTP&lt;/span&gt; module for &lt;span class="caps"&gt;IIS&lt;/span&gt; web server. A video of the prototype handling the code example above is on &lt;a href="https://www.youtube.com/watch?v=U1NbKuZkb8c"&gt;YouTube&lt;/a&gt;. Performance tests on around fifteen open-source content management systems (CMSs) have shown great results: the time required for processing &lt;span class="caps"&gt;HTTP&lt;/span&gt; requests with &lt;span class="caps"&gt;RVP&lt;/span&gt; is comparable to the time that it takes to process such requests with traditional (heuristic) &lt;span class="caps"&gt;WAF&lt;/span&gt; methods. The average performance hit for web applications was as&amp;nbsp;follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0% for requests that do not lead to a vulnerable&amp;nbsp;point;&lt;/li&gt;
&lt;li&gt;6–10% for requests that lead to a vulnerable point and are not an attack (depending on complexity of the grammar of the vulnerable&amp;nbsp;point);&lt;/li&gt;
&lt;li&gt;4–7% for requests that lead to a vulnerable point and are an&amp;nbsp;attack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Despite obvious advantages over traditional &lt;span class="caps"&gt;VP&lt;/span&gt;, &lt;span class="caps"&gt;RVP&lt;/span&gt; still has several conceptual&amp;nbsp;shortcomings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it is not possible to compute formulas that contain data from external sources absent on the &lt;span class="caps"&gt;WAF&lt;/span&gt; (including file resources, databases, and server&amp;nbsp;environment);&lt;/li&gt;
&lt;li&gt;the quality of formulas directly depends on the quality of approximation of code fragments during analysis (including loops, recursion, and calls to external library&amp;nbsp;methods);&lt;/li&gt;
&lt;li&gt;to describe semantics of transformation functions for the pre-compute database, some engineering work from the developers is required. The description process is difficult to automate and is prone to human&amp;nbsp;error. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, we have managed to mitigate these weaknesses by offloading some &lt;span class="caps"&gt;RVP&lt;/span&gt; functions to the application and by applying the technologies that underlie runtime application self-protection (&lt;span class="caps"&gt;RASP&lt;/span&gt;).&lt;/p&gt;
&lt;h2&gt;Advanced &lt;span class="caps"&gt;RASP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;In essence, the &lt;span class="caps"&gt;ARASP&lt;/span&gt; approach consists of using the application itself to compute the formula fragments that cannot be computed by the &lt;span class="caps"&gt;RVP&lt;/span&gt;. An additional instrumentation module is deployed on the application side in order to integrate detector sensors into the web application. These sensors allow getting the values of any fragments of the formulas computed by the &lt;span class="caps"&gt;RVP&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;span class="caps"&gt;ARASP&lt;/span&gt; workflow is effectively an extension of the &lt;span class="caps"&gt;RVP&lt;/span&gt;&amp;#8217;s one, and is different from it in the following&amp;nbsp;ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the report exported from &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;, each expression in a formula is supplemented by additional attribute: its coordinates in the&amp;nbsp;code:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;36&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;FromBase64Str&lt;/span&gt;   
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;35&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UrlDecodeStr&lt;/span&gt; 
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;32&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;FromBase64Str&lt;/span&gt;   
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;31&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;GetParameterData&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;The report is used to generate not only a formula computation module, but also an instrumentation module that runs on the application side. This module embeds detector sensors at all execution points in the application that correspond uncertain expressions in the report. The module also inserts breakpoints that hand off control to the &lt;span class="caps"&gt;RVP&lt;/span&gt; before proceeding to the vulnerable execution&amp;nbsp;point:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/instrumented-code.png"&gt;&lt;img alt="Instrumented code" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/instrumented-code.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="caps"&gt;RVP&lt;/span&gt; does not take control when processing an &lt;span class="caps"&gt;HTTP&lt;/span&gt; request, instead allowing the application to process the request up until the breakpoint that precedes the vulnerable execution point (when this point is reached, the &lt;span class="caps"&gt;RVP&lt;/span&gt; already has collected information from all of the detector sensors that have been triggered up to that&amp;nbsp;point).&lt;/li&gt;
&lt;li&gt;When the breakpoint is reached, processing of the &lt;span class="caps"&gt;HTTP&lt;/span&gt; request is handed over to the &lt;span class="caps"&gt;RVP&lt;/span&gt; and formulas are computed in a way equivalent to the description in the previous section, with one important difference: if the formula contains an uncertain expression, or an expression that cannot be computed by the &lt;span class="caps"&gt;RVP&lt;/span&gt; (because of references to external data sources or the absence of a necessary transformation function in the knowledge base), then the value of the expression is taken from the pool of information that has been accumulated in the application as of when detector sensors were&amp;nbsp;triggered.&lt;/li&gt;
&lt;li&gt;If an attack is detected, processing of the request is stopped (and therefore the application does not reach the vulnerable execution&amp;nbsp;point).&lt;/li&gt;
&lt;li&gt;If no attack is detected, processing of the request is returned to the application until the next breakpoint is reached or until processing of the request is&amp;nbsp;completed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This approach significantly expands upon the abilities of &lt;span class="caps"&gt;RVP&lt;/span&gt;, eliminating the drawbacks of &lt;span class="caps"&gt;RVP&lt;/span&gt; as regards the quality of application&amp;nbsp;protection.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/arasp-workflow.png"&gt;&lt;img alt="ARASP workflow" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/arasp-workflow.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Advantages of &lt;span class="caps"&gt;ARASP&lt;/span&gt;: More than just virtual&amp;nbsp;patching&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; can be configured to export formulas for all potentially vulnerable execution points, without detecting vulnerabilities in them, thereby assuring full coverage of all dangerous fragments of application code. This is what in fact makes &lt;span class="caps"&gt;ARASP&lt;/span&gt; a comprehensive solution for application protection. This next-generation &lt;span class="caps"&gt;WAF&lt;/span&gt; takes a white-box approach to the application and uses formal detection methods instead of heuristic ones. Compared to the traditional &lt;span class="caps"&gt;RASP&lt;/span&gt; approach, this solution has several advantages:
* negligible performance penalty. Processing of a request by application fragments occurs in parallel with processing of the same request by the &lt;span class="caps"&gt;WAF&lt;/span&gt; module running &lt;span class="caps"&gt;ARASP&lt;/span&gt;:
* minimal hit to application stability. Instrumentation is used only for those execution points that are truly needed for computing formulas;
* precise (close to 100%) detection of attacks, thanks to use of CompFG model elements and formal methods for operating on these&amp;nbsp;elements.&lt;/p&gt;
&lt;p&gt;That it &lt;span class="caps"&gt;RVP&lt;/span&gt; and &lt;span class="caps"&gt;ARASP&lt;/span&gt; represent the most promising way forward in application protection, and will continue to develop them as the main vector for improving integration between &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector and &lt;span class="caps"&gt;PT&lt;/span&gt; Application&amp;nbsp;Firewall.&lt;/p&gt;</content><category term="Blog"></category><category term="SAST"></category><category term="static code analysis"></category><category term="Application Inspector"></category><category term="WAF"></category><category term="Application Firewall"></category></entry><entry><title>Мечтают ли WAF’ы о статанализаторах</title><link href="https://kochetkov.github.io/do-wafs-dream-of-static-analyzers.html" rel="alternate"></link><published>2017-09-20T12:00:00+03:00</published><updated>2020-02-25T14:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2017-09-20:/do-wafs-dream-of-static-analyzers.html</id><summary type="html">&lt;p&gt;Одна из самых популярных тенденций в области защиты приложений нынешнего десятилетия — технология виртуального патчинга (virtual patching, &lt;span class="caps"&gt;VP&lt;/span&gt;), позволяющая защитить веб-приложение от эксплуатации имеющихся в нем известных уязвимостей на уровне межсетевого экрана уровня веб-приложений (web application firewall; здесь и далее под &lt;span class="caps"&gt;WAF&lt;/span&gt; подразумевается выделенное решение, функционирующее на отдельном узле, между шлюзом во внешнюю сеть и веб-сервером). Технология &lt;span class="caps"&gt;VP&lt;/span&gt; основана на построении правил фильтрации &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; по результатам работы средств статического анализа защищенности приложения (static application security testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;). Однако из-за того, что средства &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; опираются на различные модели представления приложения и различные методы принятия решений, на рынке до сих пор нет по-настоящему эффективных решений их интеграции. В рамках &lt;span class="caps"&gt;SAST&lt;/span&gt; работа с приложением осуществляется по модели белого ящика и, как правило, используются формальные подходы к поиску уязвимостей в коде. Для &lt;span class="caps"&gt;WAF&lt;/span&gt; же приложение представляет собой черный ящик, а для детектирования атак применяются эвристики. Это не позволяет эффективно использовать &lt;span class="caps"&gt;VP&lt;/span&gt; для защиты от атак в тех случаях, когда условия эксплуатации уязвимости выходят за рамки тривиальной схемы &lt;code&gt;http_parameter=plain_text_attack_vector&lt;/code&gt;. Но что, если «подружить» &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; таким образом, чтобы информация о внутреннем устройстве приложения, полученная с помощью &lt;span class="caps"&gt;SAST&lt;/span&gt;, стала доступной на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; и дала ему возможность детектировать атаки на обнаруженные уязвимости — не угадывая, но доказывая факт&amp;nbsp;атаки?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/title-picture.png"&gt;&lt;img alt="Титульная картинка" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/title-picture.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Одна из самых популярных тенденций в области защиты приложений нынешнего десятилетия — технология виртуального патчинга (virtual patching, &lt;span class="caps"&gt;VP&lt;/span&gt;), позволяющая защитить веб-приложение от эксплуатации имеющихся в нем известных уязвимостей на уровне межсетевого экрана уровня веб-приложений (web application firewall; здесь и далее под &lt;span class="caps"&gt;WAF&lt;/span&gt; подразумевается выделенное решение, функционирующее на отдельном узле, между шлюзом во внешнюю сеть и веб-сервером). Технология &lt;span class="caps"&gt;VP&lt;/span&gt; основана на построении правил фильтрации &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; по результатам работы средств статического анализа защищенности приложения (static application security testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;). Однако из-за того, что средства &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; опираются на различные модели представления приложения и различные методы принятия решений, на рынке до сих пор нет по-настоящему эффективных решений их интеграции. В рамках &lt;span class="caps"&gt;SAST&lt;/span&gt; работа с приложением осуществляется по модели белого ящика и, как правило, используются формальные подходы к поиску уязвимостей в коде. Для &lt;span class="caps"&gt;WAF&lt;/span&gt; же приложение представляет собой черный ящик, а для детектирования атак применяются эвристики. Это не позволяет эффективно использовать &lt;span class="caps"&gt;VP&lt;/span&gt; для защиты от атак в тех случаях, когда условия эксплуатации уязвимости выходят за рамки тривиальной схемы &lt;code&gt;http_parameter=plain_text_attack_vector&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Но что, если «подружить» &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; таким образом, чтобы информация о внутреннем устройстве приложения, полученная с помощью &lt;span class="caps"&gt;SAST&lt;/span&gt;, стала доступной на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; и дала ему возможность детектировать атаки на обнаруженные уязвимости — не угадывая, но доказывая факт&amp;nbsp;атаки?&lt;/p&gt;
&lt;h2&gt;Блеск и нищета традиционного &lt;span class="caps"&gt;VP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Традиционный подход к автоматизации создания виртуальных патчей для веб-приложений заключается в предоставлении &lt;span class="caps"&gt;WAF&lt;/span&gt; информации о каждой обнаруженной с помощью &lt;span class="caps"&gt;SAST&lt;/span&gt; уязвимости,&amp;nbsp;включающей:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;класс&amp;nbsp;уязвимости;&lt;/li&gt;
&lt;li&gt;уязвимую точку входа в веб-приложение (&lt;span class="caps"&gt;URL&lt;/span&gt; или его&amp;nbsp;часть);&lt;/li&gt;
&lt;li&gt;значения дополнительных параметров &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса, при которых атака становится&amp;nbsp;возможной;&lt;/li&gt;
&lt;li&gt;значения уязвимого параметра — носителя вектора&amp;nbsp;атаки;&lt;/li&gt;
&lt;li&gt;множество символов или слов (токенов), появление которых в уязвимом параметре приведет к эксплуатации&amp;nbsp;уязвимости.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для определения множеств значений параметров &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса и опасных элементов уязвимого параметра могут использоваться как простое перечисление всех возможных элементов, так и генерирующая функция (как правило, на базе регулярных выражений). Рассмотрим фрагмент кода &lt;span class="caps"&gt;ASP&lt;/span&gt;.&lt;span class="caps"&gt;NET&lt;/span&gt;-страницы, уязвимый для атак &lt;a href="https://habrahabr.ru/company/pt/blog/149152/"&gt;&lt;span class="caps"&gt;XSS&lt;/span&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;01&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;02&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;03&lt;/span&gt;
&lt;span class="m"&gt;04&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;05&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;06&lt;/span&gt;      &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wrong parameters!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="m"&gt;07&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;08&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;09&lt;/span&gt;
&lt;span class="m"&gt;10&lt;/span&gt;  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;11&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;secret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;12&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;13&lt;/span&gt;    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;`&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;14&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;15&lt;/span&gt;  &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="m"&gt;16&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;17&lt;/span&gt;    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Secret not found!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;18&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;19&lt;/span&gt;
&lt;span class="m"&gt;20&lt;/span&gt;  &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;b&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;/b&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В результате анализа этого кода для вектора атаки будет выведена символическая формула условного множества его&amp;nbsp;значений: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;{condition = "secret" ⇒ param ∈ { XSShtml-text }}, где XSShtml-text — множество возможных векторов XSS-атаки в контексте TEXT, описанном в грамматике HTML&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Из этой формулы может быть выведен как эксплойт, так и виртуальный патч. На основе дескриптора виртуального патча &lt;span class="caps"&gt;WAF&lt;/span&gt; формирует правила фильтрации, позволяющие блокировать все &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросы, выполнение которых может привести к эксплуатации найденной&amp;nbsp;уязвимости. &lt;/p&gt;
&lt;p&gt;Такой подход, безусловно, позволяет защищаться от некоторого множества атак, однако обладает и существенными&amp;nbsp;недостатками:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;для доказательства наличия уязвимости средству &lt;span class="caps"&gt;SAST&lt;/span&gt; достаточно обнаружить один из возможных векторов атак на нее. Для эффективного устранения уязвимости необходимо защититься от всех возможных векторов, которые бывает затруднительно сообщить на сторону &lt;span class="caps"&gt;WAF&lt;/span&gt;, поскольку их множество не только бесконечно, но и зачастую не может быть выражено регулярными выражениями в силу нерегулярности грамматик векторов&amp;nbsp;атак;&lt;/li&gt;
&lt;li&gt;то же самое касается и значений всех дополнительных параметров запроса, при которых становится возможна эксплуатация&amp;nbsp;уязвимости;&lt;/li&gt;
&lt;li&gt;информация об опасных элементах уязвимого параметра бесполезна в том случае, если на пути от точки входа до уязвимой точки выполнения вектор атаки подвергается промежуточным преобразованиям, изменяющим контекст его грамматики или даже всю грамматику (например, Base64-, &lt;span class="caps"&gt;URL&lt;/span&gt;- или &lt;span class="caps"&gt;HTML&lt;/span&gt;-кодирование, строковые&amp;nbsp;преобразования).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти недостатки приводят к тому, что технология &lt;span class="caps"&gt;VP&lt;/span&gt;, ориентированная на защиту от частных случаев, не позволяет эффективно защититься от всех возможных атак на обнаруженные с помощью средств &lt;span class="caps"&gt;SAST&lt;/span&gt; уязвимости. Кроме того, построенные таким образом правила фильтрации трафика часто приводят к блокированию штатных &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов и нарушению работы защищаемого приложения. Немного изменим уязвимый&amp;nbsp;код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;01&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;02&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;03&lt;/span&gt; 
&lt;span class="m"&gt;04&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;05&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;06&lt;/span&gt;      &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wrong parameters!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="m"&gt;07&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;08&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;09&lt;/span&gt; 
&lt;span class="m"&gt;10&lt;/span&gt;  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;11&lt;/span&gt;  &lt;span class="c1"&gt;// CustomDecode реализует цепочку преобразований base64-URL-base64&lt;/span&gt;
&lt;span class="m"&gt;12&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomDecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;Contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;secret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="m"&gt;13&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;14&lt;/span&gt;      &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;CustomDecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;`&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;15&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;16&lt;/span&gt;  &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="m"&gt;17&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;18&lt;/span&gt;       &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Secret not found!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;19&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;20&lt;/span&gt; 
&lt;span class="m"&gt;21&lt;/span&gt;  &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Разница с предыдущим примером лишь в том, что теперь оба параметра запроса подвергаются некоторому преобразованию и условие на параметр &lt;code&gt;secret&lt;/code&gt; ослаблено до включения подстроки. Формула вектора атаки в результате анализа этого кода примет&amp;nbsp;вид: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(String.Contains (CustomDecode (condition)) ("secret"))  ⇒ param ∈ (CustomDecode { XSShtml-text })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;При этом для функции CustomDecode в соответствующей вершине CompFG анализатором будет выведена формула, описывающая цепочку преобразований Base64-&lt;span class="caps"&gt;URL&lt;/span&gt;-Base64: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Base64Decode (UrlDecode (Base64Decode argument)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;По формулам такого вида все еще возможно построить эксплойт (об этом я подробно рассказывал в одной из предыдущих &lt;a href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html"&gt;статей&lt;/a&gt;), однако применить классический подход к построению виртуальных патчей здесь уже не представляется возможным,&amp;nbsp;поскольку:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;эксплуатация уязвимости возможна только в том случае, если декодированный параметр запроса &lt;code&gt;condition&lt;/code&gt; будет содержать подстроку &amp;#8220;secret&amp;#8221; (строка 12), но множество значений такого параметра весьма велико, а выразить его через регулярные выражения затруднительно из-за нерегулярных функций&amp;nbsp;декодирования;&lt;/li&gt;
&lt;li&gt;параметр запроса, являющийся вектором атаки, также подвергается декодированию (строка 14), что не позволяет средству &lt;span class="caps"&gt;SAST&lt;/span&gt; сформировать для &lt;span class="caps"&gt;WAF&lt;/span&gt; множество его опасных&amp;nbsp;элементов.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Поскольку все проблемы традиционного &lt;span class="caps"&gt;VP&lt;/span&gt; растут из отсутствия возможности работать с приложением на уровне &lt;span class="caps"&gt;WAF&lt;/span&gt; по модели белого ящика, очевидно, что для их устранения необходимо реализовать такую возможность и доработать подход таким образом,&amp;nbsp;чтобы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;средство &lt;span class="caps"&gt;SAST&lt;/span&gt; предоставляло &lt;span class="caps"&gt;WAF&lt;/span&gt; полную информацию обо всех преобразованиях, которым подвергаются уязвимый параметр и переменные условий успешной атаки на пути от точки входа до уязвимой точки, чтобы &lt;span class="caps"&gt;WAF&lt;/span&gt; получил возможность вычислять значения аргументов в ней, исходя из значений параметров обрабатываемого &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса;&lt;/li&gt;
&lt;li&gt;для детектирования атаки использовались не эвристические, а формальные методы, основанные на строгом доказательстве тех или иных утверждений и покрывающие общий случай условий эксплуатации каждой конкретной уязвимости — вместо ограниченного множества&amp;nbsp;частных.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Так и родилась технология виртуального патчинга времени&amp;nbsp;выполнения.&lt;/p&gt;
&lt;h2&gt;Runtime virtual&amp;nbsp;patching&lt;/h2&gt;
&lt;p&gt;В основе технологии runtime virtual patching (&lt;span class="caps"&gt;RVP&lt;/span&gt;) лежит используемая в анализаторе исходных кодов &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector (&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;) модель исследуемого приложения под названием «граф потоков вычисления» (computation flow graph, CompFG). Эта модель была подробно описана в рамках мастер-класса &lt;a href="https://www.youtube.com/watch?v=apQEQQm6GaE&amp;amp;feature=youtu.be"&gt;«Трущобы AppSec»&lt;/a&gt; на PHDays &lt;span class="caps"&gt;VII&lt;/span&gt;. CompFG строится во время анализа приложения в результате абстрактной интерпретации его кода в семантике, схожей с традиционными символическими вычислениями. Вершины данного графа содержат генерирующие формулы на целевом языке, задающие множества допустимых значений всех потоков данных, присутствующих в соответствующих точках выполнения. Эти потоки называются аргументами точки выполнения.  Например, вершина уязвимой точки выполнения рассмотренного выше примера в CompFG выглядит&amp;nbsp;так:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/compfg-example.png"&gt;&lt;img alt="Пример CompFG" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/compfg-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Одним из свойств CompFG является его конкретизируемость — возможность вычислить множества конкретных значений всех аргументов в любой точке выполнения приложения, задав значения для всех входных&amp;nbsp;параметров. &lt;/p&gt;
&lt;p&gt;Рабочий процесс &lt;span class="caps"&gt;RVP&lt;/span&gt; делится на два этапа, соответствующих этапам жизненного цикла приложения — развертывание (шаги D) и выполнение (шаги&amp;nbsp;R):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/rvp-workflow.png"&gt;&lt;img alt="Рабочий процесс RVP" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/rvp-workflow.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Этап&amp;nbsp;развертывания&lt;/h3&gt;
&lt;p&gt;Перед развертыванием очередной версии приложения осуществляется его анализ с помощью &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;, в результате которого из каждой вершины CompFG, описывающей уязвимую точку выполнения, выводятся три&amp;nbsp;формулы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;условие достижимости самой&amp;nbsp;точки;&lt;/li&gt;
&lt;li&gt;условие достижимости значений всех ее&amp;nbsp;аргументов;&lt;/li&gt;
&lt;li&gt;множества значений всех ее аргументов и грамматик, которым они&amp;nbsp;соответствуют.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все наборы формул группируются по признаку принадлежности уязвимости к потоку управления той или иной точки входа в веб-приложение. Само понятие точки входа специфично для каждого из поддерживаемых &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; веб-фреймворков и определено в базе знаний&amp;nbsp;анализатора. &lt;/p&gt;
&lt;p&gt;После этого отчет c обнаруженными уязвимостями и относящимися к ним формулами выгружается в виде кода на специальном языке предметной области, основанном на синтаксисе S-выражений и позволяющем описывать формулы CompFG в форме, не зависящей от целевого языка. Формула значения аргумента уязвимой точки рассмотренного ранее примера кода выглядит следующим&amp;nbsp;образом:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(+ ("Parameter value is ``") (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (param))))) ("``"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;а формула условия ее&amp;nbsp;достижимости:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Contains (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (condition))))) ("secret"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Полученный отчет загружается в &lt;span class="caps"&gt;PT&lt;/span&gt; Application Firewall (&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt;), и на его основе генерируется бинарный модуль, позволяющий вычислять все присутствующие в нем формулы. Декомпилированный код расчета условия достижимости уязвимой точки рассмотренного примера выглядит&amp;nbsp;так: &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/evaluator-example.png"&gt;&lt;img alt="Пример вычислителя" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/evaluator-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Для того, чтобы вычисление формул было возможным, на стороне &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt; необходимо иметь (на&amp;nbsp;выбор):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;некоторую базу вычислителей всех функций, которые могут появиться в&amp;nbsp;отчете;&lt;/li&gt;
&lt;li&gt;изолированную песочницу со средой выполнения для языка или платформы, на которой работает защищаемое приложение (&lt;span class="caps"&gt;CLR&lt;/span&gt;, &lt;span class="caps"&gt;JVM&lt;/span&gt;, интерпретатор &lt;span class="caps"&gt;PHP&lt;/span&gt;, Python или Ruby и т.п.), и библиотеками, которые используются в&amp;nbsp;приложении.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Первый вариант дает максимальное быстродействие, но предполагает огромный объем ручной работы со стороны разработчиков &lt;span class="caps"&gt;WAF&lt;/span&gt; по описанию вычислителей (даже если ограничиваться только функциями стандартных библиотек). Второй вариант дает возможность вычислять все функции, которые могут встретиться в отчете, но и увеличивает время обработки каждого &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса из-за необходимости вызова среды выполнения для вычисления каждой функции. Оптимальным здесь является вариант, при котором для наиболее часто встречающихся функций используется первый вариант, а все остальные вычисляются с помощью&amp;nbsp;второго.&lt;/p&gt;
&lt;p&gt;Вполне возможна ситуация, когда в формуле встретится функция, в которую анализатор не сможет «провалиться» (например, вызов метода, относящегося к отсутствующей зависимости проекта или к native-коду) и (или) вычисление которой также невозможно на стороне &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt; (например, функция чтения данных из внешних источников или окружения сервера). Такие функции отмечаются в формулах флагом unknown и обрабатываются особым образом (см.&amp;nbsp;ниже).&lt;/p&gt;
&lt;h3&gt;Этап&amp;nbsp;эксплуатации&lt;/h3&gt;
&lt;p&gt;На этапе эксплуатации при каждом &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросе &lt;span class="caps"&gt;WAF&lt;/span&gt; делегирует его обработку сгенерированному бинарному модулю. Модуль анализирует запрос и определяет относящуюся к нему точку входа в веб-приложение. Для этой точки выбираются формулы всех обнаруженных в результате ее анализа уязвимостей — и далее вычисляются определенным&amp;nbsp;образом.&lt;/p&gt;
&lt;p&gt;Сначала вычисляются формулы обоих условий: достижимости уязвимой точки и значений всех ее аргументов. Вместо переменных в каждую формулу подставляются значения соответствующих параметров запроса, после чего вычисляется ее значение. Если в формуле присутствуют выражения с флагом unknown, она обрабатывается следующим&amp;nbsp;образом:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;каждый флаг unknown распространяется по дереву выражений формулы снизу вверх до тех пор, пока им не будет отмечено какое-либо булево&amp;nbsp;выражение;&lt;/li&gt;
&lt;li&gt;все такие выражения (unknown-области) заменяются в формуле на булевы переменные и для полученной формулы решается задача булевой&amp;nbsp;выполнимости;&lt;/li&gt;
&lt;li&gt;из исходной формулы условия конструируются n условий — путем подстановки возможных значений unknown-областей из всех найденных на предыдущем шаге&amp;nbsp;решений;&lt;/li&gt;
&lt;li&gt;вычисляется значение каждой из полученных формул, и если хотя бы одна из них оказалась выполнима, то исходное условие также считается&amp;nbsp;выполнимым.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если в результате вычисления было получено ложное значение исходной формулы, то это значит, что данный &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запрос не может привести приложение в уязвимую точку с опасными значениями всех ее аргументов. В этом случае &lt;span class="caps"&gt;RVP&lt;/span&gt; просто возвращает обработку запроса основному модулю &lt;span class="caps"&gt;WAF&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;В случае выполнимости условий атаки на уязвимость наступает очередь вычисления значения аргумента уязвимой точки. Используемый для этого алгоритм зависит от класса уязвимости, к которому относится обрабатываемая точка. Общей для них является только логика обработки формул, содержащих unknown-ноды: в отличие от формул условий, такие формулы аргументов не могут быть вычислены каким-либо образом, о чем сразу сообщается &lt;span class="caps"&gt;WAF&lt;/span&gt; — и затем осуществляется переход к вычислению следующей уязвимой точки. В качестве примера рассмотрим наиболее сложный из алгоритмов, используемый для детектирования атак класса&amp;nbsp;инъекций.&lt;/p&gt;
&lt;h3&gt;Детектирование&amp;nbsp;инъекций&lt;/h3&gt;
&lt;p&gt;К классу инъекций относятся любые атаки, целью которых является нарушение целостности текста на каком-либо формальном языке (&lt;span class="caps"&gt;HTML&lt;/span&gt;, &lt;span class="caps"&gt;XML&lt;/span&gt;, JavaScript, &lt;span class="caps"&gt;SQL&lt;/span&gt;, &lt;span class="caps"&gt;URL&lt;/span&gt;, файловые пути и т. п.), формируемого на основе данных, контролируемых атакующим. Атака осуществляется через передачу приложению специально сформированных входных данных, подстановка которых в атакуемый текст приведет к выходу за пределы токена и внедрению в текст синтаксических конструкций, не предусмотренных логикой&amp;nbsp;приложения.&lt;/p&gt;
&lt;p&gt;В том случае, если текущая уязвимая точка приложения относится к данному классу атак, значение ее аргумента рассчитывается по алгоритму так называемого инкрементального вычисления с абстрактной интерпретацией в семантике taint-анализа. Суть данного алгоритма заключается в том, что каждое выражение формулы рассчитывается отдельно, снизу вверх, причем результат вычисления, полученный на каждом шаге, дополнительно размечается границами «загрязненности», исходя из семантики каждой вычисленной функции и правил &lt;a href="https://en.wikipedia.org/wiki/Taint_checking"&gt;традиционного taint-анализа&lt;/a&gt;. Это позволяет выделить в конечном результате вычисления все фрагменты, которые были получены в результате каких-либо преобразований входных данных&amp;nbsp;(tainted-фрагменты).&lt;/p&gt;
&lt;p&gt;Например, для приведенного выше кода и &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса с параметрами &lt;code&gt;condition=YzJWamNtVjA%3d&lt;/code&gt; и &lt;code&gt;param=UEhOamNtbHdkRDVoYkdWeWRDZ3hLVHd2YzJOeWFYQjBQZyUzRCUzRA%3d%3d&lt;/code&gt; результат применения этого алгоритма для формулы аргумента уязвимой точки будет выглядеть следующим образом (красным отмечены&amp;nbsp;tainted-фрагменты):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/incremental-evaluation-exampe.png"&gt;&lt;img alt="Пример инрементального вычисления" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/incremental-evaluation-exampe.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Далее полученное значение разбивается на токены в соответствии с грамматикой аргумента уязвимой точки, и если на любой из tainted-фрагментов пришлось более одного токена, то это и является формальным признаком детектированной атаки (по определению&amp;nbsp;инъекции):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/tokenization-example.png"&gt;&lt;img alt="Пример токенизации" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/tokenization-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;По окончании вычисления формул всех уязвимостей, относящихся к текущей точке входа, обработка запроса передается в основной модуль &lt;span class="caps"&gt;WAF&lt;/span&gt; вместе с результатами&amp;nbsp;детектирования.&lt;/p&gt;
&lt;h3&gt;Преимущества и особенности &lt;span class="caps"&gt;RVP&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Реализованный таким образом подход к защите приложения на основе результатов анализа защищенности его кода обладает рядом существенных преимуществ по сравнению с традиционным &lt;span class="caps"&gt;VP&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;за счет описанного выше формального подхода и возможности учитывать любые промежуточные преобразования выходных данных устранены все указанные недостатки традиционного &lt;span class="caps"&gt;VP&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;формальный подход также полностью исключает возможность появления ошибок первого рода (ложных срабатываний, false positive), при условии отсутствия в формулах&amp;nbsp;unknown-нод;&lt;/li&gt;
&lt;li&gt;отсутствие какого-либо негативного влияния на функции веб-приложения, поскольку защита реализуется не просто в соответствии с ними, а на их же&amp;nbsp;основе.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для обкатки технологии и подтверждения ее эффективности был разработан прототип модуля интеграции &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector и &lt;span class="caps"&gt;PT&lt;/span&gt; Application Firewall в виде &lt;span class="caps"&gt;HTTP&lt;/span&gt;-модуля веб-сервера &lt;span class="caps"&gt;IIS&lt;/span&gt; под платформу .&lt;span class="caps"&gt;NET&lt;/span&gt;. Демонстрацию его работы с рассмотренным примером кода можно посмотреть на &lt;a href="https://www.youtube.com/watch?v=U1NbKuZkb8c"&gt;YouTube&lt;/a&gt;. Тесты производительности на полутора десятках открытых &lt;span class="caps"&gt;CMS&lt;/span&gt; показали более чем приемлемые результаты: время обработки &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов с помощью &lt;span class="caps"&gt;RVP&lt;/span&gt; оказалось сравнимо со временем их обработки традиционными (эвристическими) методами &lt;span class="caps"&gt;WAF&lt;/span&gt;. Средний процент замедления реакции веб-приложения на запросы&amp;nbsp;составил:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0% при обработке запросов, не приводящих в уязвимую&amp;nbsp;точку;&lt;/li&gt;
&lt;li&gt;6–10% при обработке запросов, приводящих в уязвимую точку, но не являющихся атакой (в зависимости от сложности грамматики уязвимой&amp;nbsp;точки);&lt;/li&gt;
&lt;li&gt;4–7% при обработке запросов, приводящих в уязвимую точку и являющихся&amp;nbsp;атакой.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Несмотря на очевидные преимущества перед традиционным &lt;span class="caps"&gt;VP&lt;/span&gt;, &lt;span class="caps"&gt;RVP&lt;/span&gt; все же обладает рядом концептуальных ограничений, от которых хотелось бы&amp;nbsp;избавиться:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;отсутствует возможность вычислять значения таких формул, в которых присутствуют внешние данные из источников, отсутствующих на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; (файловых ресурсов, БД, окружение сервера и т.&amp;nbsp;п.);&lt;/li&gt;
&lt;li&gt;качество формул напрямую зависит от качества аппроксимации некоторых фрагментов кода во время его анализа (циклы, рекурсия, вызовы методов внешних библиотек и т.&amp;nbsp;п.);&lt;/li&gt;
&lt;li&gt;описание семантики преобразующих функций для базы вычислителей требует некоторого количества инженерной работы, которая слабо автоматизируется и допускает появление ошибок, связанных с человеческим&amp;nbsp;фактором.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Впрочем, и эти недостатки оказалось возможным устранить, перенеся часть функциональности &lt;span class="caps"&gt;RVP&lt;/span&gt; на сторону приложения и применив технологии, лежащие в основе самозащиты приложений времени выполнения (runtime application self-protection, &lt;span class="caps"&gt;RASP&lt;/span&gt;).&lt;/p&gt;
&lt;h2&gt;Advanced &lt;span class="caps"&gt;RASP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;По сути, подход &lt;span class="caps"&gt;ARASP&lt;/span&gt; подразумевает применение самого приложения для вычисления тех фрагментов формулы, которые невозможно вычислить при помощи &lt;span class="caps"&gt;RVP&lt;/span&gt;. Для интеграции в веб-приложение сенсоров детектирования, при помощи которых можно получить значения любых фрагментов формул, вычисляемых &lt;span class="caps"&gt;RVP&lt;/span&gt;, на стороне приложения используется дополнительный модуль&amp;nbsp;инструментирования.&lt;/p&gt;
&lt;p&gt;Процесс &lt;span class="caps"&gt;ARASP&lt;/span&gt; представляет собой рассмотренный выше процесс &lt;span class="caps"&gt;RVP&lt;/span&gt; со следующими&amp;nbsp;дополнениями:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;В выгруженном из &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; отчете каждое выражение в формуле имеет дополнительный атрибут — его координаты в&amp;nbsp;коде:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;36&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;FromBase64Str&lt;/span&gt;   
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;35&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UrlDecodeStr&lt;/span&gt; 
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;32&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;FromBase64Str&lt;/span&gt;   
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;31&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;GetParameterData&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;При помощи данного отчета генерируется не только модуль вычисления формул, но и модуль инструментирования, который выполняется на стороне приложения. Этот модуль встраивает сенсоры детектирования во все точки выполнения приложения, которые соответствуют неопределенным выражениям в отчете, а также устанавливает точки останова, которые перед переходом к уязвимой точке выполнения передают управление &lt;span class="caps"&gt;RVP&lt;/span&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/instrumented-code.png"&gt;&lt;img alt="Инструментированный код" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/instrumented-code.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="caps"&gt;RVP&lt;/span&gt; не принимает на себя управление при обработке &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов: приложению дается возможность обработать запрос до точки останова, стоящей перед уязвимой точкой выполнения (при достижении этой точки &lt;span class="caps"&gt;RVP&lt;/span&gt; уже соберет информацию со всех сенсоров детектирования, активированных до этой&amp;nbsp;точки).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;При достижении точки останова обработка &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса передается &lt;span class="caps"&gt;RVP&lt;/span&gt;, и формулы рассчитываются способом, описанным в предыдущем разделе, с одним существенным отличием: если в формуле содержится неопределенное выражение или выражение, которое невозможно вычислить при помощи &lt;span class="caps"&gt;RVP&lt;/span&gt; (по причине ссылок на внешние источники данных или отсутствия необходимой преобразующей функции в базе знаний), тогда значение выражения берется из информации, которая была собрана после активации сенсоров&amp;nbsp;детектирования.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;При обнаружении атаки обработка запроса прекращается (и, следовательно, приложение не доходит до уязвимой точки&amp;nbsp;выполнения).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;При отсутствии атаки задача по обработке запроса возвращается приложению до момента достижения следующей точки останова или до тех пор, пока не завершится обработка&amp;nbsp;запроса.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Этот подход значительно расширяет возможности технологии &lt;span class="caps"&gt;RVP&lt;/span&gt;, устраняя ее недостатки в плане качества защиты&amp;nbsp;приложений.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/arasp-workflow.png"&gt;&lt;img alt="Рабочий процесс ARASP" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/arasp-workflow.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Преимущества &lt;span class="caps"&gt;ARASP&lt;/span&gt;: больше чем просто виртуальный&amp;nbsp;патчинг&lt;/h3&gt;
&lt;p&gt;В &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; можно настроить экспорт формул для всех потенциально уязвимых точек выполнения без выявления в них уязвимостей, что обеспечит полное покрытие всех опасных фрагментов кода приложения. Именно эта функция делает &lt;span class="caps"&gt;ARASP&lt;/span&gt; комплексным решением по защите приложений. В этом &lt;span class="caps"&gt;WAF&lt;/span&gt; нового поколения применяется модель белого ящика и используются формальные методы вместо эвристических. По сравнению с традиционным подходом &lt;span class="caps"&gt;RASP&lt;/span&gt; у этого решения есть несколько&amp;nbsp;преимуществ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;незначительное снижение производительности (обработка запроса фрагментами приложения происходит параллельно с обработкой этого же запроса модулем &lt;span class="caps"&gt;WAF&lt;/span&gt; с работающим &lt;span class="caps"&gt;ARASP&lt;/span&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;минимальный урон стабильности приложения (инструментирование применяется только для тех точек исполнения, которые действительно необходимы для вычисления&amp;nbsp;формул);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;точное (практически 100%) обнаружение атак благодаря использованию методов модели CompFG и формальных методов для работы на этих&amp;nbsp;элементах.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Таким образом, &lt;span class="caps"&gt;RVP&lt;/span&gt; и &lt;span class="caps"&gt;ARASP&lt;/span&gt; являются многообещающим перспективным решением в обеспечении защиты приложений, и мы продолжим разрабатывать их в качестве основного вектора улучшения интеграции между &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector и &lt;span class="caps"&gt;PT&lt;/span&gt; Application&amp;nbsp;Firewall.&lt;/p&gt;</content><category term="Блог"></category><category term="SAST"></category><category term="static code analysis"></category><category term="Application Inspector"></category><category term="WAF"></category><category term="Application Firewall"></category></entry><entry><title>Материалы вебинара “Подводные камни прикладной криптографии I”</title><link href="https://kochetkov.github.io/webinar-applied-cryptography-pitfalls-1.html" rel="alternate"></link><published>2016-10-07T12:00:00+03:00</published><updated>2016-10-07T12:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-10-07:/webinar-applied-cryptography-pitfalls-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о генерации криптографических случайных чисел в различных языках (включая многострадальный &lt;span class="caps"&gt;PHP&lt;/span&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;неплохая &lt;a href="https://jazzy.id.au/tags/prng.html"&gt;серия статей&lt;/a&gt; о техниках взлома различных &lt;span class="caps"&gt;PRNG&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks"&gt;описание&lt;/a&gt; атаки удлинения&amp;nbsp;сообщения;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth"&gt;описание&lt;/a&gt; атаки на оракул&amp;nbsp;дополнения.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S: Было бы совсем здорово, если бы участники вебинара не поленились черкнуть пару слов о том, что им (не) понравилось и какие темы были бы им интересны в следующей части&amp;nbsp;вебинара.&lt;/p&gt;</content><category term="Блог"></category><category term="вебинары"></category><category term="криптография"></category></entry><entry><title>Ищем уязвимости в коде: теория, практика и перспективы SAST</title><link href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html" rel="alternate"></link><published>2016-07-08T04:00:00+03:00</published><updated>2016-07-08T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-07-08:/sast-theory-practice-and-prospects.html</id><summary type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;
&lt;h2&gt;Тьюринг, Райс - вот эти вот&amp;nbsp;все&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;/&lt;span class="caps"&gt;DR&lt;/span&gt;: задача статического тестирования защищенности программ алгоритмически&amp;nbsp;неразрешима.&lt;/p&gt;
&lt;p&gt;Представьте себе множество полностью абстрактных программ P, которые только и умеют, что зависать на одних наборах входных данных и останавливаться через некоторое число операций на других. Очевидно, что класс P охватывает любые теоретически возможные программы, поскольку это свойство можно приписать любой из&amp;nbsp;них. &lt;/p&gt;
&lt;p&gt;Теперь представьте, что одна из таких программ (назовем ее h) является анализатором, умеющим отвечать на простой вопрос: зависает ли произвольная программа p из множества P на заданном наборе данных n? Очевидно, что отвечать на этот вопрос h сможет только завершая свою работу и тем самым сообщая, что p зависает на n. Иными словами, если p(n) не останавливается, то h(p(n)) должна завершить свою работу за конечное число шагов, а если p(n) останавливается, то h(p(n)) должна&amp;nbsp;зависнуть. &lt;/p&gt;
&lt;p&gt;Ну, а теперь представьте, что произойдет, если мы попробуем ответить с помощью такого анализатора на вопрос: зависнет ли он сам, в результате анализа самого себя, анализирующего самого себя (ведь p может быть любой программой из P, значит она может быть и самой h)? В этом случае получается, что если h(h(n)) остановится, то анализ h(n) зависает, а если h(h(n))) зависает, то анализ h(n) останавливается. Но ведь h как раз и есть h(n), а, следовательно, мы здесь имеем противоречие и анализатор подобный h не имеет права на&amp;nbsp;существование.&lt;/p&gt;
&lt;p&gt;Описанное является вольным изложением доказательства Теоремы останова, сформулированной Алланом Тьюрингом (основоположником современной теоретической информатики) в далеком 1936-м. Данная теорема утверждает, что не существует такой программы, которая могла бы проанализировать другую программу и ответить на вопрос, остановится ли та на заданном наборе входных данных. Хорошо, но можем ли мы построить такую программу, которая дает ответ на вопрос о каких-либо других свойствах&amp;nbsp;программ?&lt;/p&gt;
&lt;p&gt;Поскольку множество P включает в себя все возможные программы, мы всегда можем разбить его на два класса (пусть будут A и B) по признаку наличия у программ любого нетривиального инвариантного свойства. Под нетривиальным инвариантным свойством подразумевается такое свойство, которым любая программа множества P либо обладает, либо не обладает и при этом все функционально тождественные программы (дающие одни и те же наборы данных на выходе при одинаковых наборах данных на входе) либо все вместе обладают этим свойством, либо все вместе не&amp;nbsp;обладают.&lt;/p&gt;
&lt;p&gt;Давайте представим, что есть некоторый анализатор q, который принимает на вход произвольную программу p множества P и останавливается, если p относится к одному из классов. Пусть, для определенности, это будет класс A. Пусть pa - программа, относящаяся к классу A и зацикливающаяся на любом входе. Выберем также из класса B произвольную программу pb. Для каждой программы p определим программу p&amp;#8217;, получающую на вход данные x и выполняющую следующий&amp;nbsp;алгоритм:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p(p)&lt;/li&gt;
&lt;li&gt;pb(x)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Теперь построим программу q&amp;#8217;, которая получает на вход произвольную программу p, строит для нее p&amp;#8217; и вычисляет&amp;nbsp;q(p&amp;#8217;). &lt;/p&gt;
&lt;p&gt;Если p&amp;#8217; зависает на первом шаге, значит p&amp;#8217; функционально тождественна pa (и относится к классу A), а, следовательно, q&amp;#8217; должна немедленно остановиться. Если p&amp;#8217; проходит первый шаг, то p&amp;#8217; функционально тождественна pb (и относится к классу B), а, следовательно, q&amp;#8217; должна зависнуть. Таким образом, для любой программы p, q&amp;#8217;(p) останавливается тогда, когда p(p) не останавливается. Но в роли p может оказаться и сама q&amp;#8217;, следовательно, p(p) останавливается только тогда, когда p(p) не останавливается. Снова пришли к&amp;nbsp;противоречию. &lt;/p&gt;
&lt;p&gt;Утверждение о том, что не существует такой программы, которая могла бы давать ответ на вопрос о наличии любых нетривиальных инвариантных свойств у произвольно взятой программы, доказал ученый Генри Райс в 1953 году. Фактически, его работа обобщает Теорему останова, поскольку свойство останавливаться на заданном наборе данных является нетривиальным и инвариантным. Теорема Райса имеет бесконечное множество практических значений, в зависимости от рассматриваемых свойств: «невозможно с помощью программы классифицировать алгоритм, реализуемый другой программой», «невозможно с помощью программы доказать, что две других программы реализуют один и тот же алгоритм», «невозможно с помощью программы доказать, что другая программа на любых наборах данных не входит в какие-либо состояния…» и т.п. И вот на последнем примере стоит остановиться&amp;nbsp;подробнее.&lt;/p&gt;
&lt;p&gt;В момент выполнения любого (как абстрактного, так и реального) алгоритма некоей универсальной выполняющей программой (например, виртуальной машиной, эмулирующей полноценный компьютер с установленной ОС), можно взять снимок этой машины, включая состояние самой выполняемой программы в адресном пространстве машины и ее внешнего окружения, такого, как дисковые накопители, состояние внешних устройств и т.п. и позднее, восстановив его, продолжить выполнение программы с того же самого места. По сути, весь процесс выполнения любой программы, представляет собой череду сменяющихся состояний, последовательность которых как раз и определяется ее кодом. При этом, в случае наличия каких-либо ошибок в конфигурации или реализации, как самой программы, так и выполняющей ее машины, велика вероятность того, что процесс выполнения войдет в состояние, которое изначально не предполагалось&amp;nbsp;разработчиками.&lt;/p&gt;
&lt;p&gt;А что есть уязвимость? Это возможность с помощью входных данных заставить процесс выполнения войти в такое состояние, которое приведет к реализации какой-либо из угроз в отношении обрабатываемой процессом информации. Следовательно, можно определить свойство защищенности любой программы, как ее способность в каждый момент времени оставаться, вне зависимости от изначальных входных данных, в рамках заранее определенного множества допустимых состояний, определяющего политику ее безопасности. При этом, задача анализа защищенности программы очевидно сводится к анализу невозможности ее перехода в любое неразрешенное политикой безопасности состояние на произвольном наборе входных данных. То есть, к той самой задаче, алгоритмическая неразрешимость которой была давным-давно доказана Генри&amp;nbsp;Райсом.&lt;/p&gt;
&lt;p&gt;Так получается, что же… весь рынок инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt; – это индустрия обмана? В теории – да, на практике же, всё как обычно - возможны&amp;nbsp;варианты.&lt;/p&gt;
&lt;h2&gt;Теория &lt;span class="caps"&gt;SAST&lt;/span&gt; на&amp;nbsp;практике&lt;/h2&gt;
&lt;p&gt;Даже оставаясь в теоретическом поле, вполне возможно сделать несколько послаблений утверждению Райса для реальных программ, выполняющихся в реальных средах. Во-первых, в теоретической информатике под «программой» подразумевается математическая абстракция, эквивалентная машине Тьюринга (МТ) – самому мощному из вычислительных автоматов. Однако же, в реальных программах далеко не каждый фрагмент их кода эквивалентен МТ. Ниже по иерархии вычислительной мощности находятся линейно-ограниченные, стековые и конечные автоматы. Анализ защищенности двух последних вполне возможен, даже в рамках самой теоретической&amp;nbsp;теории.&lt;/p&gt;
&lt;p&gt;Во-вторых, отличительной особенностью МТ является то, что ей доступна память бесконечного размера. Именно из этой особенности вытекает невозможность получить все возможные состояния вычислительного процесса – их попросту бесконечное число. Однако, в реальных компьютерах память далеко не бесконечна. Что еще важнее, в реальных программах число состояний, представляющих интерес с точки зрения задачи анализа защищенности, также конечно (хотя и неприлично&amp;nbsp;велико).&lt;/p&gt;
&lt;p&gt;В-третьих, вычисление свойств программы по Райсу, является разрешимой проблемой для ряда малых МТ, имеющих небольшое количество состояний и возможных переходов между ними. Сложно себе представить реальную программу, имеющую от 2 до 4 состояний. Однако, такой &lt;em&gt;фрагмент&lt;/em&gt; программы представить себе гораздо&amp;nbsp;легче.&lt;/p&gt;
&lt;p&gt;Следовательно, возможен эффективный анализ отдельных фрагментов кода программы, попадающих под перечисленных критерии. На практике, это означает,&amp;nbsp;что:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;фрагмент кода без циклов и рекурсии может быть всесторонне проанализирован, т.к. эквивалентен конечному&amp;nbsp;автомату;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;фрагмент с циклами или рекурсией, условие выхода из которых не зависит от входных данных, поддается анализу в качестве конечного или стекового&amp;nbsp;автомата;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;если условия выхода из цикла или рекурсии зависят от входных данных, длина которых ограничена некоторым разумным порогом, то такой фрагмент в отдельных случаях получится проанализировать как систему линейно-ограниченных автоматов или малых&amp;nbsp;МТ.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;А вот все остальное – увы и ах − статическим подходом проанализировать не удастся. Более того, разработка анализатора защищённости исходного кода - это такое направление, работая в котором инженеры ежедневно сталкиваются с трейдофом &lt;span class="caps"&gt;EXPSPACE&lt;/span&gt; &amp;lt;-&amp;gt; &lt;span class="caps"&gt;EXPTIME&lt;/span&gt;, а сводя даже частные случаи к субэкспоненте, радуются как дети, потому что это по-настоящему круто. Подумайте над тем, какова будет мощность множества значений переменной parm1 в последней точке&amp;nbsp;выполнения?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Вот поэтому о теоретических ограничениях можно не особо беспокоиться, поскольку упереться в них на текущих вычислительных мощностях будет крайне затруднительно. Однако же, перечисленные послабления этих ограничений задают правильное направление развития современных статических анализаторов, поэтому иметь в виду их все же&amp;nbsp;стоит.   &lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAST&lt;/span&gt;, &lt;span class="caps"&gt;IAST&lt;/span&gt; и&amp;nbsp;все-все-все&lt;/h2&gt;
&lt;p&gt;В противовес статическому подходу, работающему с кодом программы без его фактического выполнения, динамический (Dynamic Application Security Testing, &lt;span class="caps"&gt;DAST&lt;/span&gt;) подразумевает наличие развернутой среды выполнения приложения и ее прогон на наиболее интересных с точки зрения анализа наборах входных данных. Упрощая, его можно охарактеризовать, как метод «осознанного научного тыка» («давайте передадим программе вот такие данные, характерные вот для такой атаки и посмотрим, что же из этого выйдет»). Его недостатки очевидны: далеко не всегда есть возможность быстро развернуть анализируемую систему (а зачастую и просто собрать), переход системы в какое-либо состояние может быть следствием обработки предыдущих наборов данных, да и для всестороннего анализа поведения реальной системы количество наборов входных данных должно быть настолько велико, что о его конечности можно рассуждать исключительно&amp;nbsp;теоретически.&lt;/p&gt;
&lt;p&gt;Относительно недавно перспективным считался подход, комбинирующий преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt; – интерактивный анализ (Interactive…, &lt;span class="caps"&gt;IAST&lt;/span&gt;). Отличительной особенностью этого подхода является то, что &lt;span class="caps"&gt;SAST&lt;/span&gt; используется для формирования наборов входных данных и шаблонов ожидаемых результатов, а &lt;span class="caps"&gt;DAST&lt;/span&gt; выполняет тестирование системы на этих наборах, опционально привлекая к процессу человека-оператора в неоднозначных ситуациях. Ирония этого подхода заключается в том, что он вобрал в себя как преимущества, так и недостатки &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, что не могло не сказаться на его практической&amp;nbsp;применимости.&lt;/p&gt;
&lt;p&gt;Но кто сказал, что в случае динамического анализа нужно выполнять всю программу целиком? Как было показано выше, вполне реально проанализировать значительную часть кода с помощью статического подхода. Что же мешает проанализировать с помощью динамического только оставшиеся фрагменты? Звучит, как&amp;nbsp;план…&lt;/p&gt;
&lt;h2&gt;А внутре у ней&amp;nbsp;неонка&lt;/h2&gt;
&lt;p&gt;Существует несколько традиционных подходов к статическому анализу, отличающихся моделью, на основе которой анализатор выводит те или иные свойства исследуемого кода. Самым примитивным и очевидным является сигнатурный поиск, основанный на поиске вхождений какого-либо шаблона в синтаксическую модель представления кода (как правило, это либо поток токенов, либо абстрактное синтаксическое дерево). Отдельные реализации этого подхода используют чуть более сложные модели (семантическое дерево, его отображение на граф отдельных потоков данных и т.п.), но в целом этот подход можно рассматривать исключительно в качестве вспомогательного, позволяющего за линейное время выделить в коде подозрительные места для последующей ручной верификации. Подробнее останавливаться на нём не будем, интересующиеся могут обратиться к посвященной ему &lt;a href="https://habrahabr.ru/company/pt/blog/300946/"&gt;серии статей&lt;/a&gt; Ивана&amp;nbsp;Кочуркина.&lt;/p&gt;
&lt;p&gt;Более сложные подходы оперируют уже моделями выполнения (а не представления или семантики) кода. Такие модели, как правило, позволяют получить ответ на вопрос &amp;#8220;может ли контролируемый извне поток данных достичь какой-либо точки выполнения, в которой это приведет к возникновению уязвимости?&amp;#8221;. В большинстве случаев, модель здесь представляет собой вариацию на тему графов &lt;a href="https://en.wikipedia.org/wiki/Control_flow_graph"&gt;потока выполнения&lt;/a&gt; и &lt;a href="https://en.wikipedia.org/wiki/Data_flow_diagram"&gt;потоков данных&lt;/a&gt;, либо их комбинацию (например, &lt;a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf"&gt;граф свойств кода&lt;/a&gt;). Недостаток подобных подходов также очевиден - в любом нетривиальном коде одного только ответа на этот вопрос недостаточно для успешного детектирования уязвимости. Например, для&amp;nbsp;фрагмента:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filteredParam&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;такой анализатор выведет из построенной модели утвердительный ответ о достижимости потоком данных &lt;code&gt;Request.Params["param"]&lt;/code&gt; точки выполнения &lt;code&gt;Response.Write(filteredParam)&lt;/code&gt; и существовании в данной точке уязвимости к &lt;span class="caps"&gt;XSS&lt;/span&gt;. В то время, как на самом деле, данный поток эффективно фильтруется и не может являться носителем вектора атаки. Существует множество способов покрыть частные случаи, связанные с предварительной обработкой потоков данных, но все они в конечном итоге сводятся к разумному балансу между ложными срабатываниями первого и второго&amp;nbsp;типа.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Type 1 &amp;amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Каким образом можно минимизировать появление ошибок обоих типов? Для этого необходимо учитывать условия достижимости как потенциально уязвимых точек выполнения, так и множеств значений потоков данных, приходящих в такие точки. На основе этой информации становится возможным построить систему уравнений, множество решений которой даст все возможные наборы входных данных, необходимые для того, чтобы прийти в потенциально уязвимую точку программы. Пересечение этого множества со множеством всех возможных векторов атаки, даст множество всех наборов входных данных, приводящих программу в уязвимое состояние. Звучит отлично, но как получить модель, которая содержала бы всю необходимую&amp;nbsp;информацию?&lt;/p&gt;
&lt;h2&gt;Абстрактная интерпретация и символические&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Допустим, перед нами стоит задача определить, число с каким знаком определяет выражение &lt;code&gt;-42 / 8 * 100500&lt;/code&gt;. Самый простой способ - это вычислить данное выражение и убедиться, что получено отрицательное число. Вычисление выражения с вполне определенными значениями всех его аргументов называется конкретным вычислением. Но есть и другой способ решить эту задачу. Давайте на секунду представим, что по какой-то причине у нас нет возможности конкретно вычислить данное выражение. Например, если в него добавилась переменная &lt;code&gt;-42 / 8 * 100500 * x&lt;/code&gt;. Определим абстрактную арифметику, в которой результат операций над числами определяется исключительно правилом знака, а значения их аргументов&amp;nbsp;игнорируются:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(+a) = (+)&lt;/span&gt;
&lt;span class="err"&gt;(-a) = (-)&lt;/span&gt;
&lt;span class="err"&gt;(-) * (+) = (-)&lt;/span&gt;
&lt;span class="err"&gt;(-) / (+) = (-)  &lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;(-) + (+) = (+-)&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Интерпретируя исходное выражение в рамках данной семантики, получаем: &lt;code&gt;(-) / (+) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-)&lt;/code&gt;. Этот подход будет давать однозначный ответ на поставленную задачу до тех пор, пока в выражении не появятся операции сложения или вычитания. Давайте дополним нашу арифметику таким образом, чтобы значения аргументов операций также&amp;nbsp;учитывались:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(-a) * (+b) = (-c)&lt;/span&gt;
&lt;span class="err"&gt;(-a) / (+b) = (-c)  &lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;(-a) + (+b) = &lt;/span&gt;
&lt;span class="err"&gt;    a &amp;lt;= b -&amp;gt; (+)&lt;/span&gt;
&lt;span class="err"&gt;    a &amp;gt;  b -&amp;gt; (-)&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Интерпретируя выражение &lt;code&gt;-42 / 8 * 100500 + x&lt;/code&gt; в новой семантике получим результат &lt;code&gt;x &amp;gt;= -527625 -&amp;gt; (+), x &amp;lt; -527625 -&amp;gt; (-)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Описанный выше подход называется &lt;a href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;абстрактной интерпретацией&lt;/a&gt; и формально определяется, как устойчивая аппроксимация семантики выражений, основанная на монотонных функциях над упорядоченными множествами. Говоря более простым языком, это интерпретация выражений без их конкретного вычисления с целью сбора информации в рамках заданного семантического поля. Если мы плавно перейдем от интерпретации отдельных выражений к интерпретации кода программы на каком-либо языке, а в качестве семантического поля определим семантику самого языка, дополненную правилом оперировать всеми входными данными, как неизвестными переменными (символическими значениями), то мы получим подход, именуемый &lt;a href="https://en.wikipedia.org/wiki/Symbolic_execution"&gt;&amp;#8220;символическим выполнением&amp;#8221;&lt;/a&gt; и лежащий в основе большинства перспективных направлений статического анализа&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Именно с помощью символических вычислений становится возможным построение контекстного графа символического вычисления (альтернативное название: граф потока вычислений) - модели, всесторонне описывающей процесс вычисления исследуемой программы. Эта модель была рассмотрена в докладе &lt;a href="http://www.slideshare.net/kochetkov.vladimir/ss-48743308/14"&gt;&amp;#8220;Автоматическая генерация патчей для исходного кода&amp;#8221;&lt;/a&gt;, а ее применение для анализа защищенности кода - в статье &lt;a href="https://habrahabr.ru/company/pt/blog/224547/"&gt;&amp;#8220;Об анализе исходного кода и автоматической генерации эксплоитов&amp;#8221;&lt;/a&gt;. Вряд ли имеет смысл рассматривать их повторно в рамках данной статьи. Необходимо лишь отметить, что эта модель позволяет получить условия достижимости как любой точки потока выполнения, так и множеств значений всех приходящих в нее аргументов. То есть - именно то, что требуется нам для решения нашей&amp;nbsp;задачи.&lt;/p&gt;
&lt;h2&gt;Поиск уязвимостей на графе потока&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Формализовав в терминах графа потока вычислений критерии уязвимости к тому или иному классу атак, мы сможем реализовать анализ защищенности кода через разрешение свойств конкретной модели, полученной в результате абстрактной интерпретации исследуемого кода. Например, критерии уязвимости к атакам любых инъекций (SQLi, &lt;span class="caps"&gt;XSS&lt;/span&gt;, XPATHi, Path Traversal и т.п.) можно формализовать примерно&amp;nbsp;так:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Пусть C - граф потока вычисления исследуемого&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Пусть pvf(t) - достижимая вершина потока управления на C, являющаяся вызовом функции прямой или косвенной интерпретации текста t, соответствующего формальной грамматике&amp;nbsp;G.&lt;/p&gt;
&lt;p&gt;Пусть e - поток аргумента входных данных на&amp;nbsp;С. &lt;/p&gt;
&lt;p&gt;Пусть De - множество потоков данных на C, порождаемых от e и достижимых в точке вызова&amp;nbsp;pvf(t).&lt;/p&gt;
&lt;p&gt;Тогда приложение уязвимо к атакам инъекции в точке вызова pvf(t), если t принадлежит De и множество значений De включает в себя хотя бы одну пару элементов, при которых, в результате их синтаксического разбора в соответствии с грамматикой G, получаются не изоморфные друг-другу&amp;nbsp;деревья.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Аналогичным образом формализуются уязвимости и к другим классам атак. Однако, здесь необходимо заметить, что не все типы уязвимостей возможно формализовать в рамках какой-либо модели, выводимой только из анализируемого кода. В отдельных случаях может потребоваться дополнительная информация. Например, для формализации уязвимостей к атакам на бизнес-логику, необходимо иметь формализованные правила предметной области приложения, для формализации уязвимостей к атакам на контроль доступа - формализованную политику разграничения доступа и&amp;nbsp;т.п.&lt;/p&gt;
&lt;h2&gt;Идеальный сферический анализатор защищенности кода в&amp;nbsp;вакууме&lt;/h2&gt;
&lt;p&gt;Давайте теперь ненадолго отвлечемся от суровой реальности и чуть-чуть помечтаем о том, какой функциональностью должно обладать ядро гипотетического Идеального Анализатора (назовем его условно &amp;#8220;&lt;span class="caps"&gt;IA&lt;/span&gt;&amp;#8221;)?&lt;/p&gt;
&lt;p&gt;Во-первых, оно должно вбирать в себя преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, не включая при этом их недостатки. Из этого в частности следует, что &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь работать исключительно с имеющимся кодом приложения (исходным или бинарным), не требуя при этом его полноты или развертывания приложения в исполняющей среде. Иными словами, он должен поддерживать анализ проектов с отсутствующими внешними зависимостями или же какими-либо другими факторами, препятствующими сборке и развертыванию приложения. При этом, работа с фрагментами кода, имеющего ссылки на отсутствующие зависимости, должна быть реализована в настолько полной мере, насколько это возможно в каждом конкретном случае. С другой стороны, &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь эффективно &amp;#8220;уворачиваться&amp;#8221; не только от теоретических ограничений, накладываемых тьюринговой моделью вычислений, но и осуществлять сканирование за разумное время, потребляя разумное количество памяти и придерживаясь по возможности субэкспоненциальной &amp;#8220;весовой&amp;nbsp;категории&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Во-вторых, вероятность появления ошибок первого рода должна быть сведена к минимуму за счет построения и решения систем логических уравнений и генерации на выходе работающего вектора атаки, позволяющего пользователю подтвердить существование уязвимости одним&amp;nbsp;действием. &lt;/p&gt;
&lt;p&gt;В-третьих, &lt;span class="caps"&gt;IA&lt;/span&gt; должен эффективно бороться с ошибками второго рода, предоставляя пользователю возможность ручной проверки всех потенциально уязвимых точек потока выполнения, уязвимость которых сам &lt;span class="caps"&gt;IA&lt;/span&gt; не смог ни подтвердить, ни&amp;nbsp;опровергнуть.&lt;/p&gt;
&lt;p&gt;Использование модели, основанной на символических вычислениях, позволяет реализовать все эти требования, что называется &amp;#8220;by-design&amp;#8221;, за исключением той их части, которая касается теоретических ограничений и субэкспонент. И здесь, как нельзя кстати, придется наш план - использовать динамический анализ там, где не справился&amp;nbsp;статический. &lt;/p&gt;
&lt;h2&gt;Частичные вычисления, обратные функции и отложенная&amp;nbsp;интерпретация&lt;/h2&gt;
&lt;p&gt;Представьте себе, что &lt;span class="caps"&gt;IA&lt;/span&gt; содержит в себе некоторую базу знаний, описывающую семантику функций преобразования входных данных, реализованных в стандартной библиотеке языка или исполняющей среды приложения, наиболее популярных фреймворках и &lt;span class="caps"&gt;CMS&lt;/span&gt;. Например, что функции Base64Decode и Base64Encode являются взаимно-обратными, или что каждый вызов StringBuilder.Append добавляет новую строку к уже хранящейся в промежуточной переменной-аккумуляторе этого класса и т.п. Обладая такими знаниями &lt;span class="caps"&gt;IA&lt;/span&gt; будет избавлен от необходимости «проваливаться» в библиотечный код, анализ которого также попадает под все вычислительные&amp;nbsp;ограничения:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Нужное для выполнения условия значение для cond2 будет выведено солвером на основе информации базы знаний об обратных функциях &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// Значение sb.ToString будет получено в результаты эмуляции семантики StringBuilder, описанной в базе знаний библиотечных функций&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Но что делать, если в коде встречается вызов функции, не описанной в базе знаний &lt;span class="caps"&gt;IA&lt;/span&gt;? Давайте представим, что в распоряжении &lt;span class="caps"&gt;IA&lt;/span&gt; есть некая виртуальная среда-песочница, позволяющая запустить произвольный фрагмент анализируемого кода в заданном контексте и получить результат его выполнения. Назовём это &amp;#8220;частичным вычислением&amp;#8221;. Тогда, перед тем, как честно «провалиться» в неизвестную функцию и начинать её абстрактно интерпретировать, &lt;span class="caps"&gt;IA&lt;/span&gt; может попробовать проделать трюк, называемый «частичным фаззингом». Его общая идея заключается в предварительной подготовке базы знаний по библиотечным трансформирующим функциям и сочетаниям их последовательных вызовов на заранее известных наборах пробных данных. Имея такую базу, можно выполнить неизвестную функцию на тех же наборах данных и сравнить полученные результаты с образцами из базы знаний. Если результаты выполнения неизвестной функции совпадут с результатами выполнения известной цепочки библиотечных функций, то это будет значить, что &lt;span class="caps"&gt;IA&lt;/span&gt; теперь известна семантика неизвестной функции и в ее интерпретации нет&amp;nbsp;необходимости.&lt;/p&gt;
&lt;p&gt;Если же для какого-то фрагмента известны множества значений всех потоков данных, приходящих в этот фрагмент, а сам фрагмент не содержит опасных операций, то &lt;span class="caps"&gt;IA&lt;/span&gt; может просто выполнить его на всех возможных потоках данных и использовать полученные результаты вместо абстрактной интерпретации данного фрагмента кода. Причем этот фрагмент может относиться к любому классу вычислительной сложности и это никак не отразится на результатах его выполнения. Более того, даже если множества значений потоков данных, приходящих во фрагмент, заранее неизвестны, &lt;span class="caps"&gt;IA&lt;/span&gt; может отложить интерпретацию этого фрагмента до тех пор, пока не начнется решение уравнения для конкретной опасной операции. На этапе решения на множество значений входных данных накладывается дополнительное ограничение о наличии во входных данных векторов тех или иных атак, что может позволить предположить также и множество значений входных данных, приходящих в отложенный фрагмент и, тем самым, частично вычислить его на данном&amp;nbsp;этапе.&lt;/p&gt;
&lt;p&gt;Даже более того, на этапе решения ничего не мешает &lt;span class="caps"&gt;IA&lt;/span&gt; взять конечную формулу достижимости опасной точки и ее аргументов (которую проще всего строить в синтаксисе и семантике того же языка, на котором написан анализируемый код) и &amp;#8220;профаззить&amp;#8221; ее всеми известными значениями векторов на предмет получения их подмножества, проходящего через все фильтрующие функции&amp;nbsp;формулы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Ззначение аргумента Response.Write, проходящее через фильтрующую функцию без изменений, может быть получено в результате фаззинга его формулы постановкой в parm1 значений всех возможных векторов XSS &lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Описанные выше подходы позволяют справиться с анализом значительной части фрагментов тьюринг-полного кода, но требуют существенной инженерной проработки как в части наполнения базы знаний и оптимизации эмулирования семантики стандартных типов, так и в части реализации песочницы для частичного выполнения кода (никто не захочет, чтобы в процессе анализа внезапно выполнилось что-то вроде File.Delete в цикле), а также поддержки фаззинга n-местных неизвестных функций, интеграции концепции частичного вычисления с &lt;span class="caps"&gt;SMT&lt;/span&gt;-солвером и т.п. Однако же, никаких существенных ограничений на их реализацию нет, в отличии от граблей классического &lt;span class="caps"&gt;SAST&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Когда гадкий duck-typing становится&amp;nbsp;лебедем&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Представьте, что нам необходимо проанализировать следующий&amp;nbsp;код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// UnknownType - тип, объявленный в отсутствующей зависимости &lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Человек без труда увидит здесь достижимую уязвимость к &lt;span class="caps"&gt;XSS&lt;/span&gt;. А вот большинство существующих статических анализаторов ее благополучно прошляпят в связи с тем, что им ничего не известно о типе UnknownType. Однако все, что здесь требуется от &lt;span class="caps"&gt;IA&lt;/span&gt; - это забыть о статической типизации и перейти к утиной. Семантика интерпретации таких конструкций должна полностью зависеть от контекста их использования. Да, интерпретатор ничего не знает о том, чем является &lt;code&gt;UnknownType.Property1&lt;/code&gt; - свойством, полем, или даже делегатом (ссылкой на метод в C#). Но поскольку операции с ней осуществляются как с переменной-мембером какого-то типа, интерпретатору ничего не мешает обрабатывать их именно таким образом. А если, к примеру, далее по коду встретится конструкция &lt;code&gt;UnknownType.Property1()&lt;/code&gt;, то ничто не мешает интерпретировать вызов того метода, ссылка на который была ранее присвоена Property1. И так далее, в лучших традициях заводчиков&amp;nbsp;уток-чемпионов.&lt;/p&gt;
&lt;h2&gt;Подводя&amp;nbsp;итоги&lt;/h2&gt;
&lt;p&gt;Разумеется, есть масса маркетинговых свистелок, которыми один анализатор якобы выгодно отличается от другого, с точки зрения продающей его стороны. Но, согласитесь, в них нет никакого проку, если ядро продукта не в состоянии обеспечить базовую функциональность, ради которой его и будут использовать. А для того, чтобы её обеспечить, анализатор обязан стремиться по своим возможностям к описанному &lt;span class="caps"&gt;IA&lt;/span&gt;. Иначе ни о какой реальной защищенности на обрабатываемых им проектах и речи быть не&amp;nbsp;может. &lt;/p&gt;
&lt;p&gt;Несколько лет назад, один из наших клиентов обратился к нам за проведением анализа защищенности разрабатываемой им системы. В числе вводных данных он предоставил отчет об анализе кода их проекта продуктом, являвшимся на тот момент лидером на рынке &lt;span class="caps"&gt;SAST&lt;/span&gt;-инструментария. Отчет содержал около двух тысяч записей, большинство из которых оказались в итоге на проверку положительно-ложными срабатываниями. Но самым плохим оказалось то, чего не было в отчете. В результате ручного анализа кода, нами были обнаружены десятки уязвимых мест, пропущенных при сканировании. Использование подобных анализаторов приносит больше вреда, чем пользы, как отнимая время, необходимое для разбора всех ложно-положительных результатов, так и создавая иллюзию защищённости из-за ложно-отрицательных. Этот случай, кстати, стал одной из причин разработки нами собственного&amp;nbsp;анализатора.&lt;/p&gt;
&lt;h2&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Talk is cheap. Show me the&amp;nbsp;code.&amp;#8221;&lt;/h2&gt;
&lt;p&gt;Было бы странным не завершить статью небольшим примером кода, позволяющим проверить степень идеальности того или иного анализатора на практике. Voila - ниже представлен код, включающий в себя все базовые кейсы, покрываемые описанным подходом к абстрактной интерпретации, но не покрываемые более примитивными подходами. Каждый кейс реализован настолько тривиально, насколько это возможно и с минимальным количеством инструкций языка. Это пример для C#/&lt;span class="caps"&gt;ASP&lt;/span&gt;.Net WebForms, но не содержит какой-либо специфики и легко может быть транслирован в код на любом другом ООП-языке и под любой&amp;nbsp;web-фреймворк. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ZmFsc2U=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;false&amp;quot; в base64-кодировке&lt;/span&gt;
&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pvo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// False-negative&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не интерпретирующие поток выполнения по потокам данных функционального типа, не сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;pvo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Для анализаторов, требующих компилируемый код, этот фрагмент необходимо удалить&lt;/span&gt;
&lt;span class="cp"&gt;#region&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, игнорирующие некомпилируемый код, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endregion&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие условия достижимости точек выполнения, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WebUtility&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HtmlEncode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику нестандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="c1"&gt;// (CustomFilter.Filter реализует логику `s.Replace(&amp;quot;&amp;lt;&amp;quot;, string.Empty).Replace(&amp;quot;&amp;gt;&amp;quot;, string.Empty)`)&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных кодирующих функций, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="m"&gt;1725&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, аппроксимирующие или игнорирующие интерпретацию циклов, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не интерпретирующие семантику типов стандартной библиотеки, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Результатом анализа данного кода должно являться сообщение о единственной уязвимости к атакам &lt;span class="caps"&gt;XSS&lt;/span&gt; в выражении &lt;code&gt;pvo(parm1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Вступить и компилировать с готовым к сканированию проектом можно &lt;a href="https://kochetkov.github.io/uploads/IAMeter.zip"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но, как говорится, &amp;#8220;лучше один раз увидеть&amp;#8230;&amp;#8221; и, в первую очередь, мы проверили на соответствие &lt;span class="caps"&gt;IA&lt;/span&gt; разрабатываемый нами анализатор, по чистой случайности называющийся &lt;a href="http://ai.ptsecurity.ru/"&gt;&lt;span class="caps"&gt;AI&lt;/span&gt;&lt;/a&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А вы - уже проверили свой?&amp;nbsp;;)&lt;/p&gt;
&lt;h2&gt;На правах бонуса для дочитавших до&amp;nbsp;конца&lt;/h2&gt;
&lt;p&gt;Мы открываем публичное альфа-тестирование бесплатной утилиты Approof. В нее не включена функциональность анализа кода и не используется весь описанный выше матастафический хардкор, зато включена функциональность выявления в проектах уязвимых внешних компонентов, недостатков конфигурации, чувствительных к разглашению данных, а также внедренных веб-шеллов и вредоносного&amp;nbsp;кода:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png"&gt;&lt;/p&gt;
&lt;p&gt;Скачать утилиту можно на &lt;a href="http://approof.ptsecurity.ru/"&gt;официальном сайте&lt;/a&gt;. Перед ее использованием обязательно ознакомьтесь с лицензионным соглашением. В ходе анализа, Approof собирает неконфиденциальную статистику по проекту (&lt;span class="caps"&gt;CLOC&lt;/span&gt;, типы файлов, используемые фреймворки и т.к.) и, опционально, отправляет ее на сервер &lt;span class="caps"&gt;PT&lt;/span&gt;. Отключить отправку статистики или ознакомиться с сырым json, содержащим собранные данные, можно в разделе About&amp;nbsp;приложения.&lt;/p&gt;</content><category term="Блог"></category><category term="SAST"></category><category term="DAST"></category><category term="IAST"></category><category term="статический анализ кода"></category><category term="анализатор кода"></category><category term="Application Inspector"></category></entry><entry><title>Analyzing source code for vulnerabilities: SAST theory, practice, and prospects</title><link href="https://kochetkov.github.io/sast-theory-practice-and-prospects-en.html" rel="alternate"></link><published>2016-07-08T04:00:00+03:00</published><updated>2016-07-08T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-07-08:/sast-theory-practice-and-prospects-en.html</id><summary type="html">&lt;p&gt;It would not be a big overstatement to say that the market for &lt;span class="caps"&gt;SAST&lt;/span&gt; (Static Application Security Testing) tools is currently booming. Research papers on &lt;span class="caps"&gt;SAST&lt;/span&gt; are published at least once every two months, new &lt;span class="caps"&gt;SAST&lt;/span&gt; tools become available every year, and whole sections at international information security conferences are dedicated to &lt;span class="caps"&gt;SAST&lt;/span&gt;’s role in software development. &lt;span class="caps"&gt;SAST&lt;/span&gt; tool vendors constantly bombard the prospective users with tons of information about their products, and it is not easy to understand which part of it is true, and which is just a marketing hype. Let’s try to understand the real capabilities of such tools, and what we should do if they cannot handle some issues. We are going to take a little dive into the theory that lies in the basis of state-of-the-art &lt;span class="caps"&gt;SAST&lt;/span&gt;&amp;nbsp;tools.&lt;/p&gt;</summary><content type="html">&lt;p&gt;It would not be a big overstatement to say that the &lt;span class="caps"&gt;SAST&lt;/span&gt; market is currently booming. Research papers on &lt;span class="caps"&gt;SAST&lt;/span&gt; are published at least once every two months, new &lt;span class="caps"&gt;SAST&lt;/span&gt; tools become available every year, and whole sections at international information security conferences are dedicated to &lt;span class="caps"&gt;SAST&lt;/span&gt;’s role in software development. &lt;span class="caps"&gt;SAST&lt;/span&gt; tool vendors constantly bombard the prospective users with tons of information about their products, and it is not easy to understand which part of it is true, and which is just a marketing hype. Let’s try to understand the real capabilities of such tools, and what we should do if they cannot handle some issues. We are going to take a little dive into the theory that lies in the basis of state-of-the-art &lt;span class="caps"&gt;SAST&lt;/span&gt;&amp;nbsp;tools.&lt;/p&gt;
&lt;h2&gt;Turing, Rice and all, all,&amp;nbsp;all&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;/&lt;span class="caps"&gt;DR&lt;/span&gt;: The problem of static application security testing is algorithmically&amp;nbsp;undecidable.&lt;/p&gt;
&lt;p&gt;Imagine a set of fully abstract programs (let’s call it P) that always hang on some inputs and halt after doing some operations on other inputs. Obviously, class P includes all theoretically possible programs, because each of them has this&amp;nbsp;property. &lt;/p&gt;
&lt;p&gt;Now imagine that one of these programs is a code analyzer (let’s call it h) that can answer this simple question: Does an arbitrary program p of P hang on the given input n? Obviously, h can answer this question only if it completes its job; by doing that, it tells us that p hangs on n. In other words, if p(n) doesn’t halt, then h(p(n)) must complete its job in a finite number of steps; and if p(n) halts, then h(p(n)) must&amp;nbsp;hang. &lt;/p&gt;
&lt;p&gt;Now imagine what happens if we try using that analyzer to answer this question: Will the analyzer hang if it tries to analyze itself analyzing itself? (Because p can be any program of P, so it can be h, too.) But in this case, if h(h(n)) halts, then the analyzing of h(n) hangs; and if h(h(n))) hangs, then the analyzing of h(n) halts. But h is h(n), so we have a contradiction, which means that an h-like analyzer cannot&amp;nbsp;exist.&lt;/p&gt;
&lt;p&gt;The above is a loose summary of the proof of The Halting Theorem that was formulated by Alan Turing, the founder of the modern theoretical computer science, in 1936. The theorem states that there is no program able to analyze another program and answer the question whether that program would halt on a certain input. Well, maybe we could create a program that can answer the question about some other properties of programs under&amp;nbsp;examination?&lt;/p&gt;
&lt;p&gt;Because set P includes all possible programs, we can always split it into two classes (let’s call them A and B) based on the existence of any nontrivial, invariant property in the programs. Here nontriviality and invariance means that any program of P either has that property or doesn’t have it. Moreover, either all functionally identical programs (which produce the same outputs when fed identical inputs) have that property, or none of them has&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Imagine that there exists a code analyzer (let’s call it q) that takes an arbitrary program p of P as an input, and halts if p belongs to one of the classes (A or B). For example, let it be class A. Let pa be a program that belongs to class A and gets caught in an endless loop on any input. Let’s also take an arbitrary program (pb) from class B. For each program p, let’s define program p&amp;#8217; that takes input x and executes the following&amp;nbsp;algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p(p)&lt;/li&gt;
&lt;li&gt;pb(x)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now let’s create program q&amp;#8217; that takes an arbitrary program p as an input, creates for it p&amp;#8217;, and calculates&amp;nbsp;q(p&amp;#8217;). &lt;/p&gt;
&lt;p&gt;If p&amp;#8217; hangs on the first step, it means that p&amp;#8217; is functionally identical to pa (and belongs to class A), so q&amp;#8217; must halt immediately. If p&amp;#8217; completes the first step, it means that p&amp;#8217; is functionally identical to pb (and belongs to class B), so q&amp;#8217; must hang. Therefore, for any program p, q&amp;#8217;(p) halts if p(p) doesn’t halt. But q&amp;#8217; can take the place of p, so p(p) halts only if p(p) doesn’t halt. Again, it is a&amp;nbsp;contradiction. &lt;/p&gt;
&lt;p&gt;The statement that there is no program that can answer the question whether an arbitrary program has any nontrivial, invariant properties was proved by the scientist Henry Gordon Rice in 1953. Basically, his research has generalized the Halting Theorem, because the property of halting on a given input is nontrivial and invariant. Depending on the properties considered, Rice&amp;#8217;s theorem has infinitely many practical values: “It is impossible to use a program to classify an algorithm implemented by another program,” “It is impossible to use a program to prove that two other programs implement one and the same algorithm,” “It is impossible to use a program to prove that another program doesn’t enter certain states on any inputs,” etc. We should consider the last example in more&amp;nbsp;detail.&lt;/p&gt;
&lt;p&gt;When any (abstract or real) algorithm is being executed by a universal executing program (for example, by a virtual machine that emulates a real computer with its operating system), we can take a snapshot of that virtual machine, including the state of the application (algorithm) being executed in the address space of the virtual machine and its external environment, such as disk drives, the state of external devices, etc. Later we can restore that state from the snapshot and continue running the application from the very same point. In essence, the whole process of any program’s execution is a sequence of changing states that is determined by the program’s source code. If there are any errors in the configuration or implementation of the program or the virtual machine, it is highly probable that the control flow will enter a state that has  never been intended by the program’s&amp;nbsp;developer.&lt;/p&gt;
&lt;p&gt;What is a vulnerability? It is an opportunity of using input data to make the control flow enter a state that allows the attacker to realize a threat regarding the data being processed by the program. Therefore, we can define the security of any program as its ability to always remain within the predetermined set of admissible states that determine its security policy, regardless of the initial input. In that case, the security analysis problem boils down to checking whether it is impossible for the program to enter any state not allowed by the security policy on an arbitrary input. That is, to the problem whose algorithmic undecidability has been long ago proved by Henry&amp;nbsp;Rice.&lt;/p&gt;
&lt;p&gt;Does it mean that the whole &lt;span class="caps"&gt;SAST&lt;/span&gt; market is basically a snake oil industry? In theory – yes, it is. But in practice, as usually, the answer to that question is not that&amp;nbsp;simple.&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;SAST&lt;/span&gt; theory in&amp;nbsp;practice&lt;/h2&gt;
&lt;p&gt;Even as pure theorists, we could ease some requirements of Rice’s statement for real programs executed in real environments. First, in theoretical computer science, a program is a mathematical abstraction that is equivalent to a Turing machine (&lt;span class="caps"&gt;TM&lt;/span&gt;), the most powerful computing automaton. However, in real programs only some code fragments are truly equivalent to &lt;span class="caps"&gt;TM&lt;/span&gt;. In terms of computation power, linear bounded automata, stack machines, and finite state machines are below &lt;span class="caps"&gt;TM&lt;/span&gt;. Even as pure theorists, we can analyze the security of stack machines and finite state&amp;nbsp;machines.&lt;/p&gt;
&lt;p&gt;Second, &lt;span class="caps"&gt;TM&lt;/span&gt;’s distinguishing feature is that it can use a memory of an infinite size. This feature is the reason why we cannot get all possible states of a computation process – simply because there are an infinite number of them. But the amount of memory in real computers is far from infinite. What is even more important, in real programs the number of states that may be of some interest from the viewpoint of security analysis is also finite, though obscenely&amp;nbsp;huge.&lt;/p&gt;
&lt;p&gt;Third, calculating a program’s properties based on Rice’s statement is a decidable problem for a number of small TMs that have few states and few possible transitions between them. It is hard to imagine a real program that has 2 to 4 states. But it is much easier to imagine a program’s &lt;em&gt;fragment&lt;/em&gt; with that number of&amp;nbsp;states.&lt;/p&gt;
&lt;p&gt;Therefore, we can effectively analyze code fragments that meet the above criteria. In practice it means&amp;nbsp;that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We can thoroughly analyze a code fragment without any program loops or recursion, because it is equivalent to a finite state&amp;nbsp;machine;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can analyze a code fragment with some program loops or recursion if the exit conditions do not depend on input, by considering it as a finite state machine or a stack&amp;nbsp;machine;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the exit conditions for the program loop or recursion depends on input whose length is reasonably limited, in some cases we can analyze the fragment as a system of linear bounded automata or a system of small&amp;nbsp;TMs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As for other code fragment types, alas, we cannot use the static approach to analyze them. Moreover, when developing source code security analyzers, software engineers have to trade off between &lt;span class="caps"&gt;EXPSPACE&lt;/span&gt; and &lt;span class="caps"&gt;EXPTIME&lt;/span&gt; on a daily basis. When they do manage to reduce even special cases to a sub-exponential algorithm, they feel happy like little kids, because it’s really awesome! How do you think, what will be the power of the set of possible values of variable parm1 at the last execution&amp;nbsp;point?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That’s why we don’t have to worry too much about the theoretical limitations, because it is extremely unlikely that we would ever hit them when using any practically available computation power. However, the easing of the requirements has set the evolution of modern static code analyzers on the right course, so we should keep it in mind&amp;nbsp;anyway.   &lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAST&lt;/span&gt;, &lt;span class="caps"&gt;IAST&lt;/span&gt;, and all, all,&amp;nbsp;all&lt;/h2&gt;
&lt;p&gt;Unlike the static approach, where program code is analyzed without actually being executed, the dynamic approach (Dynamic Application Security Testing, &lt;span class="caps"&gt;DAST&lt;/span&gt;) requires having a runtime environment and executing the program on some inputs that are most useful for analysis purposes. Simply speaking, we can call &lt;span class="caps"&gt;DAST&lt;/span&gt; a “method of informed trial and error”: “Let’s feed these input data, which are characteristic for that kind of attack, to the program and see what happens.” This method has obvious drawbacks: In many cases we can’t quickly deploy the system to be analyzed (sometimes we can’t even build it), the system’s transition to a certain state may be the result of processing the previous inputs, and a comprehensive analysis of a real system’s behavior requires feeding it so many inputs that it is utterly impractical to try testing the system on each of&amp;nbsp;them.&lt;/p&gt;
&lt;p&gt;Not long ago, Interactive Application Security Testing (&lt;span class="caps"&gt;IAST&lt;/span&gt;) – an approach that combined the strengths of &lt;span class="caps"&gt;SAST&lt;/span&gt; and &lt;span class="caps"&gt;DAST&lt;/span&gt; – was considered promising. &lt;span class="caps"&gt;IAST&lt;/span&gt;’s distinctive feature is that the &lt;span class="caps"&gt;SAST&lt;/span&gt; part generates inputs and the templates of expected results, and the &lt;span class="caps"&gt;DAST&lt;/span&gt; part tests the system on these inputs, prompting the human operator to interfere in ambiguous situations. The irony of this approach is that it has inherited both strengths and weaknesses of &lt;span class="caps"&gt;SAST&lt;/span&gt; and &lt;span class="caps"&gt;DAST&lt;/span&gt;, which calls in question its&amp;nbsp;practicality.&lt;/p&gt;
&lt;p&gt;But who said that dynamic code analysis means that we have to execute the whole program? As we have already seen, we can use the static approach to analyze a major portion of the program’s code. Why can’t we use the dynamic approach to analyze only the remaining code fragments? It sounds like we have a&amp;nbsp;plan…&lt;/p&gt;
&lt;h2&gt;Mumbo Jumbo™&amp;nbsp;Inside&lt;/h2&gt;
&lt;p&gt;There are several classic approaches to static code analysis, which use different models for producing the properties of the code under examination. The most primitive and obvious approach is signature search. It is based on looking for occurrences of some template in the syntax code presentation model (which is usually a token flow or an abstract syntax tree). Some implementations of that approach use slightly more-complex models (semantic tree, its mapping to the graph of some data flow, etc.). But on the whole, this approach is only useful as a secondary one: It allows us to mark suspicious parts of the code within a linear time, so that later we can check them manually. Enough said about this approach; if you are interested in it, please read the &lt;a href="http://blog.ptsecurity.com/search/label/AST"&gt;series of articles&lt;/a&gt; by Ivan&amp;nbsp;Kochurkin.&lt;/p&gt;
&lt;p&gt;More-complex approaches use code execution (not presentation or semantic) models. Such models usually can answer this question: Can a data flow under external control reach such an control flow point that it creates a vulnerability? In most cases, the model is a &lt;a href="https://en.wikipedia.org/wiki/Control_flow_graph"&gt;control flow graph&lt;/a&gt; or a &lt;a href="https://en.wikipedia.org/wiki/Data_flow_diagram"&gt;data flow diagram&lt;/a&gt;, or a combination of them (for example, a &lt;a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf"&gt;code property graph&lt;/a&gt;). Such approaches have an obvious drawback: When analyzing any nontrivial code, answering the above question is not enough to successfully detect a vulnerability. For example, here’s a code&amp;nbsp;fragment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filteredParam&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Based on the created model, the trivial graph-based analyzer will confirm that the data flow &lt;code&gt;Request.Params["param"]&lt;/code&gt; can reach the control flow point &lt;code&gt;Response.Write(filteredParam)&lt;/code&gt;, and that there is a vulnerability to &lt;span class="caps"&gt;XSS&lt;/span&gt; attacks there. Actually, that data flow is effectively filtered and cannot carry the attack vector! There are many methods that allow us to cover special cases associated with data flow preprocessing, but ultimately each of them means finding a reasonable balance between false positives and false negatives, also known as Type I errors and type &lt;span class="caps"&gt;II&lt;/span&gt;&amp;nbsp;errors.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Type 1 &amp;amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg"&gt;&lt;/p&gt;
&lt;p&gt;How can we minimize the number of errors of both types? We need to consider reachability conditions both for potentially vulnerable control flow points and for combinations of values of the data flows that can reach those points. Based on that information, we can create a system of equations whose set of solutions will give us all possible inputs that are necessary to reach the potentially vulnerable point in the program. The intersection of this set with the set of all possible attack vectors will produce the set of all inputs that bring the program to a vulnerable state. It sounds great, but how can we build a model that contains all necessary&amp;nbsp;information?&lt;/p&gt;
&lt;h2&gt;Abstract interpretation and symbolic&amp;nbsp;computation&lt;/h2&gt;
&lt;p&gt;Suppose, we need to find out the sign of the number produced by this expression: &lt;code&gt;-42 / 8 * 100500&lt;/code&gt;. The simplest way to do it is to calculate the result and check if it is negative. The computation of an expression by using specific values of all arguments is known as “concrete computation.” But we can also solve this problem in a different way. Imagine that for some reason the concrete computation of this expression cannot be done. For example, because a variable has been added: &lt;code&gt;-42 / 8 * 100500 * x&lt;/code&gt;. Let’s define an abstract arithmetic in which the result of operations on numbers is defined only by the signs, while the absolute values of all arguments are&amp;nbsp;ignored:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(+a) = (+)&lt;/span&gt;
&lt;span class="err"&gt;(-a) = (-)&lt;/span&gt;
&lt;span class="err"&gt;(-) * (+) = (-)&lt;/span&gt;
&lt;span class="err"&gt;(-) / (+) = (-)  &lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;(-) + (+) = (+-)&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let’s interpret the initial expression within this semantics: &lt;code&gt;(-) / (+) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-)&lt;/code&gt;. This approach will give an unambiguous answer to the question as long as the expression does not contain any addition or subtraction operators. Let’s modify our arithmetic to consider the absolute values of arguments,&amp;nbsp;too:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(-a) * (+b) = (-c)&lt;/span&gt;
&lt;span class="err"&gt;(-a) / (+b) = (-c)  &lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;(-a) + (+b) = &lt;/span&gt;
&lt;span class="err"&gt;    a &amp;lt;= b -&amp;gt; (+)&lt;/span&gt;
&lt;span class="err"&gt;    a &amp;gt;  b -&amp;gt; (-)&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If we interpret the expression &lt;code&gt;-42 / 8 * 100500 + x&lt;/code&gt; based on the new semantics, the result will be &lt;code&gt;x &amp;gt;= -527625 -&amp;gt; (+), x &amp;lt; -527625 -&amp;gt; (-)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The above approach is called &lt;a href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;abstract interpretation&lt;/a&gt;. It is formally defined as a stable approximation of the semantics of expressions, based on monotonic functions over ordered sets. Simply speaking, it is an interpretation of expressions without a concrete computation of them, intended to gather information within the given semantic field. Let’s smoothly go from interpreting some expressions to interpreting program code in some programming language. As for the semantic field, let’s define the semantics of the language, complemented with the rule to handle all inputs as unknown variables (symbolic values). The result is an approach known as “[symbolic execution,]”(https://en.wikipedia.org/wiki/Symbolic_execution) which lies in the basis of most promising &lt;span class="caps"&gt;SAST&lt;/span&gt;&amp;nbsp;tools.&lt;/p&gt;
&lt;p&gt;It is symbolic computation that allows us to create a context graph for symbolic computation (also known as a computation flow graph). It is a model that comprehensively describes the computation process of the program under examination. That model was considered in the report &lt;a href="http://www.slideshare.net/kochetkov.vladimir/automated-patching-for-vulnerable-source-code/14"&gt;“Automated generation of source code patches”&lt;/a&gt;, and the model’s application for code security analysis was covered in the article &lt;a href="https://www.ptsecurity.com/upload/ptcom/PT_Positive_Research_2015_EN_web.pdf"&gt;&amp;#8220;Source Code Security Assessment and Automatic Exploit Generation&amp;#8221;&lt;/a&gt; (p. 23-24). It doesn’t make much sense for us to cover them again in this article. It should be noted that the model allows us to get reachability conditions both for any control flow point and for sets of values of input arguments. That is, it is just what we need to solve our&amp;nbsp;problem.&lt;/p&gt;
&lt;h2&gt;Vulnerability search based on the computation flow&amp;nbsp;graph&lt;/h2&gt;
&lt;p&gt;If we formalize vulnerability criteria to a certain attack class in terms of the computation flow graph, we can implement code security analysis by finding out the properties of a concrete model obtained as a result of the abstract interpretation of the code under examination. For example, we can formalize the criteria of vulnerability to any injection attacks (SQLi, &lt;span class="caps"&gt;XSS&lt;/span&gt;, XPATHi, Path Traversal, etc.) as&amp;nbsp;follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let C be the computation flow graph of the code under&amp;nbsp;examination.&lt;/p&gt;
&lt;p&gt;Let pvf(t) be the reachable control flow node in C, so that pvf(t) is the call of the function of direct or indirect interpretation of text t that conforms to formal grammar&amp;nbsp;G.&lt;/p&gt;
&lt;p&gt;Let e be the input data argument flow in&amp;nbsp;С. &lt;/p&gt;
&lt;p&gt;Let De be the set of data flows in C that are derived from e and reachable at the pvf(t) invocation&amp;nbsp;point.&lt;/p&gt;
&lt;p&gt;Then the program is vulnerable to injection attacks at the pvf(t) invocation point if t belongs to De and the set of values of De includes at least one pair of elements which, if syntactically parsed in conformance with grammar G, produces trees that are not isomorphic to each&amp;nbsp;other.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can formalize vulnerabilities to other attack classes in a similar manner. However, it should be noted that not all vulnerability types can be formalized within a model created based on the code under examination. In some cases, we may need more information. For example, to formalize vulnerabilities to attacks against business logic, we need to have formalized rules for the program’s application domain; to formalize vulnerabilities to attacks against access control, we need formalized access control policies;&amp;nbsp;etc.&lt;/p&gt;
&lt;h2&gt;Ideal – that is, purely theoretical – code security&amp;nbsp;analyzer&lt;/h2&gt;
&lt;p&gt;Let’s forget about the harsh reality for awhile and try answering this question: If a hypothetical Ideal Analyzer (&lt;span class="caps"&gt;IA&lt;/span&gt;) could exist, what functionality should it&amp;nbsp;have?&lt;/p&gt;
&lt;p&gt;First, it should have the strengths of both &lt;span class="caps"&gt;SAST&lt;/span&gt; and &lt;span class="caps"&gt;DAST&lt;/span&gt;, but do not have their weaknesses. Among other things, it means that &lt;span class="caps"&gt;IA&lt;/span&gt; should be able to analyze any existing program code (source code or binary code) without requiring its completeness or the program to be deployed in the runtime environment. In other words, &lt;span class="caps"&gt;IA&lt;/span&gt; should be able to analyze projects with missing external dependencies, or when some other factors do not let us to build or deploy the program. Moreover, handling code fragments that contain references to missing dependencies should be implemented as completely as possible in each particular case. On the other hand, &lt;span class="caps"&gt;IA&lt;/span&gt; should not only be able to avoid the theoretical limitations imposed by the Turing computation model, but also complete scanning within a reasonable time, consume a reasonable amount of memory, and, when possible, stay in the sub-exponential “weight&amp;nbsp;category.”&lt;/p&gt;
&lt;p&gt;Second, the probability of Type I errors should be minimized by creating and solving systems of logical equations and generating a working attack vector that allows the user to confirm the existence of the vulnerability in one&amp;nbsp;click. &lt;/p&gt;
&lt;p&gt;Third, &lt;span class="caps"&gt;IA&lt;/span&gt; should effectively deal with Type &lt;span class="caps"&gt;II&lt;/span&gt; errors by allowing the user to check all potentially vulnerable control flow points manually if &lt;span class="caps"&gt;IA&lt;/span&gt; was unable to either prove or disprove their&amp;nbsp;vulnerability.&lt;/p&gt;
&lt;p&gt;Using a model based on symbolic computation allows us to implement all of the above requirements by-design, except for the ones related to theoretical limitations and sub-exponentiality. Our plan – to employ dynamic code analysis when static code analysis fails – is just what we&amp;nbsp;need! &lt;/p&gt;
&lt;h2&gt;Partial computation, inverse functions, and deferred&amp;nbsp;interpretation&lt;/h2&gt;
&lt;p&gt;Imagine that &lt;span class="caps"&gt;IA&lt;/span&gt; contains a knowledge base that describes the semantics of input transformation functions implemented in the standard language library or the program’s runtime environment, in the most popular frameworks and CMSs. For example, imagine that the functions Base64Decode and Base64Encode are mutually inverse, or that each call of StringBuilder.Append adds a new line to the string already stored in the temporary variable of that class, etc. Thanks to all that knowledge, &lt;span class="caps"&gt;IA&lt;/span&gt; doesn’t have to “fall through” into the library code whose analysis is subject to all computational limitations,&amp;nbsp;too:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// The value of cond2 required for meeting the condition will be produced by the solver based on the knowledge base on inverse functions &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// The value of sb.ToString will be obtained by emulating the semantics of StringBuilder described in the knowledge base on library functions&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But what if there is a call of a function in the code, but there is no description of that function in the &lt;span class="caps"&gt;IA&lt;/span&gt; knowledge base? Imagine that &lt;span class="caps"&gt;IA&lt;/span&gt; can use a virtual sandbox environment that allows it to run an arbitrary fragment of the code under examination in the given context and get the result of its execution. Let’s call it “partial computation.” In that case, before “falling through” into an unknown function and starting to interpret it abstractly, &lt;span class="caps"&gt;IA&lt;/span&gt; can try doing a trick called “partial fuzzing.” The general idea of that trick is that we can prebuild a knowledge base on library transformation functions and any combinations of sequential calls of such functions based on the already-known combinations of test data. Having that knowledge base, we can execute an unknown function on the same combinations of data and then compare the results to the samples from the knowledge base. If the results of executing the unknown function match the results of executing a known sequence of library functions, it would mean that now &lt;span class="caps"&gt;IA&lt;/span&gt; knows the semantics of the unknown function, so there is no need to interpret the&amp;nbsp;function.&lt;/p&gt;
&lt;p&gt;But if the set of input values of all data flows are known for a code fragment that doesn’t contain any dangerous operators, &lt;span class="caps"&gt;IA&lt;/span&gt; can simply execute that fragment on all possible data flows and use the results instead of abstractly interpreting that fragment. That fragment can be of any computation power class, without any impact whatsoever on the results of its execution. Moreover, even if we do not know beforehand the the set of input values of data flows for a code fragment, &lt;span class="caps"&gt;IA&lt;/span&gt; can defer the interpretation of that fragment until it starts to solve the equation for the specific dangerous operator. At the solution step, an additional limitation about the presence of specific attack vectors in input data is imposed on the set of input values, which may allow us to make assumptions about the set of input values for the deferred fragment, and thereby partially compute it at this&amp;nbsp;step.&lt;/p&gt;
&lt;p&gt;Moreover, at the solution step, &lt;span class="caps"&gt;IA&lt;/span&gt; can simply take the final reachability formula for the dangerous point and its arguments (it would be easier to build the formula by using the syntax and semantics of the language used in the code under examination) and fuzzy it thoroughly on all known vector values to get their subset that can pass through all filter functions of the&amp;nbsp;formula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// The value of the Response.Write argument that passes unchanged through the filter function can be obtained by fuzzing its formula by substituting the values of all possible XSS vectors in parm1 &lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The above approaches allow us to analyze a good share of Turing-complete code fragments but require significant efforts by the software engineers, who need to build knowledge bases and optimize the emulation of semantics of standard types, and to implement the sandbox for partial code execution (surely nobody wants for something like File.Delete to be executed in program loop during the analysis). The engineers also need to provide support for fuzzing of n-local unknown functions, integrate the concept of partial execution with the &lt;span class="caps"&gt;SMT&lt;/span&gt; solver, etc. Nevertheless, there are no substantial limitations to doing all these things, quite unlike the drawbacks of the classic &lt;span class="caps"&gt;SAST&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;When the ugly duck-typing becomes a&amp;nbsp;swan&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Imagine that we need to analyze the following&amp;nbsp;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// UnknownType - a type that is declared in a missing dependency &lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;A human can easily detect a reachable &lt;span class="caps"&gt;XSS&lt;/span&gt; vulnerability in the above code fragment. However, the majority of the existing static code analyzers will miss it simply because they don’t know anything about the UnknownType type. But &lt;span class="caps"&gt;IA&lt;/span&gt; only needs to forget about static typing and use duck typing instead. The semantics of interpretation of such constructs should be completely dependent on the context of their use. Yes, the interpreter doesn’t know what &lt;code&gt;UnknownType.Property1&lt;/code&gt; is – a property, a field, or even a delegate (a reference to a method in C#). But because operations on it are done as if it is a variable-member of a specific type, the interpreter can simply process it in the respective manner. And if, for example, &lt;span class="caps"&gt;IA&lt;/span&gt; finds the construct &lt;code&gt;UnknownType.Property1()&lt;/code&gt; further in the code, it can simply interpret the call of the method, a reference to which has been earlier attributed to Property1. Etcetera, etcetera, in keeping with the best traditions of duck&amp;nbsp;breeders.&lt;/p&gt;
&lt;h2&gt;Taking&amp;nbsp;stock&lt;/h2&gt;
&lt;p&gt;Surely, there are tons of bells and whistles which supposedly make one code analyzer better than another, at least from the vendor’s viewpoint. But if the analyzer’s engine cannot provide even the basic functionality, what’s the point of having lots of trendy features? To make the users happy, the analyzer’s developers must strive to provide the functionality that is as close to that of the &lt;span class="caps"&gt;IA&lt;/span&gt; as possible. Otherwise, you can just forget about any actual security of the projects checked by the&amp;nbsp;analyzer. &lt;/p&gt;
&lt;p&gt;Some years ago, a customer of ours asked us to analyze the security of a system he was developing. Among the introductory data, he enclosed a report of code analysis done by an analyzing product that was the leader of the &lt;span class="caps"&gt;SAST&lt;/span&gt; tools market at that time. The report contained about two thousand entries, most of which eventually proved to be false positives. But the worst part was what was missing in the report. By manually analyzing the code, we have found dozens of vulnerable points that had been missed by the leading analyzer! So using such analyzers does more harm than good: You waste your time on manually checking all false positives, and the presence of false negatives creates an illusion of security. By the way, that case was one of the reasons why we’ve decided to develop our own&amp;nbsp;analyzer.&lt;/p&gt;
&lt;h2&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Talk is cheap. Show me the&amp;nbsp;code.&amp;#8221;&lt;/h2&gt;
&lt;p&gt;It would be amiss not to complete the article with a small code sample that allows you to check the “degree of ideality” of any analyzer in practice. Presto! Below you can see the code that includes all basic cases covered by the approach to abstract interpretation described in this article, but not covered by the more-primitive approaches. Each case has been implemented as trivially as possible and contains few instructions. Though the example is intended for C#/&lt;span class="caps"&gt;ASP&lt;/span&gt;.Net WebForms, it does not contain any specifics and can be easily translated into any other &lt;span class="caps"&gt;OOP&lt;/span&gt; code or adapted for any Web&amp;nbsp;framework. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ZmFsc2U=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;false&amp;quot; in base64&lt;/span&gt;
&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pvo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// False-negative&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that doesn’t interpret the control flow by functional data flows will not report a vulnerability here&lt;/span&gt;
&lt;span class="n"&gt;pvo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// If the analyzer requires compiled code, delete this fragment&lt;/span&gt;
&lt;span class="cp"&gt;#region&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores noncompiled code will report a vulnerability here&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endregion&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores execution point reachability conditions will report a vulnerability here&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores the semantics of standard filter functions will report a vulnerability here&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WebUtility&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HtmlEncode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// An analyzer that ignores the semantics of nonstandard filter functions will report a vulnerability here&lt;/span&gt;
&lt;span class="c1"&gt;// (CustomFilter.Filter implements the logic of `s.Replace(&amp;quot;&amp;lt;&amp;quot;, string.Empty).Replace(&amp;quot;&amp;gt;&amp;quot;, string.Empty)`)&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// An analyzer that ignores the semantics of standard encoding functions will report a vulnerability here&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="m"&gt;1725&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// An analyzer that approximates or ignores the interpretation of program loops will report a vulnerability here&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// An analyzer that does not interpret the semantics of standard library types will report a vulnerability here&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The result of analyzing this code should be a report of a single vulnerability to &lt;span class="caps"&gt;XSS&lt;/span&gt; attacks in the expression &lt;code&gt;pvo(parm1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can join us and compile a ready-to-scan project &lt;a href="https://kochetkov.github.io/uploads/IAMeter.zip"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But, as the saying goes, a picture is worth a thousand words. So we checked our own analyzer, coincidentally called &lt;a href="https://www.ptsecurity.com/products/#ai"&gt;&lt;span class="caps"&gt;AI&lt;/span&gt;&lt;/a&gt;, on conformance to &lt;span class="caps"&gt;IA&lt;/span&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_en.png"&gt;&lt;img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_en.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Have you already checked your analyzer?&amp;nbsp;;)&lt;/p&gt;
&lt;h2&gt;A little bonus for the most patient&amp;nbsp;reader&lt;/h2&gt;
&lt;p&gt;Welcome to the public alpha test of our freeware tool Approof! It doesn’t include the code analysis functionality and doesn’t implement all of the above semitheoretical stuff. Nonetheless, Approof can detect vulnerable external components, configuration defects, and sensible information, as well as injected web shells and&amp;nbsp;malware:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png"&gt;&lt;/p&gt;
&lt;p&gt;You can download Approof from our &lt;a href="https://approof.ptsecurity.com/"&gt;official website&lt;/a&gt;. Before using the tool, please read the license agreement. When analyzing code, Approof collects nonconfidential statistics on the project (&lt;span class="caps"&gt;CLOC&lt;/span&gt;, file types, frameworks used, etc.) and optionally sends it to the &lt;span class="caps"&gt;PT&lt;/span&gt; server. You can turn off the sending of statistics or take a look at the raw json that contains the collected data via the tool’s About&amp;nbsp;menu.&lt;/p&gt;</content><category term="Blog"></category><category term="SAST"></category><category term="DAST"></category><category term="IAST"></category><category term="static code analysis"></category><category term="code analyzer"></category><category term="Application Inspector"></category></entry><entry><title>По следам PHDays VI</title><link href="https://kochetkov.github.io/following-the-tracks-of-phdays-6.html" rel="alternate"></link><published>2016-06-01T04:00:00+03:00</published><updated>2016-06-01T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-06-01:/following-the-tracks-of-phdays-6.html</id><summary type="html">&lt;p&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз Application Inspector нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://phdays.ru"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз &lt;a href="http://www.ptsecurity.ru/products/ai/"&gt;Application Inspector&lt;/a&gt; нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас. &lt;/p&gt;
&lt;p&gt;Внезапно, обещание пропустить все доклады выполнилось само собой и большую часть времени я провел за кулисами, либо очищая &lt;span class="caps"&gt;AI&lt;/span&gt; от лишних фич и готовясь к своему выступлению в промежутках между прогонами тестов, либо выступая на закрытой встрече нашей новой девелоперской юзергруппы, о которой расскажу ниже. В итоге, чуть менее, чем вся конференция для меня выглядела как-то&amp;nbsp;так: &lt;/p&gt;
&lt;p&gt;&lt;img alt="PHDays VI глазами Вовы" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Ни за какими конкурсами я не наблюдал и тем более в них не участвовал (а в окрестностях &lt;span class="caps"&gt;CTF&lt;/span&gt;-зоны вообще появлялся лишь на пару минут и только для того, чтобы урвать себе немного космической еды), с вендорскими ништяками пролетел, во всех форках afterparty не участвовал и т.п. Развиртуализировался (ненавижу это слово) с несколькими френдами / подписчиками, что для интроверта уже немеряный подвиг. Наложил кирпичей, когда мимо меня, прямо за кулисами, несколько раз прошуршал  (ряженый, как выяснилось сильно позже) ОМОН в составе 4&amp;nbsp;бойцов.&lt;/p&gt;
&lt;p&gt;Однако же, гвоздем программы для меня стало мероприятие, проводившееся за ее рамками. Как я уже &lt;a href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html"&gt;писал&lt;/a&gt; ранее, в ходе конференции мы планировали провести первую встречу нашей новой пользовательской юзергруппы девелоперов, интересующихся вопросами разработки защищенных приложений и предметной области application security. В ходе нее планировалось провести сокращенный вариант прошлогоднего мастер-класса для разработчиков банковских приложений. В результате - встреча состоялась, мастер-класс проведен и по полученным отзывам можно с уверенностью сказать, что юзергруппе - быть. В относительно ближайшее время, мы планируем провести еще несколько оффлайн-встреч и вебинаров, посвященных тематике группы. В том числе, и с приглашением сторонних экспертов в различных областях и направлениях, связанных с application security. На встрече разработчики аккуратно получали около 6 часов живительного хардкора о теории и всевозможных практических аспектах проектирования и разработки защищенных приложений от&amp;nbsp;/me:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый /me" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;а поддерживать интерес аудитории мне помогал мой коллега Леша Гончаров, развлекавший народ задачками на ненормальный кодинг и раздававший печеньки особо&amp;nbsp;отличившмся:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Леша" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;В конце встречи мы анонсировали бесплатную утилиту от команды &lt;span class="caps"&gt;AI&lt;/span&gt; с рабочим названием Approof, позволяющую провести сканирование исходного кода проекта на предмет ошибок конфигурации и использования уязвимых компонентов. Участники встречи получили ее альфа-версию, а в скором времени, она будет доступна для загрузки всем&amp;nbsp;желающим. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Approof" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/4.png"&gt;&lt;/p&gt;
&lt;p&gt;Должен заметить, что на встрече я столкнулся с самой живой аудиторией из всех, встречавшихся мне на докладах, митапах и вебинарах. Была масса вопросов, кулуларных обсуждений, со мной пытались спорить и даже помогали вести встречу, отвечая участникам на вопросы, адресованные мне. Один из участников упрекнул нашу компанию в том, что мы даем владельцам веб-приложений слишком жесткие рекомендации по усилению content security policy, которые им, компаниям-разработчикам, потом тяжело выполнять (не зря работаем, значит). На второй день из более, чем полусотни слушателей отсеялось лишь около десятка человек, что как бы намекает. Слайды не выкладываю, т.к. они большей частью являются компиляцией ранее публиковавшихся выступлений и представляют интерес только для участников встречи, которые их и так получили по окончанию мероприятия вместе со всей&amp;nbsp;раздаткой.&lt;/p&gt;
&lt;p&gt;Но, в конечном счете, впечатления от конференции сугубо позитивные, хоть она и прошла для меня в достаточно своеобразном формате, повторять который - лично мне бы не&amp;nbsp;хотелось)&lt;/p&gt;</content><category term="Блог"></category><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Семинар Positive Development User Group</title><link href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html" rel="alternate"></link><published>2016-05-06T00:00:00+03:00</published><updated>2016-05-06T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-05-06:/phdays6-positive-development-user-group-workshop.html</id><summary type="html">&lt;p&gt;В этом году, в рамках развития идеи &amp;#8220;&lt;span class="caps"&gt;PT&lt;/span&gt;/PHDays для разработчиков&amp;#8221; эксперты Positive Technologies планируют провести 6-часовой мастер-класс по разработке защищенных&amp;nbsp;приложений.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Идея разработки по-настоящему-полезного-курса-по-разработке-защищенных-приложений-на-котором-не-захочется-спать зародилась в Positive Technologies еще в 2012 году, после проведения серии закрытых вебинаров на эту тему для разработчиков наших партнеров. Позднее, в 2013-ом, на PHDays &lt;span class="caps"&gt;III&lt;/span&gt; был представлен &lt;a href="http://www.slideshare.net/kochetkov.vladimir/hdswasm-russianproofreaded"&gt;воркшоп&lt;/a&gt;, построенный на их материалах. Следующие пару лет, отдельные его фрагменты использовались в различных докладах и курсах, а контент постоянно перерабатывался и дополнялся новыми разделами. Осенью 2015-го, мы с Тимуром Юнусовым объединили свои наработки и провели &lt;a href="https://habrahabr.ru/company/pt/blog/271287/"&gt;двухдневный мастер-класс&lt;/a&gt; для разработчиков банковских приложений. Его изюминкой стала непрерывная смена offensive и defensive направлений рассматриваемых тем. Тимур показывал типовые ошибки разработчиков и их последствия с точки зрения нападающего, а я объяснял, как не допускать их в новом коде и правильно устранять в уже&amp;nbsp;существующем.&lt;/p&gt;
&lt;p&gt;И, поскольку засыпающих в ходе мастер-класса отмечено не было, а отзывы о нем были получены сугубо положительные, мы решили выступить на бис и провести его сокращенный вариант повторно на предстоящей конференции &lt;a href="http://www.phdays.ru/"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt;. И не просто выступить, а в рамках первой (и, как мы надеемся, не последней) встречи Positive Development User Group - сообщества разработчиков, интересующихся предметной областью безопасности приложений. Мероприятие будет проводиться вне основной программы конференции в закрытом формате по персональным приглашениям. Заявку на участие можно заполнить &lt;a href="http://goo.gl/forms/rPIlrPeZBk"&gt;здесь&lt;/a&gt;. С программой и расписанием семинара можно ознакомиться в &lt;a href="https://goo.gl/ZIRUR0"&gt;официальном пресс-релизе мероприятия&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;P.S: И да - у нас будут печеньки&amp;nbsp;:) &lt;/p&gt;</content><category term="Блог"></category><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Переезд блога</title><link href="https://kochetkov.github.io/blog-movement.html" rel="alternate"></link><published>2015-12-15T10:45:00+03:00</published><updated>2015-12-15T10:45:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-12-15:/blog-movement.html</id><content type="html">&lt;p&gt;Давно собирался перенести свой блог с Blogger и наконец сделал это. Со временем, перенесу все хорошие статьи оттуда. Новые статьи будут опубликованы только&amp;nbsp;здесь.&lt;/p&gt;</content><category term="Блог"></category><category term="блог"></category></entry><entry><title>Blog Movement</title><link href="https://kochetkov.github.io/blog-movement-en.html" rel="alternate"></link><published>2015-12-15T10:45:00+03:00</published><updated>2015-12-15T10:45:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-12-15:/blog-movement-en.html</id><content type="html">&lt;p&gt;For a long time I was going to move my blog from Blogger, and finally did it. Over time, I will transfer all good articles from there. New articles will be only published&amp;nbsp;here.&lt;/p&gt;</content><category term="Блог"></category><category term="блог"></category></entry><entry><title>По следам вебинара “Прикладная теория Application Security”</title><link href="https://kochetkov.github.io/webinar-applied-theory-of-the-application-security.html" rel="alternate"></link><published>2015-11-14T00:00:00+03:00</published><updated>2015-11-14T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-11-14:/webinar-applied-theory-of-the-application-security.html</id><summary type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления, на ходу подбирая нужные фразы и пояснения. Посему приношу извинения тем слушателям, которые так и не поняли, что это было. Вероятно в ближайшие месяцы, проведу работу над ошибками в формате статьи или серии заметок, дабы донести основные идеи более внятным и последовательным&amp;nbsp;образом.&lt;/p&gt;
&lt;p&gt;На вебинаре я обещал дать ссылки на несколько статей о символическом исполнении, абстрактной интерпретации и т.п. Поступим проще. Вот &lt;a href="https://www.dropbox.com/sh/sqln21ngapchx3l/AADiJqQuA1U8F4jX3tYly-q9a?dl=0"&gt;здесь&lt;/a&gt; лежит подборка материалов на эти и смежные темы, которые мы в той или иной мере использовали при работе над Application Inspector. Будут вопросы - задавайте в&amp;nbsp;комментариях.&lt;/p&gt;
&lt;p&gt;Что касается книг для дальнейшего чтения, то конкретно по теории есть не так уж и много материалов и практически все мне известные можно собрать по крупицам из подборки выше. Стоит отдельно отметить выступление Meredith L. Patterson, Sergey Bratus на 28C3 в 2011 (&lt;a href="http://www.youtube.com/watch?v=3kEfedtQVOY"&gt;видео&lt;/a&gt;, &lt;a href="http://langsec.org/insecurity-theory-28c3.pdf"&gt;слайды&lt;/a&gt;) и &lt;a href="http://nob.cs.ucdavis.edu/bishop/notes/2008-cse-14/2008-cse-14.pdf"&gt;работу&lt;/a&gt; Matt Bishop с коллегами, которую я упоминал на&amp;nbsp;вебинаре.&lt;/p&gt;
&lt;p&gt;Если говорить о практике, то мой &lt;span class="caps"&gt;TOP&lt;/span&gt; 5 книг, обязательных к прочтению на данную тему следующий (порядок&amp;nbsp;произвольный):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Writing Secure Code, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nostarch.com/tangledweb.htm"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Tangled Web. A Guide to Securing Modern Web&amp;nbsp;Applications&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118026470.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Web Application Hacker&amp;#8217;s Handbook: Finding and Exploiting Security Flaws, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118662091.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Browser Hacker&amp;#8217;s&amp;nbsp;Handbook&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-047008023X.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Shellcoder&amp;#8217;s Handbook: Discovering and Exploiting Security Holes, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Собственно, серию &amp;#8220;Handbooks&amp;#8221; данного издательства стоит прочесть&amp;nbsp;всю.&lt;/p&gt;
&lt;p&gt;P.S: Коллегам по конкурирующему цеху: парни, согласитесь, что обсуждать технические вопросы реализации Application Inspector на вебинаре, связанном с ним лишь косвенно - не вполне корректно по отношению к остальным слушателям. Я всегда готов делиться той информацией, которой имею право делиться со всеми, кто попросит. Даже с конкурентами, причем даже с теми конкурентами, руководство которых находится со мной в контрах. И для этого совсем не нужно дожидаться вебинара с моим участием, как повода задать интересующие вас вопросы :) Мои контакты доступны - пишите, звоните, буду рад пообщаться. Я&amp;nbsp;серьезно.&lt;/p&gt;</content><category term="Блог"></category><category term="вебинары"></category></entry></feed>