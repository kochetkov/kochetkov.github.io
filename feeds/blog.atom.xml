<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>'';!--"&lt;kochetkov.vladimir&gt;=&amp;{()}</title><link href="https://kochetkov.github.io/" rel="alternate"></link><link href="https://kochetkov.github.io/feeds/blog.atom.xml" rel="self"></link><id>https://kochetkov.github.io/</id><updated>2016-10-07T12:00:00+03:00</updated><entry><title>Материалы вебинара “Подводные камни прикладной криптографии I”</title><link href="https://kochetkov.github.io/webinar-applied-cryptography-pitfalls-1.html" rel="alternate"></link><published>2016-10-07T12:00:00+03:00</published><updated>2016-10-07T12:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-10-07:webinar-applied-cryptography-pitfalls-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о генерации криптографических случайных чисел в различных языках (включая многострадальный &lt;span class="caps"&gt;PHP&lt;/span&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;неплохая &lt;a href="https://jazzy.id.au/tags/prng.html"&gt;серия статей&lt;/a&gt; о техниках взлома различных &lt;span class="caps"&gt;PRNG&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks"&gt;описание&lt;/a&gt; атаки удлинения&amp;nbsp;сообщения;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth"&gt;описание&lt;/a&gt; атаки на оракул&amp;nbsp;дополнения.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S: Было бы совсем здорово, если бы участники вебинара не поленились черкнуть пару слов о том, что им (не) понравилось и какие темы были бы им интересны в следующей части&amp;nbsp;вебинара.&lt;/p&gt;</summary><category term="вебинары"></category><category term="криптография"></category></entry><entry><title>Ищем уязвимости в коде: теория, практика и перспективы SAST</title><link href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html" rel="alternate"></link><published>2016-07-08T04:00:00+03:00</published><updated>2016-07-08T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-07-08:sast-theory-practice-and-prospects.html</id><summary type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;
&lt;h2&gt;Тьюринг, Райс - вот эти вот&amp;nbsp;все&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;/&lt;span class="caps"&gt;DR&lt;/span&gt;: задача статического тестирования защищенности программ алгоритмически&amp;nbsp;неразрешима.&lt;/p&gt;
&lt;p&gt;Представьте себе множество полностью абстрактных программ P, которые только и умеют, что зависать на одних наборах входных данных и останавливаться через некоторое число операций на других. Очевидно, что класс P охватывает любые теоретически возможные программы, поскольку это свойство можно приписать любой из&amp;nbsp;них. &lt;/p&gt;
&lt;p&gt;Теперь представьте, что одна из таких программ (назовем ее h) является анализатором, умеющим отвечать на простой вопрос: зависает ли произвольная программа p из множества P на заданном наборе данных n? Очевидно, что отвечать на этот вопрос h сможет только завершая свою работу и тем самым сообщая, что p зависает на n. Иными словами, если p(n) не останавливается, то h(p(n)) должна завершить свою работу за конечное число шагов, а если p(n) останавливается, то h(p(n)) должна&amp;nbsp;зависнуть. &lt;/p&gt;
&lt;p&gt;Ну, а теперь представьте, что произойдет, если мы попробуем ответить с помощью такого анализатора на вопрос: зависнет ли он сам, в результате анализа самого себя, анализирующего самого себя (ведь p может быть любой программой из P, значит она может быть и самой h)? В этом случае получается, что если h(h(n)) остановится, то анализ h(n) зависает, а если h(h(n))) зависает, то анализ h(n) останавливается. Но ведь h как раз и есть h(n), а, следовательно, мы здесь имеем противоречие и анализатор подобный h не имеет права на&amp;nbsp;существование.&lt;/p&gt;
&lt;p&gt;Описанное является вольным изложением доказательства Теоремы останова, сформулированной Алланом Тьюрингом (основоположником современной теоретической информатики) в далеком 1936-м. Данная теорема утверждает, что не существует такой программы, которая могла бы проанализировать другую программу и ответить на вопрос, остановится ли та на заданном наборе входных данных. Хорошо, но можем ли мы построить такую программу, которая дает ответ на вопрос о каких-либо других свойствах&amp;nbsp;программ?&lt;/p&gt;
&lt;p&gt;Поскольку множество P включает в себя все возможные программы, мы всегда можем разбить его на два класса (пусть будут A и B) по признаку наличия у программ любого нетривиального инвариантного свойства. Под нетривиальным инвариантным свойством подразумевается такое свойство, которым любая программа множества P либо обладает, либо не обладает и при этом все функционально тождественные программы (дающие одни и те же наборы данных на выходе при одинаковых наборах данных на входе) либо все вместе обладают этим свойством, либо все вместе не&amp;nbsp;обладают.&lt;/p&gt;
&lt;p&gt;Давайте представим, что есть некоторый анализатор q, который принимает на вход произвольную программу p множества P и останавливается, если p относится к одному из классов. Пусть, для определенности, это будет класс A. Пусть pa - программа, относящаяся к классу A и зацикливающаяся на любом входе. Выберем также из класса B произвольную программу pb. Для каждой программы p определим программу p&amp;#8217;, получающую на вход данные x и выполняющую следующий&amp;nbsp;алгоритм:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p(p)&lt;/li&gt;
&lt;li&gt;pb(x)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Теперь построим программу q&amp;#8217;, которая получает на вход произвольную программу p, строит для нее p&amp;#8217; и вычисляет&amp;nbsp;q(p&amp;#8217;). &lt;/p&gt;
&lt;p&gt;Если p&amp;#8217; зависает на первом шаге, значит p&amp;#8217; функционально тождественна pa (и относится к классу A), а, следовательно, q&amp;#8217; должна немедленно остановиться. Если p&amp;#8217; проходит первый шаг, то p&amp;#8217; функционально тождественна pb (и относится к классу B), а, следовательно, q&amp;#8217; должна зависнуть. Таким образом, для любой программы p, q&amp;#8217;(p) останавливается тогда, когда p(p) не останавливается. Но в роли p может оказаться и сама q&amp;#8217;, следовательно, p(p) останавливается только тогда, когда p(p) не останавливается. Снова пришли к&amp;nbsp;противоречию. &lt;/p&gt;
&lt;p&gt;Утверждение о том, что не существует такой программы, которая могла бы давать ответ на вопрос о наличии любых нетривиальных инвариантных свойств у произвольно взятой программы, доказал ученый Генри Райс в 1953 году. Фактически, его работа обобщает Теорему останова, поскольку свойство останавливаться на заданном наборе данных является нетривиальным и инвариантным. Теорема Райса имеет бесконечное множество практических значений, в зависимости от рассматриваемых свойств: «невозможно с помощью программы классифицировать алгоритм, реализуемый другой программой», «невозможно с помощью программы доказать, что две других программы реализуют один и тот же алгоритм», «невозможно с помощью программы доказать, что другая программа на любых наборах данных не входит в какие-либо состояния…» и т.п. И вот на последнем примере стоит остановиться&amp;nbsp;подробнее.&lt;/p&gt;
&lt;p&gt;В момент выполнения любого (как абстрактного, так и реального) алгоритма некоей универсальной выполняющей программой (например, виртуальной машиной, эмулирующей полноценный компьютер с установленной ОС), можно взять снимок этой машины, включая состояние самой выполняемой программы в адресном пространстве машины и ее внешнего окружения, такого, как дисковые накопители, состояние внешних устройств и т.п. и позднее, восстановив его, продолжить выполнение программы с того же самого места. По сути, весь процесс выполнения любой программы, представляет собой череду сменяющихся состояний, последовательность которых как раз и определяется ее кодом. При этом, в случае наличия каких-либо ошибок в конфигурации или реализации, как самой программы, так и выполняющей ее машины, велика вероятность того, что процесс выполнения войдет в состояние, которое изначально не предполагалось&amp;nbsp;разработчиками.&lt;/p&gt;
&lt;p&gt;А что есть уязвимость? Это возможность с помощью входных данных заставить процесс выполнения войти в такое состояние, которое приведет к реализации какой-либо из угроз в отношении обрабатываемой процессом информации. Следовательно, можно определить свойство защищенности любой программы, как ее способность в каждый момент времени оставаться, вне зависимости от изначальных входных данных, в рамках заранее определенного множества допустимых состояний, определяющего политику ее безопасности. При этом, задача анализа защищенности программы очевидно сводится к анализу невозможности ее перехода в любое неразрешенное политикой безопасности состояние на произвольном наборе входных данных. То есть, к той самой задаче, алгоритмическая неразрешимость которой была давным-давно доказана Генри&amp;nbsp;Райсом.&lt;/p&gt;
&lt;p&gt;Так получается, что же… весь рынок инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt; – это индустрия обмана? В теории – да, на практике же, всё как обычно - возможны&amp;nbsp;варианты.&lt;/p&gt;
&lt;h2&gt;Теория &lt;span class="caps"&gt;SAST&lt;/span&gt; на&amp;nbsp;практике&lt;/h2&gt;
&lt;p&gt;Даже оставаясь в теоретическом поле, вполне возможно сделать несколько послаблений утверждению Райса для реальных программ, выполняющихся в реальных средах. Во-первых, в теоретической информатике под «программой» подразумевается математическая абстракция, эквивалентная машине Тьюринга (МТ) – самому мощному из вычислительных автоматов. Однако же, в реальных программах далеко не каждый фрагмент их кода эквивалентен МТ. Ниже по иерархии вычислительной мощности находятся линейно-ограниченные, стековые и конечные автоматы. Анализ защищенности двух последних вполне возможен, даже в рамках самой теоретической&amp;nbsp;теории.&lt;/p&gt;
&lt;p&gt;Во-вторых, отличительной особенностью МТ является то, что ей доступна память бесконечного размера. Именно из этой особенности вытекает невозможность получить все возможные состояния вычислительного процесса – их попросту бесконечное число. Однако, в реальных компьютерах память далеко не бесконечна. Что еще важнее, в реальных программах число состояний, представляющих интерес с точки зрения задачи анализа защищенности, также конечно (хотя и неприлично&amp;nbsp;велико).&lt;/p&gt;
&lt;p&gt;В-третьих, вычисление свойств программы по Райсу, является разрешимой проблемой для ряда малых МТ, имеющих небольшое количество состояний и возможных переходов между ними. Сложно себе представить реальную программу, имеющую от 2 до 4 состояний. Однако, такой &lt;em&gt;фрагмент&lt;/em&gt; программы представить себе гораздо&amp;nbsp;легче.&lt;/p&gt;
&lt;p&gt;Следовательно, возможен эффективный анализ отдельных фрагментов кода программы, попадающих под перечисленных критерии. На практике, это означает,&amp;nbsp;что:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;фрагмент кода без циклов и рекурсии может быть всесторонне проанализирован, т.к. эквивалентен конечному&amp;nbsp;автомату;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;фрагмент с циклами или рекурсией, условие выхода из которых не зависит от входных данных, поддается анализу в качестве конечного или стекового&amp;nbsp;автомата;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;если условия выхода из цикла или рекурсии зависят от входных данных, длина которых ограничена некоторым разумным порогом, то такой фрагмент в отдельных случаях получится проанализировать как систему линейно-ограниченных автоматов или малых&amp;nbsp;МТ.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;А вот все остальное – увы и ах − статическим подходом проанализировать не удастся. Более того, разработка анализатора защищённости исходного кода - это такое направление, работая в котором инженеры ежедневно сталкиваются с трейдофом &lt;span class="caps"&gt;EXPSPACE&lt;/span&gt; &amp;lt;-&amp;gt; &lt;span class="caps"&gt;EXPTIME&lt;/span&gt;, а сводя даже частные случаи к субэкспоненте, радуются как дети, потому что это по-настоящему круто. Подумайте над тем, какова будет мощность множества значений переменной parm1 в последней точке&amp;nbsp;выполнения?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Вот поэтому о теоретических ограничениях можно не особо беспокоиться, поскольку упереться в них на текущих вычислительных мощностях будет крайне затруднительно. Однако же, перечисленные послабления этих ограничений задают правильное направление развития современных статических анализаторов, поэтому иметь в виду их все же&amp;nbsp;стоит.   &lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAST&lt;/span&gt;, &lt;span class="caps"&gt;IAST&lt;/span&gt; и&amp;nbsp;все-все-все&lt;/h2&gt;
&lt;p&gt;В противовес статическому подходу, работающему с кодом программы без его фактического выполнения, динамический (Dynamic Application Security Testing, &lt;span class="caps"&gt;DAST&lt;/span&gt;) подразумевает наличие развернутой среды выполнения приложения и ее прогон на наиболее интересных с точки зрения анализа наборах входных данных. Упрощая, его можно охарактеризовать, как метод «осознанного научного тыка» («давайте передадим программе вот такие данные, характерные вот для такой атаки и посмотрим, что же из этого выйдет»). Его недостатки очевидны: далеко не всегда есть возможность быстро развернуть анализируемую систему (а зачастую и просто собрать), переход системы в какое-либо состояние может быть следствием обработки предыдущих наборов данных, да и для всестороннего анализа поведения реальной системы количество наборов входных данных должно быть настолько велико, что о его конечности можно рассуждать исключительно&amp;nbsp;теоретически.&lt;/p&gt;
&lt;p&gt;Относительно недавно перспективным считался подход, комбинирующий преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt; – интерактивный анализ (Interactive…, &lt;span class="caps"&gt;IAST&lt;/span&gt;). Отличительной особенностью этого подхода является то, что &lt;span class="caps"&gt;SAST&lt;/span&gt; используется для формирования наборов входных данных и шаблонов ожидаемых результатов, а &lt;span class="caps"&gt;DAST&lt;/span&gt; выполняет тестирование системы на этих наборах, опционально привлекая к процессу человека-оператора в неоднозначных ситуациях. Ирония этого подхода заключается в том, что он вобрал в себя как преимущества, так и недостатки &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, что не могло не сказаться на его практической&amp;nbsp;применимости.&lt;/p&gt;
&lt;p&gt;Но кто сказал, что в случае динамического анализа нужно выполнять всю программу целиком? Как было показано выше, вполне реально проанализировать значительную часть кода с помощью статического подхода. Что же мешает проанализировать с помощью динамического только оставшиеся фрагменты? Звучит, как&amp;nbsp;план…&lt;/p&gt;
&lt;h2&gt;А внутре у ней&amp;nbsp;неонка&lt;/h2&gt;
&lt;p&gt;Существует несколько традиционных подходов к статическому анализу, отличающихся моделью, на основе которой анализатор выводит те или иные свойства исследуемого кода. Самым примитивным и очевидным является сигнатурный поиск, основанный на поиске вхождений какого-либо шаблона в синтаксическую модель представления кода (как правило, это либо поток токенов, либо абстрактное синтаксическое дерево). Отдельные реализации этого подхода используют чуть более сложные модели (семантическое дерево, его отображение на граф отдельных потоков данных и т.п.), но в целом этот подход можно рассматривать исключительно в качестве вспомогательного, позволяющего за линейное время выделить в коде подозрительные места для последующей ручной верификации. Подробнее останавливаться на нём не будем, интересующиеся могут обратиться к посвященной ему &lt;a href="https://habrahabr.ru/company/pt/blog/300946/"&gt;серии статей&lt;/a&gt; Ивана&amp;nbsp;Кочуркина.&lt;/p&gt;
&lt;p&gt;Более сложные подходы оперируют уже моделями выполнения (а не представления или семантики) кода. Такие модели, как правило, позволяют получить ответ на вопрос &amp;#8220;может ли контролируемый извне поток данных достичь какой-либо точки выполнения, в которой это приведет к возникновению уязвимости?&amp;#8221;. В большинстве случаев, модель здесь представляет собой вариацию на тему графов &lt;a href="https://en.wikipedia.org/wiki/Control_flow_graph"&gt;потока выполнения&lt;/a&gt; и &lt;a href="https://en.wikipedia.org/wiki/Data_flow_diagram"&gt;потоков данных&lt;/a&gt;, либо их комбинацию (например, &lt;a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf"&gt;граф свойств кода&lt;/a&gt;). Недостаток подобных подходов также очевиден - в любом нетривиальном коде одного только ответа на этот вопрос недостаточно для успешного детектирования уязвимости. Например, для&amp;nbsp;фрагмента:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filteredParam&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;такой анализатор выведет из построенной модели утвердительный ответ о достижимости потоком данных &lt;code&gt;Request.Params["param"]&lt;/code&gt; точки выполнения &lt;code&gt;Response.Write(filteredParam)&lt;/code&gt; и существовании в данной точке уязвимости к &lt;span class="caps"&gt;XSS&lt;/span&gt;. В то время, как на самом деле, данный поток эффективно фильтруется и не может являться носителем вектора атаки. Существует множество способов покрыть частные случаи, связанные с предварительной обработкой потоков данных, но все они в конечном итоге сводятся к разумному балансу между ложными срабатываниями первого и второго&amp;nbsp;типа.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Type 1 &amp;amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Каким образом можно минимизировать появление ошибок обоих типов? Для этого необходимо учитывать условия достижимости как потенциально уязвимых точек выполнения, так и множеств значений потоков данных, приходящих в такие точки. На основе этой информации становится возможным построить систему уравнений, множество решений которой даст все возможные наборы входных данных, необходимые для того, чтобы прийти в потенциально уязвимую точку программы. Пересечение этого множества со множеством всех возможных векторов атаки, даст множество всех наборов входных данных, приводящих программу в уязвимое состояние. Звучит отлично, но как получить модель, которая содержала бы всю необходимую&amp;nbsp;информацию?&lt;/p&gt;
&lt;h2&gt;Абстрактная интерпретация и символические&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Допустим, перед нами стоит задача определить, число с каким знаком определяет выражение &lt;code&gt;-42 / 8 * 100500&lt;/code&gt;. Самый простой способ - это вычислить данное выражение и убедиться, что получено отрицательное число. Вычисление выражения с вполне определенными значениями всех его аргументов называется конкретным вычислением. Но есть и другой способ решить эту задачу. Давайте на секунду представим, что по какой-то причине у нас нет возможности конкретно вычислить данное выражение. Например, если в него добавилась переменная &lt;code&gt;-42 / 8 * 100500 * x&lt;/code&gt;. Определим абстрактную арифметику, в которой результат операций над числами определяется исключительно правилом знака, а значения их аргументов&amp;nbsp;игнорируются:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(+a) = (+)
(-a) = (-)
(-) * (+) = (-)
(-) / (+) = (-)  
...
(-) + (+) = (+-)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Интерпретируя исходное выражение в рамках данной семантики, получаем: &lt;code&gt;(-) / (+) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-)&lt;/code&gt;. Этот подход будет давать однозначный ответ на поставленную задачу до тех пор, пока в выражении не появятся операции сложения или вычитания. Давайте дополним нашу арифметику таким образом, чтобы значения аргументов операций также&amp;nbsp;учитывались:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(-a) * (+b) = (-c)
(-a) / (+b) = (-c)  
...
(-a) + (+b) = 
    a &amp;lt;= b -&amp;gt; (+)
    a &amp;gt;  b -&amp;gt; (-)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Интерпретируя выражение &lt;code&gt;-42 / 8 * 100500 + x&lt;/code&gt; в новой семантике получим результат &lt;code&gt;x &amp;gt;= -527625 -&amp;gt; (+), x &amp;lt; -527625 -&amp;gt; (-)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Описанный выше подход называется &lt;a href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;абстрактной интерпретацией&lt;/a&gt; и формально определяется, как устойчивая аппроксимация семантики выражений, основанная на монотонных функциях над упорядоченными множествами. Говоря более простым языком, это интерпретация выражений без их конкретного вычисления с целью сбора информации в рамках заданного семантического поля. Если мы плавно перейдем от интерпретации отдельных выражений к интерпретации кода программы на каком-либо языке, а в качестве семантического поля определим семантику самого языка, дополненную правилом оперировать всеми входными данными, как неизвестными переменными (символическими значениями), то мы получим подход, именуемый &lt;a href="https://en.wikipedia.org/wiki/Symbolic_execution"&gt;&amp;#8220;символическим выполнением&amp;#8221;&lt;/a&gt; и лежащий в основе большинства перспективных направлений статического анализа&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Именно с помощью символических вычислений становится возможным построение контекстного графа символического вычисления (альтернативное название: граф потока вычислений) - модели, всесторонне описывающей процесс вычисления исследуемой программы. Эта модель была рассмотрена в докладе &lt;a href="http://www.slideshare.net/kochetkov.vladimir/ss-48743308/14"&gt;&amp;#8220;Автоматическая генерация патчей для исходного кода&amp;#8221;&lt;/a&gt;, а ее применение для анализа защищенности кода - в статье &lt;a href="https://habrahabr.ru/company/pt/blog/224547/"&gt;&amp;#8220;Об анализе исходного кода и автоматической генерации эксплоитов&amp;#8221;&lt;/a&gt;. Вряд ли имеет смысл рассматривать их повторно в рамках данной статьи. Необходимо лишь отметить, что эта модель позволяет получить условия достижимости как любой точки потока выполнения, так и множеств значений всех приходящих в нее аргументов. То есть - именно то, что требуется нам для решения нашей&amp;nbsp;задачи.&lt;/p&gt;
&lt;h2&gt;Поиск уязвимостей на графе потока&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Формализовав в терминах графа потока вычислений критерии уязвимости к тому или иному классу атак, мы сможем реализовать анализ защищенности кода через разрешение свойств конкретной модели, полученной в результате абстрактной интерпретации исследуемого кода. Например, критерии уязвимости к атакам любых инъекций (SQLi, &lt;span class="caps"&gt;XSS&lt;/span&gt;, XPATHi, Path Traversal и т.п.) можно формализовать примерно&amp;nbsp;так:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Пусть C - граф потока вычисления исследуемого&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Пусть pvf(t) - достижимая вершина потока управления на C, являющаяся вызовом функции прямой или косвенной интерпретации текста t, соответствующего формальной грамматике&amp;nbsp;G.&lt;/p&gt;
&lt;p&gt;Пусть e - поток аргумента входных данных на&amp;nbsp;С. &lt;/p&gt;
&lt;p&gt;Пусть De - множество потоков данных на C, порождаемых от e и достижимых в точке вызова&amp;nbsp;pvf(t).&lt;/p&gt;
&lt;p&gt;Тогда приложение уязвимо к атакам инъекции в точке вызова pvf(t), если t принадлежит De и множество значений De включает в себя хотя бы одну пару элементов, при которых, в результате их синтаксического разбора в соответствии с грамматикой G, получаются не изоморфные друг-другу&amp;nbsp;деревья.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Аналогичным образом формализуются уязвимости и к другим классам атак. Однако, здесь необходимо заметить, что не все типы уязвимостей возможно формализовать в рамках какой-либо модели, выводимой только из анализируемого кода. В отдельных случаях может потребоваться дополнительная информация. Например, для формализации уязвимостей к атакам на бизнес-логику, необходимо иметь формализованные правила предметной области приложения, для формализации уязвимостей к атакам на контроль доступа - формализованную политику разграничения доступа и&amp;nbsp;т.п.&lt;/p&gt;
&lt;h2&gt;Идеальный сферический анализатор защищенности кода в&amp;nbsp;вакууме&lt;/h2&gt;
&lt;p&gt;Давайте теперь ненадолго отвлечемся от суровой реальности и чуть-чуть помечтаем о том, какой функциональностью должно обладать ядро гипотетического Идеального Анализатора (назовем его условно &amp;#8220;&lt;span class="caps"&gt;IA&lt;/span&gt;&amp;#8221;)?&lt;/p&gt;
&lt;p&gt;Во-первых, оно должно вбирать в себя преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, не включая при этом их недостатки. Из этого в частности следует, что &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь работать исключительно с имеющимся кодом приложения (исходным или бинарным), не требуя при этом его полноты или развертывания приложения в исполняющей среде. Иными словами, он должен поддерживать анализ проектов с отсутствующими внешними зависимостями или же какими-либо другими факторами, препятствующими сборке и развертыванию приложения. При этом, работа с фрагментами кода, имеющего ссылки на отсутствующие зависимости, должна быть реализована в настолько полной мере, насколько это возможно в каждом конкретном случае. С другой стороны, &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь эффективно &amp;#8220;уворачиваться&amp;#8221; не только от теоретических ограничений, накладываемых тьюринговой моделью вычислений, но и осуществлять сканирование за разумное время, потребляя разумное количество памяти и придерживаясь по возможности субэкспоненциальной &amp;#8220;весовой&amp;nbsp;категории&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Во-вторых, вероятность появления ошибок первого рода должна быть сведена к минимуму за счет построения и решения систем логических уравнений и генерации на выходе работающего вектора атаки, позволяющего пользователю подтвердить существование уязвимости одним&amp;nbsp;действием. &lt;/p&gt;
&lt;p&gt;В-третьих, &lt;span class="caps"&gt;IA&lt;/span&gt; должен эффективно бороться с ошибками второго рода, предоставляя пользователю возможность ручной проверки всех потенциально уязвимых точек потока выполнения, уязвимость которых сам &lt;span class="caps"&gt;IA&lt;/span&gt; не смог ни подтвердить, ни&amp;nbsp;опровергнуть.&lt;/p&gt;
&lt;p&gt;Использование модели, основанной на символических вычислениях, позволяет реализовать все эти требования, что называется &amp;#8220;by-design&amp;#8221;, за исключением той их части, которая касается теоретических ограничений и субэкспонент. И здесь, как нельзя кстати, придется наш план - использовать динамический анализ там, где не справился&amp;nbsp;статический. &lt;/p&gt;
&lt;h2&gt;Частичные вычисления, обратные функции и отложенная&amp;nbsp;интерпретация&lt;/h2&gt;
&lt;p&gt;Представьте себе, что &lt;span class="caps"&gt;IA&lt;/span&gt; содержит в себе некоторую базу знаний, описывающую семантику функций преобразования входных данных, реализованных в стандартной библиотеке языка или исполняющей среды приложения, наиболее популярных фреймворках и &lt;span class="caps"&gt;CMS&lt;/span&gt;. Например, что функции Base64Decode и Base64Encode являются взаимно-обратными, или что каждый вызов StringBuilder.Append добавляет новую строку к уже хранящейся в промежуточной переменной-аккумуляторе этого класса и т.п. Обладая такими знаниями &lt;span class="caps"&gt;IA&lt;/span&gt; будет избавлен от необходимости «проваливаться» в библиотечный код, анализ которого также попадает под все вычислительные&amp;nbsp;ограничения:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Нужное для выполнения условия значение для cond2 будет выведено солвером на основе информации базы знаний об обратных функциях &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// Значение sb.ToString будет получено в результаты эмуляции семантики StringBuilder, описанной в базе знаний библиотечных функций&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Но что делать, если в коде встречается вызов функции, не описанной в базе знаний &lt;span class="caps"&gt;IA&lt;/span&gt;? Давайте представим, что в распоряжении &lt;span class="caps"&gt;IA&lt;/span&gt; есть некая виртуальная среда-песочница, позволяющая запустить произвольный фрагмент анализируемого кода в заданном контексте и получить результат его выполнения. Назовём это &amp;#8220;частичным вычислением&amp;#8221;. Тогда, перед тем, как честно «провалиться» в неизвестную функцию и начинать её абстрактно интерпретировать, &lt;span class="caps"&gt;IA&lt;/span&gt; может попробовать проделать трюк, называемый «частичным фаззингом». Его общая идея заключается в предварительной подготовке базы знаний по библиотечным трансформирующим функциям и сочетаниям их последовательных вызовов на заранее известных наборах пробных данных. Имея такую базу, можно выполнить неизвестную функцию на тех же наборах данных и сравнить полученные результаты с образцами из базы знаний. Если результаты выполнения неизвестной функции совпадут с результатами выполнения известной цепочки библиотечных функций, то это будет значить, что &lt;span class="caps"&gt;IA&lt;/span&gt; теперь известна семантика неизвестной функции и в ее интерпретации нет&amp;nbsp;необходимости.&lt;/p&gt;
&lt;p&gt;Если же для какого-то фрагмента известны множества значений всех потоков данных, приходящих в этот фрагмент, а сам фрагмент не содержит опасных операций, то &lt;span class="caps"&gt;IA&lt;/span&gt; может просто выполнить его на всех возможных потоках данных и использовать полученные результаты вместо абстрактной интерпретации данного фрагмента кода. Причем этот фрагмент может относиться к любому классу вычислительной сложности и это никак не отразится на результатах его выполнения. Более того, даже если множества значений потоков данных, приходящих во фрагмент, заранее неизвестны, &lt;span class="caps"&gt;IA&lt;/span&gt; может отложить интерпретацию этого фрагмента до тех пор, пока не начнется решение уравнения для конкретной опасной операции. На этапе решения на множество значений входных данных накладывается дополнительное ограничение о наличии во входных данных векторов тех или иных атак, что может позволить предположить также и множество значений входных данных, приходящих в отложенный фрагмент и, тем самым, частично вычислить его на данном&amp;nbsp;этапе.&lt;/p&gt;
&lt;p&gt;Даже более того, на этапе решения ничего не мешает &lt;span class="caps"&gt;IA&lt;/span&gt; взять конечную формулу достижимости опасной точки и ее аргументов (которую проще всего строить в синтаксисе и семантике того же языка, на котором написан анализируемый код) и &amp;#8220;профаззить&amp;#8221; ее всеми известными значениями векторов на предмет получения их подмножества, проходящего через все фильтрующие функции&amp;nbsp;формулы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Ззначение аргумента Response.Write, проходящее через фильтрующую функцию без изменений, может быть получено в результате фаззинга его формулы постановкой в parm1 значений всех возможных векторов XSS &lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Описанные выше подходы позволяют справиться с анализом значительной части фрагментов тьюринг-полного кода, но требуют существенной инженерной проработки как в части наполнения базы знаний и оптимизации эмулирования семантики стандартных типов, так и в части реализации песочницы для частичного выполнения кода (никто не захочет, чтобы в процессе анализа внезапно выполнилось что-то вроде File.Delete в цикле), а также поддержки фаззинга n-местных неизвестных функций, интеграции концепции частичного вычисления с &lt;span class="caps"&gt;SMT&lt;/span&gt;-солвером и т.п. Однако же, никаких существенных ограничений на их реализацию нет, в отличии от граблей классического &lt;span class="caps"&gt;SAST&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Когда гадкий duck-typing становится&amp;nbsp;лебедем&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Представьте, что нам необходимо проанализировать следующий&amp;nbsp;код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// UnknownType - тип, объявленный в отсутствующей зависимости &lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Человек без труда увидит здесь достижимую уязвимость к &lt;span class="caps"&gt;XSS&lt;/span&gt;. А вот большинство существующих статических анализаторов ее благополучно прошляпят в связи с тем, что им ничего не известно о типе UnknownType. Однако все, что здесь требуется от &lt;span class="caps"&gt;IA&lt;/span&gt; - это забыть о статической типизации и перейти к утиной. Семантика интерпретации таких конструкций должна полностью зависеть от контекста их использования. Да, интерпретатор ничего не знает о том, чем является &lt;code&gt;UnknownType.Property1&lt;/code&gt; - свойством, полем, или даже делегатом (ссылкой на метод в C#). Но поскольку операции с ней осуществляются как с переменной-мембером какого-то типа, интерпретатору ничего не мешает обрабатывать их именно таким образом. А если, к примеру, далее по коду встретится конструкция &lt;code&gt;UnknownType.Property1()&lt;/code&gt;, то ничто не мешает интерпретировать вызов того метода, ссылка на который была ранее присвоена Property1. И так далее, в лучших традициях заводчиков&amp;nbsp;уток-чемпионов.&lt;/p&gt;
&lt;h2&gt;Подводя&amp;nbsp;итоги&lt;/h2&gt;
&lt;p&gt;Разумеется, есть масса маркетинговых свистелок, которыми один анализатор якобы выгодно отличается от другого, с точки зрения продающей его стороны. Но, согласитесь, в них нет никакого проку, если ядро продукта не в состоянии обеспечить базовую функциональность, ради которой его и будут использовать. А для того, чтобы её обеспечить, анализатор обязан стремиться по своим возможностям к описанному &lt;span class="caps"&gt;IA&lt;/span&gt;. Иначе ни о какой реальной защищенности на обрабатываемых им проектах и речи быть не&amp;nbsp;может. &lt;/p&gt;
&lt;p&gt;Несколько лет назад, один из наших клиентов обратился к нам за проведением анализа защищенности разрабатываемой им системы. В числе вводных данных он предоставил отчет об анализе кода их проекта продуктом, являвшимся на тот момент лидером на рынке &lt;span class="caps"&gt;SAST&lt;/span&gt;-инструментария. Отчет содержал около двух тысяч записей, большинство из которых оказались в итоге на проверку положительно-ложными срабатываниями. Но самым плохим оказалось то, чего не было в отчете. В результате ручного анализа кода, нами были обнаружены десятки уязвимых мест, пропущенных при сканировании. Использование подобных анализаторов приносит больше вреда, чем пользы, как отнимая время, необходимое для разбора всех ложно-положительных результатов, так и создавая иллюзию защищённости из-за ложно-отрицательных. Этот случай, кстати, стал одной из причин разработки нами собственного&amp;nbsp;анализатора.&lt;/p&gt;
&lt;h2&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Talk is cheap. Show me the&amp;nbsp;code.&amp;#8221;&lt;/h2&gt;
&lt;p&gt;Было бы странным не завершить статью небольшим примером кода, позволяющим проверить степень идеальности того или иного анализатора на практике. Voila - ниже представлен код, включающий в себя все базовые кейсы, покрываемые описанным подходом к абстрактной интерпретации, но не покрываемые более примитивными подходами. Каждый кейс реализован настолько тривиально, насколько это возможно и с минимальным количеством инструкций языка. Это пример для C#/&lt;span class="caps"&gt;ASP&lt;/span&gt;.Net WebForms, но не содержит какой-либо специфики и легко может быть транслирован в код на любом другом ООП-языке и под любой&amp;nbsp;web-фреймворк. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ZmFsc2U=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;false&amp;quot; в base64-кодировке&lt;/span&gt;
&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pvo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// False-negative&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не интерпретирующие поток выполнения по потокам данных функционального типа, не сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;pvo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Для анализаторов, требующих компилируемый код, этот фрагмент необходимо удалить&lt;/span&gt;
&lt;span class="cp"&gt;#region&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, игнорирующие некомпилируемый код, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endregion&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие условия достижимости точек выполнения, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WebUtility&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HtmlEncode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику нестандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="c1"&gt;// (CustomFilter.Filter реализует логику `s.Replace(&amp;quot;&amp;lt;&amp;quot;, string.Empty).Replace(&amp;quot;&amp;gt;&amp;quot;, string.Empty)`)&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных кодирующих функций, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="m"&gt;1725&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, аппроксимирующие или игнорирующие интерпретацию циклов, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не интерпретирующие семантику типов стандартной библиотеки, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Результатом анализа данного кода должно являться сообщение о единственной уязвимости к атакам &lt;span class="caps"&gt;XSS&lt;/span&gt; в выражении &lt;code&gt;pvo(parm1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Вступить и компилировать с готовым к сканированию проектом можно &lt;a href="https://kochetkov.github.io/uploads/IAMeter.zip"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но, как говорится, &amp;#8220;лучше один раз увидеть&amp;#8230;&amp;#8221; и, в первую очередь, мы проверили на соответствие &lt;span class="caps"&gt;IA&lt;/span&gt; разрабатываемый нами анализатор, по чистой случайности называющийся &lt;a href="http://ai.ptsecurity.ru/"&gt;&lt;span class="caps"&gt;AI&lt;/span&gt;&lt;/a&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А вы - уже проверили свой?&amp;nbsp;;)&lt;/p&gt;
&lt;h2&gt;На правах бонуса для дочитавших до&amp;nbsp;конца&lt;/h2&gt;
&lt;p&gt;Мы открываем публичное альфа-тестирование бесплатной утилиты Approof. В нее не включена функциональность анализа кода и не используется весь описанный выше матастафический хардкор, зато включена функциональность выявления в проектах уязвимых внешних компонентов, недостатков конфигурации, чувствительных к разглашению данных, а также внедренных веб-шеллов и вредоносного&amp;nbsp;кода:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png" /&gt;&lt;/p&gt;
&lt;p&gt;Скачать утилиту можно на &lt;a href="http://approof.ptsecurity.ru/"&gt;официальном сайте&lt;/a&gt;. Перед ее использованием обязательно ознакомьтесь с лицензионным соглашением. В ходе анализа, Approof собирает неконфиденциальную статистику по проекту (&lt;span class="caps"&gt;CLOC&lt;/span&gt;, типы файлов, используемые фреймворки и т.к.) и, опционально, отправляет ее на сервер &lt;span class="caps"&gt;PT&lt;/span&gt;. Отключить отправку статистики или ознакомиться с сырым json, содержащим собранные данные, можно в разделе About&amp;nbsp;приложения.&lt;/p&gt;</summary><category term="SAST"></category><category term="DAST"></category><category term="IAST"></category><category term="статический анализ кода"></category><category term="анализатор кода"></category><category term="static code analysis"></category><category term="Application Inspector"></category></entry><entry><title>По следам PHDays VI</title><link href="https://kochetkov.github.io/following-the-tracks-of-phdays-6.html" rel="alternate"></link><published>2016-06-01T04:00:00+03:00</published><updated>2016-06-01T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-06-01:following-the-tracks-of-phdays-6.html</id><summary type="html">&lt;p&gt;&lt;a href="http://phdays.ru"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз &lt;a href="http://www.ptsecurity.ru/products/ai/"&gt;Application Inspector&lt;/a&gt; нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас. &lt;/p&gt;
&lt;p&gt;Внезапно, обещание пропустить все доклады выполнилось само собой и большую часть времени я провел за кулисами, либо очищая &lt;span class="caps"&gt;AI&lt;/span&gt; от лишних фич и готовясь к своему выступлению в промежутках между прогонами тестов, либо выступая на закрытой встрече нашей новой девелоперской юзергруппы, о которой расскажу ниже. В итоге, чуть менее, чем вся конференция для меня выглядела как-то&amp;nbsp;так: &lt;/p&gt;
&lt;p&gt;&lt;img alt="PHDays VI глазами Вовы" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/1.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Ни за какими конкурсами я не наблюдал и тем более в них не участвовал (а в окрестностях &lt;span class="caps"&gt;CTF&lt;/span&gt;-зоны вообще появлялся лишь на пару минут и только для того, чтобы урвать себе немного космической еды), с вендорскими ништяками пролетел, во всех форках afterparty не участвовал и т.п. Развиртуализировался (ненавижу это слово) с несколькими френдами / подписчиками, что для интроверта уже немеряный подвиг. Наложил кирпичей, когда мимо меня, прямо за кулисами, несколько раз прошуршал  (ряженый, как выяснилось сильно позже) ОМОН в составе 4&amp;nbsp;бойцов.&lt;/p&gt;
&lt;p&gt;Однако же, гвоздем программы для меня стало мероприятие, проводившееся за ее рамками. Как я уже &lt;a href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html"&gt;писал&lt;/a&gt; ранее, в ходе конференции мы планировали провести первую встречу нашей новой пользовательской юзергруппы девелоперов, интересующихся вопросами разработки защищенных приложений и предметной области application security. В ходе нее планировалось провести сокращенный вариант прошлогоднего мастер-класса для разработчиков банковских приложений. В результате - встреча состоялась, мастер-класс проведен и по полученным отзывам можно с уверенностью сказать, что юзергруппе - быть. В относительно ближайшее время, мы планируем провести еще несколько оффлайн-встреч и вебинаров, посвященных тематике группы. В том числе, и с приглашением сторонних экспертов в различных областях и направлениях, связанных с application security. На встрече разработчики аккуратно получали около 6 часов живительного хардкора о теории и всевозможных практических аспектах проектирования и разработки защищенных приложений от&amp;nbsp;/me:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый /me" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;а поддерживать интерес аудитории мне помогал мой коллега Леша Гончаров, развлекавший народ задачками на ненормальный кодинг и раздававший печеньки особо&amp;nbsp;отличившмся:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Леша" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/3.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;В конце встречи мы анонсировали бесплатную утилиту от команды &lt;span class="caps"&gt;AI&lt;/span&gt; с рабочим названием Approof, позволяющую провести сканирование исходного кода проекта на предмет ошибок конфигурации и использования уязвимых компонентов. Участники встречи получили ее альфа-версию, а в скором времени, она будет доступна для загрузки всем&amp;nbsp;желающим. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Approof" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/4.png" /&gt;&lt;/p&gt;
&lt;p&gt;Должен заметить, что на встрече я столкнулся с самой живой аудиторией из всех, встречавшихся мне на докладах, митапах и вебинарах. Была масса вопросов, кулуларных обсуждений, со мной пытались спорить и даже помогали вести встречу, отвечая участникам на вопросы, адресованные мне. Один из участников упрекнул нашу компанию в том, что мы даем владельцам веб-приложений слишком жесткие рекомендации по усилению content security policy, которые им, компаниям-разработчикам, потом тяжело выполнять (не зря работаем, значит). На второй день из более, чем полусотни слушателей отсеялось лишь около десятка человек, что как бы намекает. Слайды не выкладываю, т.к. они большей частью являются компиляцией ранее публиковавшихся выступлений и представляют интерес только для участников встречи, которые их и так получили по окончанию мероприятия вместе со всей&amp;nbsp;раздаткой.&lt;/p&gt;
&lt;p&gt;Но, в конечном счете, впечатления от конференции сугубо позитивные, хоть она и прошла для меня в достаточно своеобразном формате, повторять который - лично мне бы не&amp;nbsp;хотелось)&lt;/p&gt;</summary><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Семинар Positive Development User Group</title><link href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html" rel="alternate"></link><published>2016-05-06T00:00:00+03:00</published><updated>2016-05-06T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-05-06:phdays6-positive-development-user-group-workshop.html</id><summary type="html">&lt;p&gt;Идея разработки по-настоящему-полезного-курса-по-разработке-защищенных-приложений-на-котором-не-захочется-спать зародилась в Positive Technologies еще в 2012 году, после проведения серии закрытых вебинаров на эту тему для разработчиков наших партнеров. Позднее, в 2013-ом, на PHDays &lt;span class="caps"&gt;III&lt;/span&gt; был представлен &lt;a href="http://www.slideshare.net/kochetkov.vladimir/hdswasm-russianproofreaded"&gt;воркшоп&lt;/a&gt;, построенный на их материалах. Следующие пару лет, отдельные его фрагменты использовались в различных докладах и курсах, а контент постоянно перерабатывался и дополнялся новыми разделами. Осенью 2015-го, мы с Тимуром Юнусовым объединили свои наработки и провели &lt;a href="https://habrahabr.ru/company/pt/blog/271287/"&gt;двухдневный мастер-класс&lt;/a&gt; для разработчиков банковских приложений. Его изюминкой стала непрерывная смена offensive и defensive направлений рассматриваемых тем. Тимур показывал типовые ошибки разработчиков и их последствия с точки зрения нападающего, а я объяснял, как не допускать их в новом коде и правильно устранять в уже&amp;nbsp;существующем.&lt;/p&gt;
&lt;p&gt;И, поскольку засыпающих в ходе мастер-класса отмечено не было, а отзывы о нем были получены сугубо положительные, мы решили выступить на бис и провести его сокращенный вариант повторно на предстоящей конференции &lt;a href="http://www.phdays.ru/"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt;. И не просто выступить, а в рамках первой (и, как мы надеемся, не последней) встречи Positive Development User Group - сообщества разработчиков, интересующихся предметной областью безопасности приложений. Мероприятие будет проводиться вне основной программы конференции в закрытом формате по персональным приглашениям. Заявку на участие можно заполнить &lt;a href="http://goo.gl/forms/rPIlrPeZBk"&gt;здесь&lt;/a&gt;. С программой и расписанием семинара можно ознакомиться в &lt;a href="https://goo.gl/ZIRUR0"&gt;официальном пресс-релизе мероприятия&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;P.S: И да - у нас будут печеньки&amp;nbsp;:) &lt;/p&gt;</summary><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Переезд блога</title><link href="https://kochetkov.github.io/blog-movement.html" rel="alternate"></link><published>2015-12-15T10:45:00+03:00</published><updated>2015-12-15T10:45:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-12-15:blog-movement.html</id><summary type="html">&lt;p&gt;Давно собирался перенести свой блог с Blogger и наконец сделал это. Со временем, перенесу все хорошие статьи оттуда. Новые статьи будут опубликованы только&amp;nbsp;здесь.&lt;/p&gt;</summary><category term="блог"></category></entry><entry><title>По следам вебинара “Прикладная теория Application Security”</title><link href="https://kochetkov.github.io/webinar-applied-theory-of-the-application-security.html" rel="alternate"></link><published>2015-11-14T00:00:00+03:00</published><updated>2015-11-14T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-11-14:webinar-applied-theory-of-the-application-security.html</id><summary type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления, на ходу подбирая нужные фразы и пояснения. Посему приношу извинения тем слушателям, которые так и не поняли, что это было. Вероятно в ближайшие месяцы, проведу работу над ошибками в формате статьи или серии заметок, дабы донести основные идеи более внятным и последовательным&amp;nbsp;образом.&lt;/p&gt;
&lt;p&gt;На вебинаре я обещал дать ссылки на несколько статей о символическом исполнении, абстрактной интерпретации и т.п. Поступим проще. Вот &lt;a href="https://www.dropbox.com/sh/sqln21ngapchx3l/AADiJqQuA1U8F4jX3tYly-q9a?dl=0"&gt;здесь&lt;/a&gt; лежит подборка материалов на эти и смежные темы, которые мы в той или иной мере использовали при работе над Application Inspector. Будут вопросы - задавайте в&amp;nbsp;комментариях.&lt;/p&gt;
&lt;p&gt;Что касается книг для дальнейшего чтения, то конкретно по теории есть не так уж и много материалов и практически все мне известные можно собрать по крупицам из подборки выше. Стоит отдельно отметить выступление Meredith L. Patterson, Sergey Bratus на 28C3 в 2011 (&lt;a href="http://www.youtube.com/watch?v=3kEfedtQVOY"&gt;видео&lt;/a&gt;, &lt;a href="http://langsec.org/insecurity-theory-28c3.pdf"&gt;слайды&lt;/a&gt;) и &lt;a href="http://nob.cs.ucdavis.edu/bishop/notes/2008-cse-14/2008-cse-14.pdf"&gt;работу&lt;/a&gt; Matt Bishop с коллегами, которую я упоминал на&amp;nbsp;вебинаре.&lt;/p&gt;
&lt;p&gt;Если говорить о практике, то мой &lt;span class="caps"&gt;TOP&lt;/span&gt; 5 книг, обязательных к прочтению на данную тему следующий (порядок&amp;nbsp;произвольный):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Writing Secure Code, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nostarch.com/tangledweb.htm"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Tangled Web. A Guide to Securing Modern Web&amp;nbsp;Applications&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118026470.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Web Application Hacker&amp;#8217;s Handbook: Finding and Exploiting Security Flaws, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118662091.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Browser Hacker&amp;#8217;s&amp;nbsp;Handbook&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-047008023X.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Shellcoder&amp;#8217;s Handbook: Discovering and Exploiting Security Holes, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Собственно, серию &amp;#8220;Handbooks&amp;#8221; данного издательства стоит прочесть&amp;nbsp;всю.&lt;/p&gt;
&lt;p&gt;P.S: Коллегам по конкурирующему цеху: парни, согласитесь, что обсуждать технические вопросы реализации Application Inspector на вебинаре, связанном с ним лишь косвенно - не вполне корректно по отношению к остальным слушателям. Я всегда готов делиться той информацией, которой имею право делиться со всеми, кто попросит. Даже с конкурентами, причем даже с теми конкурентами, руководство которых находится со мной в контрах. И для этого совсем не нужно дожидаться вебинара с моим участием, как повода задать интересующие вас вопросы :) Мои контакты доступны - пишите, звоните, буду рад пообщаться. Я&amp;nbsp;серьезно.&lt;/p&gt;</summary><category term="вебинары"></category></entry></feed>