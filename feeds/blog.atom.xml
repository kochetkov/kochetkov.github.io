<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>'';!--"&lt;kochetkov.vladimir&gt;=&amp;{()} - Блог</title><link href="https://kochetkov.github.io/" rel="alternate"></link><link href="https://kochetkov.github.io/feeds/blog.atom.xml" rel="self"></link><id>https://kochetkov.github.io/</id><updated>2020-02-25T14:00:00+03:00</updated><entry><title>Мечтают ли WAF’ы о статанализаторах</title><link href="https://kochetkov.github.io/do-wafs-dream-of-static-analyzers.html" rel="alternate"></link><published>2017-09-20T12:00:00+03:00</published><updated>2020-02-25T14:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2017-09-20:/do-wafs-dream-of-static-analyzers.html</id><summary type="html">&lt;p&gt;Одна из самых популярных тенденций в области защиты приложений нынешнего десятилетия — технология виртуального патчинга (virtual patching, &lt;span class="caps"&gt;VP&lt;/span&gt;), позволяющая защитить веб-приложение от эксплуатации имеющихся в нем известных уязвимостей на уровне межсетевого экрана уровня веб-приложений (web application firewall; здесь и далее под &lt;span class="caps"&gt;WAF&lt;/span&gt; подразумевается выделенное решение, функционирующее на отдельном узле, между шлюзом во внешнюю сеть и веб-сервером). Технология &lt;span class="caps"&gt;VP&lt;/span&gt; основана на построении правил фильтрации &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; по результатам работы средств статического анализа защищенности приложения (static application security testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;). Однако из-за того, что средства &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; опираются на различные модели представления приложения и различные методы принятия решений, на рынке до сих пор нет по-настоящему эффективных решений их интеграции. В рамках &lt;span class="caps"&gt;SAST&lt;/span&gt; работа с приложением осуществляется по модели белого ящика и, как правило, используются формальные подходы к поиску уязвимостей в коде. Для &lt;span class="caps"&gt;WAF&lt;/span&gt; же приложение представляет собой черный ящик, а для детектирования атак применяются эвристики. Это не позволяет эффективно использовать &lt;span class="caps"&gt;VP&lt;/span&gt; для защиты от атак в тех случаях, когда условия эксплуатации уязвимости выходят за рамки тривиальной схемы &lt;code&gt;http_parameter=plain_text_attack_vector&lt;/code&gt;. Но что, если «подружить» &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; таким образом, чтобы информация о внутреннем устройстве приложения, полученная с помощью &lt;span class="caps"&gt;SAST&lt;/span&gt;, стала доступной на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; и дала ему возможность детектировать атаки на обнаруженные уязвимости — не угадывая, но доказывая факт&amp;nbsp;атаки?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/title-picture.png"&gt;&lt;img alt="Титульная картинка" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/title-picture.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Одна из самых популярных тенденций в области защиты приложений нынешнего десятилетия — технология виртуального патчинга (virtual patching, &lt;span class="caps"&gt;VP&lt;/span&gt;), позволяющая защитить веб-приложение от эксплуатации имеющихся в нем известных уязвимостей на уровне межсетевого экрана уровня веб-приложений (web application firewall; здесь и далее под &lt;span class="caps"&gt;WAF&lt;/span&gt; подразумевается выделенное решение, функционирующее на отдельном узле, между шлюзом во внешнюю сеть и веб-сервером). Технология &lt;span class="caps"&gt;VP&lt;/span&gt; основана на построении правил фильтрации &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; по результатам работы средств статического анализа защищенности приложения (static application security testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;). Однако из-за того, что средства &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; опираются на различные модели представления приложения и различные методы принятия решений, на рынке до сих пор нет по-настоящему эффективных решений их интеграции. В рамках &lt;span class="caps"&gt;SAST&lt;/span&gt; работа с приложением осуществляется по модели белого ящика и, как правило, используются формальные подходы к поиску уязвимостей в коде. Для &lt;span class="caps"&gt;WAF&lt;/span&gt; же приложение представляет собой черный ящик, а для детектирования атак применяются эвристики. Это не позволяет эффективно использовать &lt;span class="caps"&gt;VP&lt;/span&gt; для защиты от атак в тех случаях, когда условия эксплуатации уязвимости выходят за рамки тривиальной схемы &lt;code&gt;http_parameter=plain_text_attack_vector&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Но что, если «подружить» &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;WAF&lt;/span&gt; таким образом, чтобы информация о внутреннем устройстве приложения, полученная с помощью &lt;span class="caps"&gt;SAST&lt;/span&gt;, стала доступной на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; и дала ему возможность детектировать атаки на обнаруженные уязвимости — не угадывая, но доказывая факт&amp;nbsp;атаки?&lt;/p&gt;
&lt;h2&gt;Блеск и нищета традиционного &lt;span class="caps"&gt;VP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Традиционный подход к автоматизации создания виртуальных патчей для веб-приложений заключается в предоставлении &lt;span class="caps"&gt;WAF&lt;/span&gt; информации о каждой обнаруженной с помощью &lt;span class="caps"&gt;SAST&lt;/span&gt; уязвимости,&amp;nbsp;включающей:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;класс&amp;nbsp;уязвимости;&lt;/li&gt;
&lt;li&gt;уязвимую точку входа в веб-приложение (&lt;span class="caps"&gt;URL&lt;/span&gt; или его&amp;nbsp;часть);&lt;/li&gt;
&lt;li&gt;значения дополнительных параметров &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса, при которых атака становится&amp;nbsp;возможной;&lt;/li&gt;
&lt;li&gt;значения уязвимого параметра — носителя вектора&amp;nbsp;атаки;&lt;/li&gt;
&lt;li&gt;множество символов или слов (токенов), появление которых в уязвимом параметре приведет к эксплуатации&amp;nbsp;уязвимости.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для определения множеств значений параметров &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса и опасных элементов уязвимого параметра могут использоваться как простое перечисление всех возможных элементов, так и генерирующая функция (как правило, на базе регулярных выражений). Рассмотрим фрагмент кода &lt;span class="caps"&gt;ASP&lt;/span&gt;.&lt;span class="caps"&gt;NET&lt;/span&gt;-страницы, уязвимый для атак &lt;a href="https://habrahabr.ru/company/pt/blog/149152/"&gt;&lt;span class="caps"&gt;XSS&lt;/span&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;01&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;02&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;03&lt;/span&gt;
&lt;span class="m"&gt;04&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;05&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;06&lt;/span&gt;      &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wrong parameters!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="m"&gt;07&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;08&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;09&lt;/span&gt;
&lt;span class="m"&gt;10&lt;/span&gt;  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;11&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;secret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;12&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;13&lt;/span&gt;    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;`&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;14&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;15&lt;/span&gt;  &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="m"&gt;16&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;17&lt;/span&gt;    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Secret not found!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;18&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;19&lt;/span&gt;
&lt;span class="m"&gt;20&lt;/span&gt;  &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;b&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;/b&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;В результате анализа этого кода для вектора атаки будет выведена символическая формула условного множества его&amp;nbsp;значений: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;{condition = "secret" ⇒ param ∈ { XSShtml-text }}, где XSShtml-text — множество возможных векторов XSS-атаки в контексте TEXT, описанном в грамматике HTML&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Из этой формулы может быть выведен как эксплойт, так и виртуальный патч. На основе дескриптора виртуального патча &lt;span class="caps"&gt;WAF&lt;/span&gt; формирует правила фильтрации, позволяющие блокировать все &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросы, выполнение которых может привести к эксплуатации найденной&amp;nbsp;уязвимости. &lt;/p&gt;
&lt;p&gt;Такой подход, безусловно, позволяет защищаться от некоторого множества атак, однако обладает и существенными&amp;nbsp;недостатками:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;для доказательства наличия уязвимости средству &lt;span class="caps"&gt;SAST&lt;/span&gt; достаточно обнаружить один из возможных векторов атак на нее. Для эффективного устранения уязвимости необходимо защититься от всех возможных векторов, которые бывает затруднительно сообщить на сторону &lt;span class="caps"&gt;WAF&lt;/span&gt;, поскольку их множество не только бесконечно, но и зачастую не может быть выражено регулярными выражениями в силу нерегулярности грамматик векторов&amp;nbsp;атак;&lt;/li&gt;
&lt;li&gt;то же самое касается и значений всех дополнительных параметров запроса, при которых становится возможна эксплуатация&amp;nbsp;уязвимости;&lt;/li&gt;
&lt;li&gt;информация об опасных элементах уязвимого параметра бесполезна в том случае, если на пути от точки входа до уязвимой точки выполнения вектор атаки подвергается промежуточным преобразованиям, изменяющим контекст его грамматики или даже всю грамматику (например, Base64-, &lt;span class="caps"&gt;URL&lt;/span&gt;- или &lt;span class="caps"&gt;HTML&lt;/span&gt;-кодирование, строковые&amp;nbsp;преобразования).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти недостатки приводят к тому, что технология &lt;span class="caps"&gt;VP&lt;/span&gt;, ориентированная на защиту от частных случаев, не позволяет эффективно защититься от всех возможных атак на обнаруженные с помощью средств &lt;span class="caps"&gt;SAST&lt;/span&gt; уязвимости. Кроме того, построенные таким образом правила фильтрации трафика часто приводят к блокированию штатных &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов и нарушению работы защищаемого приложения. Немного изменим уязвимый&amp;nbsp;код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;01&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;02&lt;/span&gt;  &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="m"&gt;03&lt;/span&gt; 
&lt;span class="m"&gt;04&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="p"&gt;||&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="m"&gt;05&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;06&lt;/span&gt;      &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wrong parameters!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="m"&gt;07&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;08&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;09&lt;/span&gt; 
&lt;span class="m"&gt;10&lt;/span&gt;  &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;11&lt;/span&gt;  &lt;span class="c1"&gt;// CustomDecode реализует цепочку преобразований base64-URL-base64&lt;/span&gt;
&lt;span class="m"&gt;12&lt;/span&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomDecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;Contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;secret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="m"&gt;13&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;14&lt;/span&gt;      &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;CustomDecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;`&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;15&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;16&lt;/span&gt;  &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="m"&gt;17&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="m"&gt;18&lt;/span&gt;       &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Secret not found!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="m"&gt;19&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;20&lt;/span&gt; 
&lt;span class="m"&gt;21&lt;/span&gt;  &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Разница с предыдущим примером лишь в том, что теперь оба параметра запроса подвергаются некоторому преобразованию и условие на параметр &lt;code&gt;secret&lt;/code&gt; ослаблено до включения подстроки. Формула вектора атаки в результате анализа этого кода примет&amp;nbsp;вид: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(String.Contains (CustomDecode (condition)) ("secret"))  ⇒ param ∈ (CustomDecode { XSShtml-text })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;При этом для функции CustomDecode в соответствующей вершине CompFG анализатором будет выведена формула, описывающая цепочку преобразований Base64-&lt;span class="caps"&gt;URL&lt;/span&gt;-Base64: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Base64Decode (UrlDecode (Base64Decode argument)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;По формулам такого вида все еще возможно построить эксплойт (об этом я подробно рассказывал в одной из предыдущих &lt;a href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html"&gt;статей&lt;/a&gt;), однако применить классический подход к построению виртуальных патчей здесь уже не представляется возможным,&amp;nbsp;поскольку:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;эксплуатация уязвимости возможна только в том случае, если декодированный параметр запроса &lt;code&gt;condition&lt;/code&gt; будет содержать подстроку &amp;#8220;secret&amp;#8221; (строка 12), но множество значений такого параметра весьма велико, а выразить его через регулярные выражения затруднительно из-за нерегулярных функций&amp;nbsp;декодирования;&lt;/li&gt;
&lt;li&gt;параметр запроса, являющийся вектором атаки, также подвергается декодированию (строка 14), что не позволяет средству &lt;span class="caps"&gt;SAST&lt;/span&gt; сформировать для &lt;span class="caps"&gt;WAF&lt;/span&gt; множество его опасных&amp;nbsp;элементов.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Поскольку все проблемы традиционного &lt;span class="caps"&gt;VP&lt;/span&gt; растут из отсутствия возможности работать с приложением на уровне &lt;span class="caps"&gt;WAF&lt;/span&gt; по модели белого ящика, очевидно, что для их устранения необходимо реализовать такую возможность и доработать подход таким образом,&amp;nbsp;чтобы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;средство &lt;span class="caps"&gt;SAST&lt;/span&gt; предоставляло &lt;span class="caps"&gt;WAF&lt;/span&gt; полную информацию обо всех преобразованиях, которым подвергаются уязвимый параметр и переменные условий успешной атаки на пути от точки входа до уязвимой точки, чтобы &lt;span class="caps"&gt;WAF&lt;/span&gt; получил возможность вычислять значения аргументов в ней, исходя из значений параметров обрабатываемого &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса;&lt;/li&gt;
&lt;li&gt;для детектирования атаки использовались не эвристические, а формальные методы, основанные на строгом доказательстве тех или иных утверждений и покрывающие общий случай условий эксплуатации каждой конкретной уязвимости — вместо ограниченного множества&amp;nbsp;частных.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Так и родилась технология виртуального патчинга времени&amp;nbsp;выполнения.&lt;/p&gt;
&lt;h2&gt;Runtime virtual&amp;nbsp;patching&lt;/h2&gt;
&lt;p&gt;В основе технологии runtime virtual patching (&lt;span class="caps"&gt;RVP&lt;/span&gt;) лежит используемая в анализаторе исходных кодов &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector (&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;) модель исследуемого приложения под названием «граф потоков вычисления» (computation flow graph, CompFG). Эта модель была подробно описана в рамках мастер-класса &lt;a href="https://www.youtube.com/watch?v=apQEQQm6GaE&amp;amp;feature=youtu.be"&gt;«Трущобы AppSec»&lt;/a&gt; на PHDays &lt;span class="caps"&gt;VII&lt;/span&gt;. CompFG строится во время анализа приложения в результате абстрактной интерпретации его кода в семантике, схожей с традиционными символическими вычислениями. Вершины данного графа содержат генерирующие формулы на целевом языке, задающие множества допустимых значений всех потоков данных, присутствующих в соответствующих точках выполнения. Эти потоки называются аргументами точки выполнения.  Например, вершина уязвимой точки выполнения рассмотренного выше примера в CompFG выглядит&amp;nbsp;так:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/compfg-example.png"&gt;&lt;img alt="Пример CompFG" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/compfg-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Одним из свойств CompFG является его конкретизируемость — возможность вычислить множества конкретных значений всех аргументов в любой точке выполнения приложения, задав значения для всех входных&amp;nbsp;параметров. &lt;/p&gt;
&lt;p&gt;Рабочий процесс &lt;span class="caps"&gt;RVP&lt;/span&gt; делится на два этапа, соответствующих этапам жизненного цикла приложения — развертывание (шаги D) и выполнение (шаги&amp;nbsp;R):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/rvp-workflow.png"&gt;&lt;img alt="Рабочий процесс RVP" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/rvp-workflow.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Этап&amp;nbsp;развертывания&lt;/h3&gt;
&lt;p&gt;Перед развертыванием очередной версии приложения осуществляется его анализ с помощью &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt;, в результате которого из каждой вершины CompFG, описывающей уязвимую точку выполнения, выводятся три&amp;nbsp;формулы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;условие достижимости самой&amp;nbsp;точки;&lt;/li&gt;
&lt;li&gt;условие достижимости значений всех ее&amp;nbsp;аргументов;&lt;/li&gt;
&lt;li&gt;множества значений всех ее аргументов и грамматик, которым они&amp;nbsp;соответствуют.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все наборы формул группируются по признаку принадлежности уязвимости к потоку управления той или иной точки входа в веб-приложение. Само понятие точки входа специфично для каждого из поддерживаемых &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; веб-фреймворков и определено в базе знаний&amp;nbsp;анализатора. &lt;/p&gt;
&lt;p&gt;После этого отчет c обнаруженными уязвимостями и относящимися к ним формулами выгружается в виде кода на специальном языке предметной области, основанном на синтаксисе S-выражений и позволяющем описывать формулы CompFG в форме, не зависящей от целевого языка. Формула значения аргумента уязвимой точки рассмотренного ранее примера кода выглядит следующим&amp;nbsp;образом:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(+ ("Parameter value is ``") (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (param))))) ("``"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;а формула условия ее&amp;nbsp;достижимости:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Contains (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (condition))))) ("secret"))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Полученный отчет загружается в &lt;span class="caps"&gt;PT&lt;/span&gt; Application Firewall (&lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt;), и на его основе генерируется бинарный модуль, позволяющий вычислять все присутствующие в нем формулы. Декомпилированный код расчета условия достижимости уязвимой точки рассмотренного примера выглядит&amp;nbsp;так: &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/evaluator-example.png"&gt;&lt;img alt="Пример вычислителя" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/evaluator-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Для того, чтобы вычисление формул было возможным, на стороне &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt; необходимо иметь (на&amp;nbsp;выбор):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;некоторую базу вычислителей всех функций, которые могут появиться в&amp;nbsp;отчете;&lt;/li&gt;
&lt;li&gt;изолированную песочницу со средой выполнения для языка или платформы, на которой работает защищаемое приложение (&lt;span class="caps"&gt;CLR&lt;/span&gt;, &lt;span class="caps"&gt;JVM&lt;/span&gt;, интерпретатор &lt;span class="caps"&gt;PHP&lt;/span&gt;, Python или Ruby и т.п.), и библиотеками, которые используются в&amp;nbsp;приложении.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Первый вариант дает максимальное быстродействие, но предполагает огромный объем ручной работы со стороны разработчиков &lt;span class="caps"&gt;WAF&lt;/span&gt; по описанию вычислителей (даже если ограничиваться только функциями стандартных библиотек). Второй вариант дает возможность вычислять все функции, которые могут встретиться в отчете, но и увеличивает время обработки каждого &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса из-за необходимости вызова среды выполнения для вычисления каждой функции. Оптимальным здесь является вариант, при котором для наиболее часто встречающихся функций используется первый вариант, а все остальные вычисляются с помощью&amp;nbsp;второго.&lt;/p&gt;
&lt;p&gt;Вполне возможна ситуация, когда в формуле встретится функция, в которую анализатор не сможет «провалиться» (например, вызов метода, относящегося к отсутствующей зависимости проекта или к native-коду) и (или) вычисление которой также невозможно на стороне &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AF&lt;/span&gt; (например, функция чтения данных из внешних источников или окружения сервера). Такие функции отмечаются в формулах флагом unknown и обрабатываются особым образом (см.&amp;nbsp;ниже).&lt;/p&gt;
&lt;h3&gt;Этап&amp;nbsp;эксплуатации&lt;/h3&gt;
&lt;p&gt;На этапе эксплуатации при каждом &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросе &lt;span class="caps"&gt;WAF&lt;/span&gt; делегирует его обработку сгенерированному бинарному модулю. Модуль анализирует запрос и определяет относящуюся к нему точку входа в веб-приложение. Для этой точки выбираются формулы всех обнаруженных в результате ее анализа уязвимостей — и далее вычисляются определенным&amp;nbsp;образом.&lt;/p&gt;
&lt;p&gt;Сначала вычисляются формулы обоих условий: достижимости уязвимой точки и значений всех ее аргументов. Вместо переменных в каждую формулу подставляются значения соответствующих параметров запроса, после чего вычисляется ее значение. Если в формуле присутствуют выражения с флагом unknown, она обрабатывается следующим&amp;nbsp;образом:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;каждый флаг unknown распространяется по дереву выражений формулы снизу вверх до тех пор, пока им не будет отмечено какое-либо булево&amp;nbsp;выражение;&lt;/li&gt;
&lt;li&gt;все такие выражения (unknown-области) заменяются в формуле на булевы переменные и для полученной формулы решается задача булевой&amp;nbsp;выполнимости;&lt;/li&gt;
&lt;li&gt;из исходной формулы условия конструируются n условий — путем подстановки возможных значений unknown-областей из всех найденных на предыдущем шаге&amp;nbsp;решений;&lt;/li&gt;
&lt;li&gt;вычисляется значение каждой из полученных формул, и если хотя бы одна из них оказалась выполнима, то исходное условие также считается&amp;nbsp;выполнимым.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если в результате вычисления было получено ложное значение исходной формулы, то это значит, что данный &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запрос не может привести приложение в уязвимую точку с опасными значениями всех ее аргументов. В этом случае &lt;span class="caps"&gt;RVP&lt;/span&gt; просто возвращает обработку запроса основному модулю &lt;span class="caps"&gt;WAF&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;В случае выполнимости условий атаки на уязвимость наступает очередь вычисления значения аргумента уязвимой точки. Используемый для этого алгоритм зависит от класса уязвимости, к которому относится обрабатываемая точка. Общей для них является только логика обработки формул, содержащих unknown-ноды: в отличие от формул условий, такие формулы аргументов не могут быть вычислены каким-либо образом, о чем сразу сообщается &lt;span class="caps"&gt;WAF&lt;/span&gt; — и затем осуществляется переход к вычислению следующей уязвимой точки. В качестве примера рассмотрим наиболее сложный из алгоритмов, используемый для детектирования атак класса&amp;nbsp;инъекций.&lt;/p&gt;
&lt;h3&gt;Детектирование&amp;nbsp;инъекций&lt;/h3&gt;
&lt;p&gt;К классу инъекций относятся любые атаки, целью которых является нарушение целостности текста на каком-либо формальном языке (&lt;span class="caps"&gt;HTML&lt;/span&gt;, &lt;span class="caps"&gt;XML&lt;/span&gt;, JavaScript, &lt;span class="caps"&gt;SQL&lt;/span&gt;, &lt;span class="caps"&gt;URL&lt;/span&gt;, файловые пути и т. п.), формируемого на основе данных, контролируемых атакующим. Атака осуществляется через передачу приложению специально сформированных входных данных, подстановка которых в атакуемый текст приведет к выходу за пределы токена и внедрению в текст синтаксических конструкций, не предусмотренных логикой&amp;nbsp;приложения.&lt;/p&gt;
&lt;p&gt;В том случае, если текущая уязвимая точка приложения относится к данному классу атак, значение ее аргумента рассчитывается по алгоритму так называемого инкрементального вычисления с абстрактной интерпретацией в семантике taint-анализа. Суть данного алгоритма заключается в том, что каждое выражение формулы рассчитывается отдельно, снизу вверх, причем результат вычисления, полученный на каждом шаге, дополнительно размечается границами «загрязненности», исходя из семантики каждой вычисленной функции и правил &lt;a href="https://en.wikipedia.org/wiki/Taint_checking"&gt;традиционного taint-анализа&lt;/a&gt;. Это позволяет выделить в конечном результате вычисления все фрагменты, которые были получены в результате каких-либо преобразований входных данных&amp;nbsp;(tainted-фрагменты).&lt;/p&gt;
&lt;p&gt;Например, для приведенного выше кода и &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса с параметрами &lt;code&gt;condition=YzJWamNtVjA%3d&lt;/code&gt; и &lt;code&gt;param=UEhOamNtbHdkRDVoYkdWeWRDZ3hLVHd2YzJOeWFYQjBQZyUzRCUzRA%3d%3d&lt;/code&gt; результат применения этого алгоритма для формулы аргумента уязвимой точки будет выглядеть следующим образом (красным отмечены&amp;nbsp;tainted-фрагменты):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/incremental-evaluation-exampe.png"&gt;&lt;img alt="Пример инрементального вычисления" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/incremental-evaluation-exampe.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Далее полученное значение разбивается на токены в соответствии с грамматикой аргумента уязвимой точки, и если на любой из tainted-фрагментов пришлось более одного токена, то это и является формальным признаком детектированной атаки (по определению&amp;nbsp;инъекции):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/tokenization-example.png"&gt;&lt;img alt="Пример токенизации" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/tokenization-example.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;По окончании вычисления формул всех уязвимостей, относящихся к текущей точке входа, обработка запроса передается в основной модуль &lt;span class="caps"&gt;WAF&lt;/span&gt; вместе с результатами&amp;nbsp;детектирования.&lt;/p&gt;
&lt;h3&gt;Преимущества и особенности &lt;span class="caps"&gt;RVP&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Реализованный таким образом подход к защите приложения на основе результатов анализа защищенности его кода обладает рядом существенных преимуществ по сравнению с традиционным &lt;span class="caps"&gt;VP&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;за счет описанного выше формального подхода и возможности учитывать любые промежуточные преобразования выходных данных устранены все указанные недостатки традиционного &lt;span class="caps"&gt;VP&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;формальный подход также полностью исключает возможность появления ошибок первого рода (ложных срабатываний, false positive), при условии отсутствия в формулах&amp;nbsp;unknown-нод;&lt;/li&gt;
&lt;li&gt;отсутствие какого-либо негативного влияния на функции веб-приложения, поскольку защита реализуется не просто в соответствии с ними, а на их же&amp;nbsp;основе.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для обкатки технологии и подтверждения ее эффективности был разработан прототип модуля интеграции &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector и &lt;span class="caps"&gt;PT&lt;/span&gt; Application Firewall в виде &lt;span class="caps"&gt;HTTP&lt;/span&gt;-модуля веб-сервера &lt;span class="caps"&gt;IIS&lt;/span&gt; под платформу .&lt;span class="caps"&gt;NET&lt;/span&gt;. Демонстрацию его работы с рассмотренным примером кода можно посмотреть на &lt;a href="https://www.youtube.com/watch?v=U1NbKuZkb8c"&gt;YouTube&lt;/a&gt;. Тесты производительности на полутора десятках открытых &lt;span class="caps"&gt;CMS&lt;/span&gt; показали более чем приемлемые результаты: время обработки &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов с помощью &lt;span class="caps"&gt;RVP&lt;/span&gt; оказалось сравнимо со временем их обработки традиционными (эвристическими) методами &lt;span class="caps"&gt;WAF&lt;/span&gt;. Средний процент замедления реакции веб-приложения на запросы&amp;nbsp;составил:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0% при обработке запросов, не приводящих в уязвимую&amp;nbsp;точку;&lt;/li&gt;
&lt;li&gt;6–10% при обработке запросов, приводящих в уязвимую точку, но не являющихся атакой (в зависимости от сложности грамматики уязвимой&amp;nbsp;точки);&lt;/li&gt;
&lt;li&gt;4–7% при обработке запросов, приводящих в уязвимую точку и являющихся&amp;nbsp;атакой.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Несмотря на очевидные преимущества перед традиционным &lt;span class="caps"&gt;VP&lt;/span&gt;, &lt;span class="caps"&gt;RVP&lt;/span&gt; все же обладает рядом концептуальных ограничений, от которых хотелось бы&amp;nbsp;избавиться:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;отсутствует возможность вычислять значения таких формул, в которых присутствуют внешние данные из источников, отсутствующих на стороне &lt;span class="caps"&gt;WAF&lt;/span&gt; (файловых ресурсов, БД, окружение сервера и т.&amp;nbsp;п.);&lt;/li&gt;
&lt;li&gt;качество формул напрямую зависит от качества аппроксимации некоторых фрагментов кода во время его анализа (циклы, рекурсия, вызовы методов внешних библиотек и т.&amp;nbsp;п.);&lt;/li&gt;
&lt;li&gt;описание семантики преобразующих функций для базы вычислителей требует некоторого количества инженерной работы, которая слабо автоматизируется и допускает появление ошибок, связанных с человеческим&amp;nbsp;фактором.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Впрочем, и эти недостатки оказалось возможным устранить, перенеся часть функциональности &lt;span class="caps"&gt;RVP&lt;/span&gt; на сторону приложения и применив технологии, лежащие в основе самозащиты приложений времени выполнения (runtime application self-protection, &lt;span class="caps"&gt;RASP&lt;/span&gt;).&lt;/p&gt;
&lt;h2&gt;Advanced &lt;span class="caps"&gt;RASP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;По сути, подход &lt;span class="caps"&gt;ARASP&lt;/span&gt; подразумевает применение самого приложения для вычисления тех фрагментов формулы, которые невозможно вычислить при помощи &lt;span class="caps"&gt;RVP&lt;/span&gt;. Для интеграции в веб-приложение сенсоров детектирования, при помощи которых можно получить значения любых фрагментов формул, вычисляемых &lt;span class="caps"&gt;RVP&lt;/span&gt;, на стороне приложения используется дополнительный модуль&amp;nbsp;инструментирования.&lt;/p&gt;
&lt;p&gt;Процесс &lt;span class="caps"&gt;ARASP&lt;/span&gt; представляет собой рассмотренный выше процесс &lt;span class="caps"&gt;RVP&lt;/span&gt; со следующими&amp;nbsp;дополнениями:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;В выгруженном из &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; отчете каждое выражение в формуле имеет дополнительный атрибут — его координаты в&amp;nbsp;коде:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parameter value is `&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;36&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;FromBase64Str&lt;/span&gt;   
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;35&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UrlDecodeStr&lt;/span&gt; 
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;32&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;FromBase64Str&lt;/span&gt;   
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aspx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;31&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;GetParameterData&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;При помощи данного отчета генерируется не только модуль вычисления формул, но и модуль инструментирования, который выполняется на стороне приложения. Этот модуль встраивает сенсоры детектирования во все точки выполнения приложения, которые соответствуют неопределенным выражениям в отчете, а также устанавливает точки останова, которые перед переходом к уязвимой точке выполнения передают управление &lt;span class="caps"&gt;RVP&lt;/span&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/instrumented-code.png"&gt;&lt;img alt="Инструментированный код" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/instrumented-code.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="caps"&gt;RVP&lt;/span&gt; не принимает на себя управление при обработке &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запросов: приложению дается возможность обработать запрос до точки останова, стоящей перед уязвимой точкой выполнения (при достижении этой точки &lt;span class="caps"&gt;RVP&lt;/span&gt; уже соберет информацию со всех сенсоров детектирования, активированных до этой&amp;nbsp;точки).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;При достижении точки останова обработка &lt;span class="caps"&gt;HTTP&lt;/span&gt;-запроса передается &lt;span class="caps"&gt;RVP&lt;/span&gt;, и формулы рассчитываются способом, описанным в предыдущем разделе, с одним существенным отличием: если в формуле содержится неопределенное выражение или выражение, которое невозможно вычислить при помощи &lt;span class="caps"&gt;RVP&lt;/span&gt; (по причине ссылок на внешние источники данных или отсутствия необходимой преобразующей функции в базе знаний), тогда значение выражения берется из информации, которая была собрана после активации сенсоров&amp;nbsp;детектирования.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;При обнаружении атаки обработка запроса прекращается (и, следовательно, приложение не доходит до уязвимой точки&amp;nbsp;выполнения).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;При отсутствии атаки задача по обработке запроса возвращается приложению до момента достижения следующей точки останова или до тех пор, пока не завершится обработка&amp;nbsp;запроса.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Этот подход значительно расширяет возможности технологии &lt;span class="caps"&gt;RVP&lt;/span&gt;, устраняя ее недостатки в плане качества защиты&amp;nbsp;приложений.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/arasp-workflow.png"&gt;&lt;img alt="Рабочий процесс ARASP" src="https://kochetkov.github.io/images/2017-09-20.do-wafs-dream-of-static-analyzers/arasp-workflow.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Преимущества &lt;span class="caps"&gt;ARASP&lt;/span&gt;: больше чем просто виртуальный&amp;nbsp;патчинг&lt;/h3&gt;
&lt;p&gt;В &lt;span class="caps"&gt;PT&lt;/span&gt; &lt;span class="caps"&gt;AI&lt;/span&gt; можно настроить экспорт формул для всех потенциально уязвимых точек выполнения без выявления в них уязвимостей, что обеспечит полное покрытие всех опасных фрагментов кода приложения. Именно эта функция делает &lt;span class="caps"&gt;ARASP&lt;/span&gt; комплексным решением по защите приложений. В этом &lt;span class="caps"&gt;WAF&lt;/span&gt; нового поколения применяется модель белого ящика и используются формальные методы вместо эвристических. По сравнению с традиционным подходом &lt;span class="caps"&gt;RASP&lt;/span&gt; у этого решения есть несколько&amp;nbsp;преимуществ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;незначительное снижение производительности (обработка запроса фрагментами приложения происходит параллельно с обработкой этого же запроса модулем &lt;span class="caps"&gt;WAF&lt;/span&gt; с работающим &lt;span class="caps"&gt;ARASP&lt;/span&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;минимальный урон стабильности приложения (инструментирование применяется только для тех точек исполнения, которые действительно необходимы для вычисления&amp;nbsp;формул);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;точное (практически 100%) обнаружение атак благодаря использованию методов модели CompFG и формальных методов для работы на этих&amp;nbsp;элементах.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Таким образом, &lt;span class="caps"&gt;RVP&lt;/span&gt; и &lt;span class="caps"&gt;ARASP&lt;/span&gt; являются многообещающим перспективным решением в обеспечении защиты приложений, и мы продолжим разрабатывать их в качестве основного вектора улучшения интеграции между &lt;span class="caps"&gt;PT&lt;/span&gt; Application Inspector и &lt;span class="caps"&gt;PT&lt;/span&gt; Application&amp;nbsp;Firewall.&lt;/p&gt;</content><category term="Блог"></category><category term="SAST"></category><category term="static code analysis"></category><category term="Application Inspector"></category><category term="WAF"></category><category term="Application Firewall"></category></entry><entry><title>Материалы вебинара “Подводные камни прикладной криптографии I”</title><link href="https://kochetkov.github.io/webinar-applied-cryptography-pitfalls-1.html" rel="alternate"></link><published>2016-10-07T12:00:00+03:00</published><updated>2016-10-07T12:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-10-07:/webinar-applied-cryptography-pitfalls-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.slideshare.net/kochetkov.vladimir/i-66826448"&gt;Слайды&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.webinar.ru/record/845596/"&gt;Запись&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Большинство ссылок и дополнительных материалов, о которых я упоминал в ходе вебинара, есть в слайдах (и теперь их можно нажать&amp;nbsp;:)). &lt;/p&gt;
&lt;p&gt;Дополнительно: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://xakep.ru/2015/06/03/web-app-hack-keep-alive/"&gt;статья&lt;/a&gt; Семёна Рожкова об использовании &lt;span class="caps"&gt;HTTP&lt;/span&gt; keep-alive для усиления временнЫх побочных&amp;nbsp;каналов;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробный &lt;a href="http://portal.idc.ac.il/en/schools/cs/research/documents/sinai_2011.pdf"&gt;разбор&lt;/a&gt; реализаций &lt;span class="caps"&gt;PRNG&lt;/span&gt; в стандартных библиотеках языков C, Java, C#, &lt;span class="caps"&gt;PHP&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;краткая &lt;a href="https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages"&gt;шпаргалка&lt;/a&gt; о генерации криптографических случайных чисел в различных языках (включая многострадальный &lt;span class="caps"&gt;PHP&lt;/span&gt;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;неплохая &lt;a href="https://jazzy.id.au/tags/prng.html"&gt;серия статей&lt;/a&gt; о техниках взлома различных &lt;span class="caps"&gt;PRNG&lt;/span&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks"&gt;описание&lt;/a&gt; атаки удлинения&amp;nbsp;сообщения;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;подробное &lt;a href="https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth"&gt;описание&lt;/a&gt; атаки на оракул&amp;nbsp;дополнения.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S: Было бы совсем здорово, если бы участники вебинара не поленились черкнуть пару слов о том, что им (не) понравилось и какие темы были бы им интересны в следующей части&amp;nbsp;вебинара.&lt;/p&gt;</content><category term="Блог"></category><category term="вебинары"></category><category term="криптография"></category></entry><entry><title>Ищем уязвимости в коде: теория, практика и перспективы SAST</title><link href="https://kochetkov.github.io/sast-theory-practice-and-prospects.html" rel="alternate"></link><published>2016-07-08T04:00:00+03:00</published><updated>2016-07-08T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-07-08:/sast-theory-practice-and-prospects.html</id><summary type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Не будет большим преувеличением сказать, что рынок средств статического тестирования защищенности приложений (Static Application Security Testing, &lt;span class="caps"&gt;SAST&lt;/span&gt;) в наше время переживает самый настоящий бум. Не проходит и пары месяцев между публикациями очередных научных работ на эту тему, ежегодно на рынок выводятся все новые и новые инструменты статического анализа защищенности, а месту &lt;span class="caps"&gt;SAST&lt;/span&gt; в процессе разработки ПО отводятся целые секции на международных ИБ-конференциях. В условиях непрерывного информационного прессинга со стороны поставщиков инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt;, нелегко разобраться в том, что есть правда, а что − не более, чем маркетинговые уловки, слабо коррелирующие с действительностью. Давайте попробуем понять, что же действительно под силу инструментам &lt;span class="caps"&gt;SAST&lt;/span&gt; и как быть с тем, что им «не по зубам». Для этого нам придется немного погрузиться в теорию, лежащую в основе современных средств статического анализа защищенности&amp;nbsp;кода.&lt;/p&gt;
&lt;h2&gt;Тьюринг, Райс - вот эти вот&amp;nbsp;все&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;/&lt;span class="caps"&gt;DR&lt;/span&gt;: задача статического тестирования защищенности программ алгоритмически&amp;nbsp;неразрешима.&lt;/p&gt;
&lt;p&gt;Представьте себе множество полностью абстрактных программ P, которые только и умеют, что зависать на одних наборах входных данных и останавливаться через некоторое число операций на других. Очевидно, что класс P охватывает любые теоретически возможные программы, поскольку это свойство можно приписать любой из&amp;nbsp;них. &lt;/p&gt;
&lt;p&gt;Теперь представьте, что одна из таких программ (назовем ее h) является анализатором, умеющим отвечать на простой вопрос: зависает ли произвольная программа p из множества P на заданном наборе данных n? Очевидно, что отвечать на этот вопрос h сможет только завершая свою работу и тем самым сообщая, что p зависает на n. Иными словами, если p(n) не останавливается, то h(p(n)) должна завершить свою работу за конечное число шагов, а если p(n) останавливается, то h(p(n)) должна&amp;nbsp;зависнуть. &lt;/p&gt;
&lt;p&gt;Ну, а теперь представьте, что произойдет, если мы попробуем ответить с помощью такого анализатора на вопрос: зависнет ли он сам, в результате анализа самого себя, анализирующего самого себя (ведь p может быть любой программой из P, значит она может быть и самой h)? В этом случае получается, что если h(h(n)) остановится, то анализ h(n) зависает, а если h(h(n))) зависает, то анализ h(n) останавливается. Но ведь h как раз и есть h(n), а, следовательно, мы здесь имеем противоречие и анализатор подобный h не имеет права на&amp;nbsp;существование.&lt;/p&gt;
&lt;p&gt;Описанное является вольным изложением доказательства Теоремы останова, сформулированной Алланом Тьюрингом (основоположником современной теоретической информатики) в далеком 1936-м. Данная теорема утверждает, что не существует такой программы, которая могла бы проанализировать другую программу и ответить на вопрос, остановится ли та на заданном наборе входных данных. Хорошо, но можем ли мы построить такую программу, которая дает ответ на вопрос о каких-либо других свойствах&amp;nbsp;программ?&lt;/p&gt;
&lt;p&gt;Поскольку множество P включает в себя все возможные программы, мы всегда можем разбить его на два класса (пусть будут A и B) по признаку наличия у программ любого нетривиального инвариантного свойства. Под нетривиальным инвариантным свойством подразумевается такое свойство, которым любая программа множества P либо обладает, либо не обладает и при этом все функционально тождественные программы (дающие одни и те же наборы данных на выходе при одинаковых наборах данных на входе) либо все вместе обладают этим свойством, либо все вместе не&amp;nbsp;обладают.&lt;/p&gt;
&lt;p&gt;Давайте представим, что есть некоторый анализатор q, который принимает на вход произвольную программу p множества P и останавливается, если p относится к одному из классов. Пусть, для определенности, это будет класс A. Пусть pa - программа, относящаяся к классу A и зацикливающаяся на любом входе. Выберем также из класса B произвольную программу pb. Для каждой программы p определим программу p&amp;#8217;, получающую на вход данные x и выполняющую следующий&amp;nbsp;алгоритм:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p(p)&lt;/li&gt;
&lt;li&gt;pb(x)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Теперь построим программу q&amp;#8217;, которая получает на вход произвольную программу p, строит для нее p&amp;#8217; и вычисляет&amp;nbsp;q(p&amp;#8217;). &lt;/p&gt;
&lt;p&gt;Если p&amp;#8217; зависает на первом шаге, значит p&amp;#8217; функционально тождественна pa (и относится к классу A), а, следовательно, q&amp;#8217; должна немедленно остановиться. Если p&amp;#8217; проходит первый шаг, то p&amp;#8217; функционально тождественна pb (и относится к классу B), а, следовательно, q&amp;#8217; должна зависнуть. Таким образом, для любой программы p, q&amp;#8217;(p) останавливается тогда, когда p(p) не останавливается. Но в роли p может оказаться и сама q&amp;#8217;, следовательно, p(p) останавливается только тогда, когда p(p) не останавливается. Снова пришли к&amp;nbsp;противоречию. &lt;/p&gt;
&lt;p&gt;Утверждение о том, что не существует такой программы, которая могла бы давать ответ на вопрос о наличии любых нетривиальных инвариантных свойств у произвольно взятой программы, доказал ученый Генри Райс в 1953 году. Фактически, его работа обобщает Теорему останова, поскольку свойство останавливаться на заданном наборе данных является нетривиальным и инвариантным. Теорема Райса имеет бесконечное множество практических значений, в зависимости от рассматриваемых свойств: «невозможно с помощью программы классифицировать алгоритм, реализуемый другой программой», «невозможно с помощью программы доказать, что две других программы реализуют один и тот же алгоритм», «невозможно с помощью программы доказать, что другая программа на любых наборах данных не входит в какие-либо состояния…» и т.п. И вот на последнем примере стоит остановиться&amp;nbsp;подробнее.&lt;/p&gt;
&lt;p&gt;В момент выполнения любого (как абстрактного, так и реального) алгоритма некоей универсальной выполняющей программой (например, виртуальной машиной, эмулирующей полноценный компьютер с установленной ОС), можно взять снимок этой машины, включая состояние самой выполняемой программы в адресном пространстве машины и ее внешнего окружения, такого, как дисковые накопители, состояние внешних устройств и т.п. и позднее, восстановив его, продолжить выполнение программы с того же самого места. По сути, весь процесс выполнения любой программы, представляет собой череду сменяющихся состояний, последовательность которых как раз и определяется ее кодом. При этом, в случае наличия каких-либо ошибок в конфигурации или реализации, как самой программы, так и выполняющей ее машины, велика вероятность того, что процесс выполнения войдет в состояние, которое изначально не предполагалось&amp;nbsp;разработчиками.&lt;/p&gt;
&lt;p&gt;А что есть уязвимость? Это возможность с помощью входных данных заставить процесс выполнения войти в такое состояние, которое приведет к реализации какой-либо из угроз в отношении обрабатываемой процессом информации. Следовательно, можно определить свойство защищенности любой программы, как ее способность в каждый момент времени оставаться, вне зависимости от изначальных входных данных, в рамках заранее определенного множества допустимых состояний, определяющего политику ее безопасности. При этом, задача анализа защищенности программы очевидно сводится к анализу невозможности ее перехода в любое неразрешенное политикой безопасности состояние на произвольном наборе входных данных. То есть, к той самой задаче, алгоритмическая неразрешимость которой была давным-давно доказана Генри&amp;nbsp;Райсом.&lt;/p&gt;
&lt;p&gt;Так получается, что же… весь рынок инструментария &lt;span class="caps"&gt;SAST&lt;/span&gt; – это индустрия обмана? В теории – да, на практике же, всё как обычно - возможны&amp;nbsp;варианты.&lt;/p&gt;
&lt;h2&gt;Теория &lt;span class="caps"&gt;SAST&lt;/span&gt; на&amp;nbsp;практике&lt;/h2&gt;
&lt;p&gt;Даже оставаясь в теоретическом поле, вполне возможно сделать несколько послаблений утверждению Райса для реальных программ, выполняющихся в реальных средах. Во-первых, в теоретической информатике под «программой» подразумевается математическая абстракция, эквивалентная машине Тьюринга (МТ) – самому мощному из вычислительных автоматов. Однако же, в реальных программах далеко не каждый фрагмент их кода эквивалентен МТ. Ниже по иерархии вычислительной мощности находятся линейно-ограниченные, стековые и конечные автоматы. Анализ защищенности двух последних вполне возможен, даже в рамках самой теоретической&amp;nbsp;теории.&lt;/p&gt;
&lt;p&gt;Во-вторых, отличительной особенностью МТ является то, что ей доступна память бесконечного размера. Именно из этой особенности вытекает невозможность получить все возможные состояния вычислительного процесса – их попросту бесконечное число. Однако, в реальных компьютерах память далеко не бесконечна. Что еще важнее, в реальных программах число состояний, представляющих интерес с точки зрения задачи анализа защищенности, также конечно (хотя и неприлично&amp;nbsp;велико).&lt;/p&gt;
&lt;p&gt;В-третьих, вычисление свойств программы по Райсу, является разрешимой проблемой для ряда малых МТ, имеющих небольшое количество состояний и возможных переходов между ними. Сложно себе представить реальную программу, имеющую от 2 до 4 состояний. Однако, такой &lt;em&gt;фрагмент&lt;/em&gt; программы представить себе гораздо&amp;nbsp;легче.&lt;/p&gt;
&lt;p&gt;Следовательно, возможен эффективный анализ отдельных фрагментов кода программы, попадающих под перечисленных критерии. На практике, это означает,&amp;nbsp;что:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;фрагмент кода без циклов и рекурсии может быть всесторонне проанализирован, т.к. эквивалентен конечному&amp;nbsp;автомату;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;фрагмент с циклами или рекурсией, условие выхода из которых не зависит от входных данных, поддается анализу в качестве конечного или стекового&amp;nbsp;автомата;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;если условия выхода из цикла или рекурсии зависят от входных данных, длина которых ограничена некоторым разумным порогом, то такой фрагмент в отдельных случаях получится проанализировать как систему линейно-ограниченных автоматов или малых&amp;nbsp;МТ.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;А вот все остальное – увы и ах − статическим подходом проанализировать не удастся. Более того, разработка анализатора защищённости исходного кода - это такое направление, работая в котором инженеры ежедневно сталкиваются с трейдофом &lt;span class="caps"&gt;EXPSPACE&lt;/span&gt; &amp;lt;-&amp;gt; &lt;span class="caps"&gt;EXPTIME&lt;/span&gt;, а сводя даже частные случаи к субэкспоненте, радуются как дети, потому что это по-настоящему круто. Подумайте над тем, какова будет мощность множества значений переменной parm1 в последней точке&amp;nbsp;выполнения?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Вот поэтому о теоретических ограничениях можно не особо беспокоиться, поскольку упереться в них на текущих вычислительных мощностях будет крайне затруднительно. Однако же, перечисленные послабления этих ограничений задают правильное направление развития современных статических анализаторов, поэтому иметь в виду их все же&amp;nbsp;стоит.   &lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;DAST&lt;/span&gt;, &lt;span class="caps"&gt;IAST&lt;/span&gt; и&amp;nbsp;все-все-все&lt;/h2&gt;
&lt;p&gt;В противовес статическому подходу, работающему с кодом программы без его фактического выполнения, динамический (Dynamic Application Security Testing, &lt;span class="caps"&gt;DAST&lt;/span&gt;) подразумевает наличие развернутой среды выполнения приложения и ее прогон на наиболее интересных с точки зрения анализа наборах входных данных. Упрощая, его можно охарактеризовать, как метод «осознанного научного тыка» («давайте передадим программе вот такие данные, характерные вот для такой атаки и посмотрим, что же из этого выйдет»). Его недостатки очевидны: далеко не всегда есть возможность быстро развернуть анализируемую систему (а зачастую и просто собрать), переход системы в какое-либо состояние может быть следствием обработки предыдущих наборов данных, да и для всестороннего анализа поведения реальной системы количество наборов входных данных должно быть настолько велико, что о его конечности можно рассуждать исключительно&amp;nbsp;теоретически.&lt;/p&gt;
&lt;p&gt;Относительно недавно перспективным считался подход, комбинирующий преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt; – интерактивный анализ (Interactive…, &lt;span class="caps"&gt;IAST&lt;/span&gt;). Отличительной особенностью этого подхода является то, что &lt;span class="caps"&gt;SAST&lt;/span&gt; используется для формирования наборов входных данных и шаблонов ожидаемых результатов, а &lt;span class="caps"&gt;DAST&lt;/span&gt; выполняет тестирование системы на этих наборах, опционально привлекая к процессу человека-оператора в неоднозначных ситуациях. Ирония этого подхода заключается в том, что он вобрал в себя как преимущества, так и недостатки &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, что не могло не сказаться на его практической&amp;nbsp;применимости.&lt;/p&gt;
&lt;p&gt;Но кто сказал, что в случае динамического анализа нужно выполнять всю программу целиком? Как было показано выше, вполне реально проанализировать значительную часть кода с помощью статического подхода. Что же мешает проанализировать с помощью динамического только оставшиеся фрагменты? Звучит, как&amp;nbsp;план…&lt;/p&gt;
&lt;h2&gt;А внутре у ней&amp;nbsp;неонка&lt;/h2&gt;
&lt;p&gt;Существует несколько традиционных подходов к статическому анализу, отличающихся моделью, на основе которой анализатор выводит те или иные свойства исследуемого кода. Самым примитивным и очевидным является сигнатурный поиск, основанный на поиске вхождений какого-либо шаблона в синтаксическую модель представления кода (как правило, это либо поток токенов, либо абстрактное синтаксическое дерево). Отдельные реализации этого подхода используют чуть более сложные модели (семантическое дерево, его отображение на граф отдельных потоков данных и т.п.), но в целом этот подход можно рассматривать исключительно в качестве вспомогательного, позволяющего за линейное время выделить в коде подозрительные места для последующей ручной верификации. Подробнее останавливаться на нём не будем, интересующиеся могут обратиться к посвященной ему &lt;a href="https://habrahabr.ru/company/pt/blog/300946/"&gt;серии статей&lt;/a&gt; Ивана&amp;nbsp;Кочуркина.&lt;/p&gt;
&lt;p&gt;Более сложные подходы оперируют уже моделями выполнения (а не представления или семантики) кода. Такие модели, как правило, позволяют получить ответ на вопрос &amp;#8220;может ли контролируемый извне поток данных достичь какой-либо точки выполнения, в которой это приведет к возникновению уязвимости?&amp;#8221;. В большинстве случаев, модель здесь представляет собой вариацию на тему графов &lt;a href="https://en.wikipedia.org/wiki/Control_flow_graph"&gt;потока выполнения&lt;/a&gt; и &lt;a href="https://en.wikipedia.org/wiki/Data_flow_diagram"&gt;потоков данных&lt;/a&gt;, либо их комбинацию (например, &lt;a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf"&gt;граф свойств кода&lt;/a&gt;). Недостаток подобных подходов также очевиден - в любом нетривиальном коде одного только ответа на этот вопрос недостаточно для успешного детектирования уязвимости. Например, для&amp;nbsp;фрагмента:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;requestParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;filteredParam&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filteredParam&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;такой анализатор выведет из построенной модели утвердительный ответ о достижимости потоком данных &lt;code&gt;Request.Params["param"]&lt;/code&gt; точки выполнения &lt;code&gt;Response.Write(filteredParam)&lt;/code&gt; и существовании в данной точке уязвимости к &lt;span class="caps"&gt;XSS&lt;/span&gt;. В то время, как на самом деле, данный поток эффективно фильтруется и не может являться носителем вектора атаки. Существует множество способов покрыть частные случаи, связанные с предварительной обработкой потоков данных, но все они в конечном итоге сводятся к разумному балансу между ложными срабатываниями первого и второго&amp;nbsp;типа.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Type 1 &amp;amp; 2 errors" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/type12errors.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Каким образом можно минимизировать появление ошибок обоих типов? Для этого необходимо учитывать условия достижимости как потенциально уязвимых точек выполнения, так и множеств значений потоков данных, приходящих в такие точки. На основе этой информации становится возможным построить систему уравнений, множество решений которой даст все возможные наборы входных данных, необходимые для того, чтобы прийти в потенциально уязвимую точку программы. Пересечение этого множества со множеством всех возможных векторов атаки, даст множество всех наборов входных данных, приводящих программу в уязвимое состояние. Звучит отлично, но как получить модель, которая содержала бы всю необходимую&amp;nbsp;информацию?&lt;/p&gt;
&lt;h2&gt;Абстрактная интерпретация и символические&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Допустим, перед нами стоит задача определить, число с каким знаком определяет выражение &lt;code&gt;-42 / 8 * 100500&lt;/code&gt;. Самый простой способ - это вычислить данное выражение и убедиться, что получено отрицательное число. Вычисление выражения с вполне определенными значениями всех его аргументов называется конкретным вычислением. Но есть и другой способ решить эту задачу. Давайте на секунду представим, что по какой-то причине у нас нет возможности конкретно вычислить данное выражение. Например, если в него добавилась переменная &lt;code&gt;-42 / 8 * 100500 * x&lt;/code&gt;. Определим абстрактную арифметику, в которой результат операций над числами определяется исключительно правилом знака, а значения их аргументов&amp;nbsp;игнорируются:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(+a) = (+)&lt;/span&gt;
&lt;span class="err"&gt;(-a) = (-)&lt;/span&gt;
&lt;span class="err"&gt;(-) * (+) = (-)&lt;/span&gt;
&lt;span class="err"&gt;(-) / (+) = (-)  &lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;(-) + (+) = (+-)&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Интерпретируя исходное выражение в рамках данной семантики, получаем: &lt;code&gt;(-) / (+) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-) * (+)&lt;/code&gt; -&amp;gt; &lt;code&gt;(-)&lt;/code&gt;. Этот подход будет давать однозначный ответ на поставленную задачу до тех пор, пока в выражении не появятся операции сложения или вычитания. Давайте дополним нашу арифметику таким образом, чтобы значения аргументов операций также&amp;nbsp;учитывались:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(-a) * (+b) = (-c)&lt;/span&gt;
&lt;span class="err"&gt;(-a) / (+b) = (-c)  &lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;(-a) + (+b) = &lt;/span&gt;
&lt;span class="err"&gt;    a &amp;lt;= b -&amp;gt; (+)&lt;/span&gt;
&lt;span class="err"&gt;    a &amp;gt;  b -&amp;gt; (-)&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Интерпретируя выражение &lt;code&gt;-42 / 8 * 100500 + x&lt;/code&gt; в новой семантике получим результат &lt;code&gt;x &amp;gt;= -527625 -&amp;gt; (+), x &amp;lt; -527625 -&amp;gt; (-)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Описанный выше подход называется &lt;a href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;абстрактной интерпретацией&lt;/a&gt; и формально определяется, как устойчивая аппроксимация семантики выражений, основанная на монотонных функциях над упорядоченными множествами. Говоря более простым языком, это интерпретация выражений без их конкретного вычисления с целью сбора информации в рамках заданного семантического поля. Если мы плавно перейдем от интерпретации отдельных выражений к интерпретации кода программы на каком-либо языке, а в качестве семантического поля определим семантику самого языка, дополненную правилом оперировать всеми входными данными, как неизвестными переменными (символическими значениями), то мы получим подход, именуемый &lt;a href="https://en.wikipedia.org/wiki/Symbolic_execution"&gt;&amp;#8220;символическим выполнением&amp;#8221;&lt;/a&gt; и лежащий в основе большинства перспективных направлений статического анализа&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Именно с помощью символических вычислений становится возможным построение контекстного графа символического вычисления (альтернативное название: граф потока вычислений) - модели, всесторонне описывающей процесс вычисления исследуемой программы. Эта модель была рассмотрена в докладе &lt;a href="http://www.slideshare.net/kochetkov.vladimir/ss-48743308/14"&gt;&amp;#8220;Автоматическая генерация патчей для исходного кода&amp;#8221;&lt;/a&gt;, а ее применение для анализа защищенности кода - в статье &lt;a href="https://habrahabr.ru/company/pt/blog/224547/"&gt;&amp;#8220;Об анализе исходного кода и автоматической генерации эксплоитов&amp;#8221;&lt;/a&gt;. Вряд ли имеет смысл рассматривать их повторно в рамках данной статьи. Необходимо лишь отметить, что эта модель позволяет получить условия достижимости как любой точки потока выполнения, так и множеств значений всех приходящих в нее аргументов. То есть - именно то, что требуется нам для решения нашей&amp;nbsp;задачи.&lt;/p&gt;
&lt;h2&gt;Поиск уязвимостей на графе потока&amp;nbsp;вычисления&lt;/h2&gt;
&lt;p&gt;Формализовав в терминах графа потока вычислений критерии уязвимости к тому или иному классу атак, мы сможем реализовать анализ защищенности кода через разрешение свойств конкретной модели, полученной в результате абстрактной интерпретации исследуемого кода. Например, критерии уязвимости к атакам любых инъекций (SQLi, &lt;span class="caps"&gt;XSS&lt;/span&gt;, XPATHi, Path Traversal и т.п.) можно формализовать примерно&amp;nbsp;так:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Пусть C - граф потока вычисления исследуемого&amp;nbsp;кода.&lt;/p&gt;
&lt;p&gt;Пусть pvf(t) - достижимая вершина потока управления на C, являющаяся вызовом функции прямой или косвенной интерпретации текста t, соответствующего формальной грамматике&amp;nbsp;G.&lt;/p&gt;
&lt;p&gt;Пусть e - поток аргумента входных данных на&amp;nbsp;С. &lt;/p&gt;
&lt;p&gt;Пусть De - множество потоков данных на C, порождаемых от e и достижимых в точке вызова&amp;nbsp;pvf(t).&lt;/p&gt;
&lt;p&gt;Тогда приложение уязвимо к атакам инъекции в точке вызова pvf(t), если t принадлежит De и множество значений De включает в себя хотя бы одну пару элементов, при которых, в результате их синтаксического разбора в соответствии с грамматикой G, получаются не изоморфные друг-другу&amp;nbsp;деревья.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Аналогичным образом формализуются уязвимости и к другим классам атак. Однако, здесь необходимо заметить, что не все типы уязвимостей возможно формализовать в рамках какой-либо модели, выводимой только из анализируемого кода. В отдельных случаях может потребоваться дополнительная информация. Например, для формализации уязвимостей к атакам на бизнес-логику, необходимо иметь формализованные правила предметной области приложения, для формализации уязвимостей к атакам на контроль доступа - формализованную политику разграничения доступа и&amp;nbsp;т.п.&lt;/p&gt;
&lt;h2&gt;Идеальный сферический анализатор защищенности кода в&amp;nbsp;вакууме&lt;/h2&gt;
&lt;p&gt;Давайте теперь ненадолго отвлечемся от суровой реальности и чуть-чуть помечтаем о том, какой функциональностью должно обладать ядро гипотетического Идеального Анализатора (назовем его условно &amp;#8220;&lt;span class="caps"&gt;IA&lt;/span&gt;&amp;#8221;)?&lt;/p&gt;
&lt;p&gt;Во-первых, оно должно вбирать в себя преимущества &lt;span class="caps"&gt;SAST&lt;/span&gt; и &lt;span class="caps"&gt;DAST&lt;/span&gt;, не включая при этом их недостатки. Из этого в частности следует, что &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь работать исключительно с имеющимся кодом приложения (исходным или бинарным), не требуя при этом его полноты или развертывания приложения в исполняющей среде. Иными словами, он должен поддерживать анализ проектов с отсутствующими внешними зависимостями или же какими-либо другими факторами, препятствующими сборке и развертыванию приложения. При этом, работа с фрагментами кода, имеющего ссылки на отсутствующие зависимости, должна быть реализована в настолько полной мере, насколько это возможно в каждом конкретном случае. С другой стороны, &lt;span class="caps"&gt;IA&lt;/span&gt; должен уметь эффективно &amp;#8220;уворачиваться&amp;#8221; не только от теоретических ограничений, накладываемых тьюринговой моделью вычислений, но и осуществлять сканирование за разумное время, потребляя разумное количество памяти и придерживаясь по возможности субэкспоненциальной &amp;#8220;весовой&amp;nbsp;категории&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Во-вторых, вероятность появления ошибок первого рода должна быть сведена к минимуму за счет построения и решения систем логических уравнений и генерации на выходе работающего вектора атаки, позволяющего пользователю подтвердить существование уязвимости одним&amp;nbsp;действием. &lt;/p&gt;
&lt;p&gt;В-третьих, &lt;span class="caps"&gt;IA&lt;/span&gt; должен эффективно бороться с ошибками второго рода, предоставляя пользователю возможность ручной проверки всех потенциально уязвимых точек потока выполнения, уязвимость которых сам &lt;span class="caps"&gt;IA&lt;/span&gt; не смог ни подтвердить, ни&amp;nbsp;опровергнуть.&lt;/p&gt;
&lt;p&gt;Использование модели, основанной на символических вычислениях, позволяет реализовать все эти требования, что называется &amp;#8220;by-design&amp;#8221;, за исключением той их части, которая касается теоретических ограничений и субэкспонент. И здесь, как нельзя кстати, придется наш план - использовать динамический анализ там, где не справился&amp;nbsp;статический. &lt;/p&gt;
&lt;h2&gt;Частичные вычисления, обратные функции и отложенная&amp;nbsp;интерпретация&lt;/h2&gt;
&lt;p&gt;Представьте себе, что &lt;span class="caps"&gt;IA&lt;/span&gt; содержит в себе некоторую базу знаний, описывающую семантику функций преобразования входных данных, реализованных в стандартной библиотеке языка или исполняющей среды приложения, наиболее популярных фреймворках и &lt;span class="caps"&gt;CMS&lt;/span&gt;. Например, что функции Base64Decode и Base64Encode являются взаимно-обратными, или что каждый вызов StringBuilder.Append добавляет новую строку к уже хранящейся в промежуточной переменной-аккумуляторе этого класса и т.п. Обладая такими знаниями &lt;span class="caps"&gt;IA&lt;/span&gt; будет избавлен от необходимости «проваливаться» в библиотечный код, анализ которого также попадает под все вычислительные&amp;nbsp;ограничения:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Нужное для выполнения условия значение для cond2 будет выведено солвером на основе информации базы знаний об обратных функциях &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;param&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// Значение sb.ToString будет получено в результаты эмуляции семантики StringBuilder, описанной в базе знаний библиотечных функций&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Но что делать, если в коде встречается вызов функции, не описанной в базе знаний &lt;span class="caps"&gt;IA&lt;/span&gt;? Давайте представим, что в распоряжении &lt;span class="caps"&gt;IA&lt;/span&gt; есть некая виртуальная среда-песочница, позволяющая запустить произвольный фрагмент анализируемого кода в заданном контексте и получить результат его выполнения. Назовём это &amp;#8220;частичным вычислением&amp;#8221;. Тогда, перед тем, как честно «провалиться» в неизвестную функцию и начинать её абстрактно интерпретировать, &lt;span class="caps"&gt;IA&lt;/span&gt; может попробовать проделать трюк, называемый «частичным фаззингом». Его общая идея заключается в предварительной подготовке базы знаний по библиотечным трансформирующим функциям и сочетаниям их последовательных вызовов на заранее известных наборах пробных данных. Имея такую базу, можно выполнить неизвестную функцию на тех же наборах данных и сравнить полученные результаты с образцами из базы знаний. Если результаты выполнения неизвестной функции совпадут с результатами выполнения известной цепочки библиотечных функций, то это будет значить, что &lt;span class="caps"&gt;IA&lt;/span&gt; теперь известна семантика неизвестной функции и в ее интерпретации нет&amp;nbsp;необходимости.&lt;/p&gt;
&lt;p&gt;Если же для какого-то фрагмента известны множества значений всех потоков данных, приходящих в этот фрагмент, а сам фрагмент не содержит опасных операций, то &lt;span class="caps"&gt;IA&lt;/span&gt; может просто выполнить его на всех возможных потоках данных и использовать полученные результаты вместо абстрактной интерпретации данного фрагмента кода. Причем этот фрагмент может относиться к любому классу вычислительной сложности и это никак не отразится на результатах его выполнения. Более того, даже если множества значений потоков данных, приходящих во фрагмент, заранее неизвестны, &lt;span class="caps"&gt;IA&lt;/span&gt; может отложить интерпретацию этого фрагмента до тех пор, пока не начнется решение уравнения для конкретной опасной операции. На этапе решения на множество значений входных данных накладывается дополнительное ограничение о наличии во входных данных векторов тех или иных атак, что может позволить предположить также и множество значений входных данных, приходящих в отложенный фрагмент и, тем самым, частично вычислить его на данном&amp;nbsp;этапе.&lt;/p&gt;
&lt;p&gt;Даже более того, на этапе решения ничего не мешает &lt;span class="caps"&gt;IA&lt;/span&gt; взять конечную формулу достижимости опасной точки и ее аргументов (которую проще всего строить в синтаксисе и семантике того же языка, на котором написан анализируемый код) и &amp;#8220;профаззить&amp;#8221; ее всеми известными значениями векторов на предмет получения их подмножества, проходящего через все фильтрующие функции&amp;nbsp;формулы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Ззначение аргумента Response.Write, проходящее через фильтрующую функцию без изменений, может быть получено в результате фаззинга его формулы постановкой в parm1 значений всех возможных векторов XSS &lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Описанные выше подходы позволяют справиться с анализом значительной части фрагментов тьюринг-полного кода, но требуют существенной инженерной проработки как в части наполнения базы знаний и оптимизации эмулирования семантики стандартных типов, так и в части реализации песочницы для частичного выполнения кода (никто не захочет, чтобы в процессе анализа внезапно выполнилось что-то вроде File.Delete в цикле), а также поддержки фаззинга n-местных неизвестных функций, интеграции концепции частичного вычисления с &lt;span class="caps"&gt;SMT&lt;/span&gt;-солвером и т.п. Однако же, никаких существенных ограничений на их реализацию нет, в отличии от граблей классического &lt;span class="caps"&gt;SAST&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Когда гадкий duck-typing становится&amp;nbsp;лебедем&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Duck-typing" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ducktyping.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Представьте, что нам необходимо проанализировать следующий&amp;nbsp;код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// UnknownType - тип, объявленный в отсутствующей зависимости &lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Человек без труда увидит здесь достижимую уязвимость к &lt;span class="caps"&gt;XSS&lt;/span&gt;. А вот большинство существующих статических анализаторов ее благополучно прошляпят в связи с тем, что им ничего не известно о типе UnknownType. Однако все, что здесь требуется от &lt;span class="caps"&gt;IA&lt;/span&gt; - это забыть о статической типизации и перейти к утиной. Семантика интерпретации таких конструкций должна полностью зависеть от контекста их использования. Да, интерпретатор ничего не знает о том, чем является &lt;code&gt;UnknownType.Property1&lt;/code&gt; - свойством, полем, или даже делегатом (ссылкой на метод в C#). Но поскольку операции с ней осуществляются как с переменной-мембером какого-то типа, интерпретатору ничего не мешает обрабатывать их именно таким образом. А если, к примеру, далее по коду встретится конструкция &lt;code&gt;UnknownType.Property1()&lt;/code&gt;, то ничто не мешает интерпретировать вызов того метода, ссылка на который была ранее присвоена Property1. И так далее, в лучших традициях заводчиков&amp;nbsp;уток-чемпионов.&lt;/p&gt;
&lt;h2&gt;Подводя&amp;nbsp;итоги&lt;/h2&gt;
&lt;p&gt;Разумеется, есть масса маркетинговых свистелок, которыми один анализатор якобы выгодно отличается от другого, с точки зрения продающей его стороны. Но, согласитесь, в них нет никакого проку, если ядро продукта не в состоянии обеспечить базовую функциональность, ради которой его и будут использовать. А для того, чтобы её обеспечить, анализатор обязан стремиться по своим возможностям к описанному &lt;span class="caps"&gt;IA&lt;/span&gt;. Иначе ни о какой реальной защищенности на обрабатываемых им проектах и речи быть не&amp;nbsp;может. &lt;/p&gt;
&lt;p&gt;Несколько лет назад, один из наших клиентов обратился к нам за проведением анализа защищенности разрабатываемой им системы. В числе вводных данных он предоставил отчет об анализе кода их проекта продуктом, являвшимся на тот момент лидером на рынке &lt;span class="caps"&gt;SAST&lt;/span&gt;-инструментария. Отчет содержал около двух тысяч записей, большинство из которых оказались в итоге на проверку положительно-ложными срабатываниями. Но самым плохим оказалось то, чего не было в отчете. В результате ручного анализа кода, нами были обнаружены десятки уязвимых мест, пропущенных при сканировании. Использование подобных анализаторов приносит больше вреда, чем пользы, как отнимая время, необходимое для разбора всех ложно-положительных результатов, так и создавая иллюзию защищённости из-за ложно-отрицательных. Этот случай, кстати, стал одной из причин разработки нами собственного&amp;nbsp;анализатора.&lt;/p&gt;
&lt;h2&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Talk is cheap. Show me the&amp;nbsp;code.&amp;#8221;&lt;/h2&gt;
&lt;p&gt;Было бы странным не завершить статью небольшим примером кода, позволяющим проверить степень идеальности того или иного анализатора на практике. Voila - ниже представлен код, включающий в себя все базовые кейсы, покрываемые описанным подходом к абстрактной интерпретации, но не покрываемые более примитивными подходами. Каждый кейс реализован настолько тривиально, насколько это возможно и с минимальным количеством инструкций языка. Это пример для C#/&lt;span class="caps"&gt;ASP&lt;/span&gt;.Net WebForms, но не содержит какой-либо специфики и легко может быть транслирован в код на любом другом ООП-языке и под любой&amp;nbsp;web-фреймворк. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;parm1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ZmFsc2U=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// &amp;quot;false&amp;quot; в base64-кодировке&lt;/span&gt;
&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pvo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// False-negative&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не интерпретирующие поток выполнения по потокам данных функционального типа, не сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;pvo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Для анализаторов, требующих компилируемый код, этот фрагмент необходимо удалить&lt;/span&gt;
&lt;span class="cp"&gt;#region&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;harmless value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property3&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnknownType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Property2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, игнорирующие некомпилируемый код, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endregion&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие условия достижимости точек выполнения, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WebUtility&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HtmlEncode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// False-positive&lt;/span&gt;
&lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику нестандартных фильтрующих функций, сообщат здесь об уязвимости&lt;/span&gt;
&lt;span class="c1"&gt;// (CustomFilter.Filter реализует логику `s.Replace(&amp;quot;&amp;lt;&amp;quot;, string.Empty).Replace(&amp;quot;&amp;gt;&amp;quot;, string.Empty)`)&lt;/span&gt;
&lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomFilterLibrary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CustomFilter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Encoding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UTF8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FromBase64String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не учитывающие семантику стандартных кодирующих функций, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="m"&gt;1725&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, аппроксимирующие или игнорирующие интерпретацию циклов, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sb&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// False-positive&lt;/span&gt;
    &lt;span class="c1"&gt;// Анализаторы, не интерпретирующие семантику типов стандартной библиотеки, сообщат здесь об уязвимости&lt;/span&gt;
    &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parm1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Результатом анализа данного кода должно являться сообщение о единственной уязвимости к атакам &lt;span class="caps"&gt;XSS&lt;/span&gt; в выражении &lt;code&gt;pvo(parm1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Вступить и компилировать с готовым к сканированию проектом можно &lt;a href="https://kochetkov.github.io/uploads/IAMeter.zip"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но, как говорится, &amp;#8220;лучше один раз увидеть&amp;#8230;&amp;#8221; и, в первую очередь, мы проверили на соответствие &lt;span class="caps"&gt;IA&lt;/span&gt; разрабатываемый нами анализатор, по чистой случайности называющийся &lt;a href="http://ai.ptsecurity.ru/"&gt;&lt;span class="caps"&gt;AI&lt;/span&gt;&lt;/a&gt;:  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;img alt="IA" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/ai_ru.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А вы - уже проверили свой?&amp;nbsp;;)&lt;/p&gt;
&lt;h2&gt;На правах бонуса для дочитавших до&amp;nbsp;конца&lt;/h2&gt;
&lt;p&gt;Мы открываем публичное альфа-тестирование бесплатной утилиты Approof. В нее не включена функциональность анализа кода и не используется весь описанный выше матастафический хардкор, зато включена функциональность выявления в проектах уязвимых внешних компонентов, недостатков конфигурации, чувствительных к разглашению данных, а также внедренных веб-шеллов и вредоносного&amp;nbsp;кода:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Approof" src="https://kochetkov.github.io/images/2016-07-08.sast-theory-practice-and-prospects/approof.png"&gt;&lt;/p&gt;
&lt;p&gt;Скачать утилиту можно на &lt;a href="http://approof.ptsecurity.ru/"&gt;официальном сайте&lt;/a&gt;. Перед ее использованием обязательно ознакомьтесь с лицензионным соглашением. В ходе анализа, Approof собирает неконфиденциальную статистику по проекту (&lt;span class="caps"&gt;CLOC&lt;/span&gt;, типы файлов, используемые фреймворки и т.к.) и, опционально, отправляет ее на сервер &lt;span class="caps"&gt;PT&lt;/span&gt;. Отключить отправку статистики или ознакомиться с сырым json, содержащим собранные данные, можно в разделе About&amp;nbsp;приложения.&lt;/p&gt;</content><category term="Блог"></category><category term="SAST"></category><category term="DAST"></category><category term="IAST"></category><category term="статический анализ кода"></category><category term="анализатор кода"></category><category term="Application Inspector"></category></entry><entry><title>По следам PHDays VI</title><link href="https://kochetkov.github.io/following-the-tracks-of-phdays-6.html" rel="alternate"></link><published>2016-06-01T04:00:00+03:00</published><updated>2016-06-01T04:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-06-01:/following-the-tracks-of-phdays-6.html</id><summary type="html">&lt;p&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз Application Inspector нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://phdays.ru"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt; отгремел без малого две недели назад, но случившийся параллельно с ним очередной публичный релиз &lt;a href="http://www.ptsecurity.ru/products/ai/"&gt;Application Inspector&lt;/a&gt; нахлобучил так, что силы написать об этом нашлись только&amp;nbsp;сейчас. &lt;/p&gt;
&lt;p&gt;Внезапно, обещание пропустить все доклады выполнилось само собой и большую часть времени я провел за кулисами, либо очищая &lt;span class="caps"&gt;AI&lt;/span&gt; от лишних фич и готовясь к своему выступлению в промежутках между прогонами тестов, либо выступая на закрытой встрече нашей новой девелоперской юзергруппы, о которой расскажу ниже. В итоге, чуть менее, чем вся конференция для меня выглядела как-то&amp;nbsp;так: &lt;/p&gt;
&lt;p&gt;&lt;img alt="PHDays VI глазами Вовы" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Ни за какими конкурсами я не наблюдал и тем более в них не участвовал (а в окрестностях &lt;span class="caps"&gt;CTF&lt;/span&gt;-зоны вообще появлялся лишь на пару минут и только для того, чтобы урвать себе немного космической еды), с вендорскими ништяками пролетел, во всех форках afterparty не участвовал и т.п. Развиртуализировался (ненавижу это слово) с несколькими френдами / подписчиками, что для интроверта уже немеряный подвиг. Наложил кирпичей, когда мимо меня, прямо за кулисами, несколько раз прошуршал  (ряженый, как выяснилось сильно позже) ОМОН в составе 4&amp;nbsp;бойцов.&lt;/p&gt;
&lt;p&gt;Однако же, гвоздем программы для меня стало мероприятие, проводившееся за ее рамками. Как я уже &lt;a href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html"&gt;писал&lt;/a&gt; ранее, в ходе конференции мы планировали провести первую встречу нашей новой пользовательской юзергруппы девелоперов, интересующихся вопросами разработки защищенных приложений и предметной области application security. В ходе нее планировалось провести сокращенный вариант прошлогоднего мастер-класса для разработчиков банковских приложений. В результате - встреча состоялась, мастер-класс проведен и по полученным отзывам можно с уверенностью сказать, что юзергруппе - быть. В относительно ближайшее время, мы планируем провести еще несколько оффлайн-встреч и вебинаров, посвященных тематике группы. В том числе, и с приглашением сторонних экспертов в различных областях и направлениях, связанных с application security. На встрече разработчики аккуратно получали около 6 часов живительного хардкора о теории и всевозможных практических аспектах проектирования и разработки защищенных приложений от&amp;nbsp;/me:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый /me" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;а поддерживать интерес аудитории мне помогал мой коллега Леша Гончаров, развлекавший народ задачками на ненормальный кодинг и раздававший печеньки особо&amp;nbsp;отличившмся:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Леша" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;В конце встречи мы анонсировали бесплатную утилиту от команды &lt;span class="caps"&gt;AI&lt;/span&gt; с рабочим названием Approof, позволяющую провести сканирование исходного кода проекта на предмет ошибок конфигурации и использования уязвимых компонентов. Участники встречи получили ее альфа-версию, а в скором времени, она будет доступна для загрузки всем&amp;nbsp;желающим. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Тот самый Approof" src="https://kochetkov.github.io/images/2016-05-31.following-the-tracks-of-phdays-6/4.png"&gt;&lt;/p&gt;
&lt;p&gt;Должен заметить, что на встрече я столкнулся с самой живой аудиторией из всех, встречавшихся мне на докладах, митапах и вебинарах. Была масса вопросов, кулуларных обсуждений, со мной пытались спорить и даже помогали вести встречу, отвечая участникам на вопросы, адресованные мне. Один из участников упрекнул нашу компанию в том, что мы даем владельцам веб-приложений слишком жесткие рекомендации по усилению content security policy, которые им, компаниям-разработчикам, потом тяжело выполнять (не зря работаем, значит). На второй день из более, чем полусотни слушателей отсеялось лишь около десятка человек, что как бы намекает. Слайды не выкладываю, т.к. они большей частью являются компиляцией ранее публиковавшихся выступлений и представляют интерес только для участников встречи, которые их и так получили по окончанию мероприятия вместе со всей&amp;nbsp;раздаткой.&lt;/p&gt;
&lt;p&gt;Но, в конечном счете, впечатления от конференции сугубо позитивные, хоть она и прошла для меня в достаточно своеобразном формате, повторять который - лично мне бы не&amp;nbsp;хотелось)&lt;/p&gt;</content><category term="Блог"></category><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Семинар Positive Development User Group</title><link href="https://kochetkov.github.io/phdays6-positive-development-user-group-workshop.html" rel="alternate"></link><published>2016-05-06T00:00:00+03:00</published><updated>2016-05-06T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2016-05-06:/phdays6-positive-development-user-group-workshop.html</id><summary type="html">&lt;p&gt;В этом году, в рамках развития идеи &amp;#8220;&lt;span class="caps"&gt;PT&lt;/span&gt;/PHDays для разработчиков&amp;#8221; эксперты Positive Technologies планируют провести 6-часовой мастер-класс по разработке защищенных&amp;nbsp;приложений.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Идея разработки по-настоящему-полезного-курса-по-разработке-защищенных-приложений-на-котором-не-захочется-спать зародилась в Positive Technologies еще в 2012 году, после проведения серии закрытых вебинаров на эту тему для разработчиков наших партнеров. Позднее, в 2013-ом, на PHDays &lt;span class="caps"&gt;III&lt;/span&gt; был представлен &lt;a href="http://www.slideshare.net/kochetkov.vladimir/hdswasm-russianproofreaded"&gt;воркшоп&lt;/a&gt;, построенный на их материалах. Следующие пару лет, отдельные его фрагменты использовались в различных докладах и курсах, а контент постоянно перерабатывался и дополнялся новыми разделами. Осенью 2015-го, мы с Тимуром Юнусовым объединили свои наработки и провели &lt;a href="https://habrahabr.ru/company/pt/blog/271287/"&gt;двухдневный мастер-класс&lt;/a&gt; для разработчиков банковских приложений. Его изюминкой стала непрерывная смена offensive и defensive направлений рассматриваемых тем. Тимур показывал типовые ошибки разработчиков и их последствия с точки зрения нападающего, а я объяснял, как не допускать их в новом коде и правильно устранять в уже&amp;nbsp;существующем.&lt;/p&gt;
&lt;p&gt;И, поскольку засыпающих в ходе мастер-класса отмечено не было, а отзывы о нем были получены сугубо положительные, мы решили выступить на бис и провести его сокращенный вариант повторно на предстоящей конференции &lt;a href="http://www.phdays.ru/"&gt;PHDays &lt;span class="caps"&gt;VI&lt;/span&gt;&lt;/a&gt;. И не просто выступить, а в рамках первой (и, как мы надеемся, не последней) встречи Positive Development User Group - сообщества разработчиков, интересующихся предметной областью безопасности приложений. Мероприятие будет проводиться вне основной программы конференции в закрытом формате по персональным приглашениям. Заявку на участие можно заполнить &lt;a href="http://goo.gl/forms/rPIlrPeZBk"&gt;здесь&lt;/a&gt;. С программой и расписанием семинара можно ознакомиться в &lt;a href="https://goo.gl/ZIRUR0"&gt;официальном пресс-релизе мероприятия&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;P.S: И да - у нас будут печеньки&amp;nbsp;:) &lt;/p&gt;</content><category term="Блог"></category><category term="phdays"></category><category term="appsec"></category><category term="разработка"></category><category term="мероприятия"></category></entry><entry><title>Переезд блога</title><link href="https://kochetkov.github.io/blog-movement.html" rel="alternate"></link><published>2015-12-15T10:45:00+03:00</published><updated>2015-12-15T10:45:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-12-15:/blog-movement.html</id><content type="html">&lt;p&gt;Давно собирался перенести свой блог с Blogger и наконец сделал это. Со временем, перенесу все хорошие статьи оттуда. Новые статьи будут опубликованы только&amp;nbsp;здесь.&lt;/p&gt;</content><category term="Блог"></category><category term="блог"></category></entry><entry><title>По следам вебинара “Прикладная теория Application Security”</title><link href="https://kochetkov.github.io/webinar-applied-theory-of-the-application-security.html" rel="alternate"></link><published>2015-11-14T00:00:00+03:00</published><updated>2015-11-14T00:00:00+03:00</updated><author><name>Владимир Кочетков</name></author><id>tag:kochetkov.github.io,2015-11-14:/webinar-applied-theory-of-the-application-security.html</id><summary type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Вебинаром остался категорически недоволен =/ Уж сколько твердил сам себе и выслушивал от других, что нужно готовиться заранее, делать тестовые прогоны и выходить на вебинар как минимум с 3-4 версией контента, ан нет - через раз вылезает какая-то суровая генетическая лень, вынуждающая готовить слайды в последний момент и импровизировать во время выступления, на ходу подбирая нужные фразы и пояснения. Посему приношу извинения тем слушателям, которые так и не поняли, что это было. Вероятно в ближайшие месяцы, проведу работу над ошибками в формате статьи или серии заметок, дабы донести основные идеи более внятным и последовательным&amp;nbsp;образом.&lt;/p&gt;
&lt;p&gt;На вебинаре я обещал дать ссылки на несколько статей о символическом исполнении, абстрактной интерпретации и т.п. Поступим проще. Вот &lt;a href="https://www.dropbox.com/sh/sqln21ngapchx3l/AADiJqQuA1U8F4jX3tYly-q9a?dl=0"&gt;здесь&lt;/a&gt; лежит подборка материалов на эти и смежные темы, которые мы в той или иной мере использовали при работе над Application Inspector. Будут вопросы - задавайте в&amp;nbsp;комментариях.&lt;/p&gt;
&lt;p&gt;Что касается книг для дальнейшего чтения, то конкретно по теории есть не так уж и много материалов и практически все мне известные можно собрать по крупицам из подборки выше. Стоит отдельно отметить выступление Meredith L. Patterson, Sergey Bratus на 28C3 в 2011 (&lt;a href="http://www.youtube.com/watch?v=3kEfedtQVOY"&gt;видео&lt;/a&gt;, &lt;a href="http://langsec.org/insecurity-theory-28c3.pdf"&gt;слайды&lt;/a&gt;) и &lt;a href="http://nob.cs.ucdavis.edu/bishop/notes/2008-cse-14/2008-cse-14.pdf"&gt;работу&lt;/a&gt; Matt Bishop с коллегами, которую я упоминал на&amp;nbsp;вебинаре.&lt;/p&gt;
&lt;p&gt;Если говорить о практике, то мой &lt;span class="caps"&gt;TOP&lt;/span&gt; 5 книг, обязательных к прочтению на данную тему следующий (порядок&amp;nbsp;произвольный):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Writing Secure Code, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nostarch.com/tangledweb.htm"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Tangled Web. A Guide to Securing Modern Web&amp;nbsp;Applications&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118026470.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Web Application Hacker&amp;#8217;s Handbook: Finding and Exploiting Security Flaws, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118662091.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Browser Hacker&amp;#8217;s&amp;nbsp;Handbook&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-047008023X.html"&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;The Shellcoder&amp;#8217;s Handbook: Discovering and Exploiting Security Holes, 2nd&amp;nbsp;Edition&amp;#8221;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Собственно, серию &amp;#8220;Handbooks&amp;#8221; данного издательства стоит прочесть&amp;nbsp;всю.&lt;/p&gt;
&lt;p&gt;P.S: Коллегам по конкурирующему цеху: парни, согласитесь, что обсуждать технические вопросы реализации Application Inspector на вебинаре, связанном с ним лишь косвенно - не вполне корректно по отношению к остальным слушателям. Я всегда готов делиться той информацией, которой имею право делиться со всеми, кто попросит. Даже с конкурентами, причем даже с теми конкурентами, руководство которых находится со мной в контрах. И для этого совсем не нужно дожидаться вебинара с моим участием, как повода задать интересующие вас вопросы :) Мои контакты доступны - пишите, звоните, буду рад пообщаться. Я&amp;nbsp;серьезно.&lt;/p&gt;</content><category term="Блог"></category><category term="вебинары"></category></entry></feed>